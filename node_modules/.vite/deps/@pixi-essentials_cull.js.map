{
  "version": 3,
  "sources": ["../../../pixi-graph/node_modules/@pixi-essentials/cull/src/Cull.ts"],
  "sourcesContent": ["import { DisplayObject, Container } from '@pixi/display';\nimport { Rectangle } from '@pixi/math';\n\nconst tempRect = new Rectangle();\n\n/**\n * The culling options for {@code Cull}.\n *\n * @ignore\n * @public\n */\nexport interface ICullOptions\n{\n    recursive: boolean;\n    toggle: 'visible' | 'renderable';\n}\n\n/**\n * Provides a simple, configurable mechanism for culling a subtree of your scene graph.\n *\n * If your scene graph is not static, culling needs to be done before rendering. You\n * can run it on the `prerender` event fired by the renderer.\n *\n * @public\n */\nexport class Cull\n{\n    private _recursive: boolean;\n    private _toggle: 'visible' | 'renderable';\n    private _targetList: Set<DisplayObject>;\n\n    /**\n     * @param options\n     * @param [options.recursive] - whether culling should be recursive\n     * @param [options.toggle='renderable'] - which property of display-object was be set to indicate\n     *      its culling state. It should be one of `renderable`, `visible`.\n     */\n    constructor(options: Partial<ICullOptions> = {})\n    {\n        this._recursive = typeof options.recursive === 'boolean' ? options.recursive : true;\n        this._toggle = options.toggle || 'visible';\n        this._targetList = new Set<DisplayObject>();\n    }\n\n    /**\n     * Adds a display-object to the culling list\n     *\n     * @param target - the display-object to be culled\n     * @return this\n     */\n    add(target: DisplayObject): this\n    {\n        this._targetList.add(target);\n\n        return this;\n    }\n\n    /**\n     * Adds all the display-objects to the culling list\n     *\n     * @param targets - the display-objects to be culled\n     * @return this\n     */\n    addAll(targets: DisplayObject[]): this\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.add(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the culling list\n     *\n     * @param target - the display-object to be removed\n     * @return this\n     */\n    remove(target: DisplayObject): this\n    {\n        this._targetList.delete(target);\n\n        return this;\n    }\n\n    /**\n     * Removes all the passed display-objects from the culling list\n     *\n     * @param targets - the display-objects to be removed\n     * @return this\n     */\n    removeAll(targets: DisplayObject[]): this\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.delete(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the culling list\n     *\n     * @return this\n     */\n    clear(): this\n    {\n        this._targetList.clear();\n\n        return this;\n    }\n\n    /**\n     * @param rect - the rectangle outside of which display-objects should be culled\n     * @param skipUpdate - whether to skip unculling, transform update, bounds calculation. It is\n     *  highly recommended you enable this by calling _this.uncull()_ and _root.getBounds(false)_ manually\n     *  before your render loop.\n     * @return this\n     */\n    cull(rect: Rectangle, skipUpdate = false): this\n    {\n        if (!skipUpdate)\n        {\n            this.uncull();\n        }\n\n        this._targetList.forEach((target) =>\n        {\n            if (!skipUpdate)\n            {\n                // Update transforms, bounds of display-objects in this target's subtree\n                target.getBounds(false, tempRect);\n            }\n\n            if (this._recursive)\n            {\n                this.cullRecursive(rect, target, skipUpdate);\n            }\n            else\n            {\n                // NOTE: If skipUpdate is false, then tempRect already contains the bounds of the target\n                if (skipUpdate)\n                {\n                    target._bounds.getRectangle(rect);\n                }\n\n                target[this._toggle] = tempRect.right > rect.left\n                    && tempRect.left < rect.right\n                    && tempRect.bottom > rect.top\n                    && tempRect.top < rect.bottom;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets all display-objects to the unculled state.\n     *\n     * This happens regardless of whether the culling toggle was set by {@code this.cull} or manually. This\n     * is why it is recommended to one of `visible` or `renderable` for normal use and the other for culling.\n     *\n     * @return this\n     */\n    uncull(): this\n    {\n        this._targetList.forEach((target) =>\n        {\n            if (this._recursive)\n            {\n                this.uncullRecursive(target);\n            }\n            else\n            {\n                target[this._toggle] = false;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Recursively culls the subtree of {@code displayObject}.\n     *\n     * @param rect - the visiblity rectangle\n     * @param displayObject - the root of the subtree to cull\n     * @param skipUpdate - whether to skip bounds calculation. However, transforms are expected to be updated by the caller.\n     */\n    protected cullRecursive(rect: Rectangle, displayObject: DisplayObject, skipUpdate?: boolean): void\n    {\n        // NOTE: getBounds can skipUpdate because updateTransform is invoked before culling.\n        const bounds = skipUpdate\n            ? displayObject._bounds.getRectangle(tempRect)\n            : displayObject.getBounds(true, tempRect);\n\n        displayObject[this._toggle] = bounds.right > rect.left\n            && bounds.left < rect.right\n            && bounds.bottom > rect.top\n            && bounds.top < rect.bottom;\n\n        const fullyVisible = bounds.left >= rect.left\n            && bounds.top >= rect.top\n            && bounds.right <= rect.right\n            && bounds.bottom <= rect.bottom;\n\n        // Only cull children if this display-object is *not* fully-visible. It is expected that the bounds\n        // of children lie inside of its own. Hence, further culling is only required if the display-object\n        // intersects with the boundaries of \"rect\". Otherwise, if the object is fully outside/inside the\n        // screen, the children don't need to be evaluated as they are presumed to be unculled.\n        if (!fullyVisible\n                && displayObject[this._toggle]\n                && (displayObject as Container).children\n                && (displayObject as Container).children.length)\n        {\n            const children = (displayObject as Container).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.cullRecursive(rect, children[i]);\n            }\n        }\n    }\n\n    /**\n     * Recursively unculls the subtree of {@code displayObject}.\n     *\n     * @param displayObject\n     */\n    protected uncullRecursive(displayObject: DisplayObject): void\n    {\n        displayObject[this._toggle] = true;\n\n        if ((displayObject as Container).children && (displayObject as Container).children.length)\n        {\n            const children = (displayObject as Container).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.uncullRecursive(children[i]);\n            }\n        }\n    }\n}\n"],
  "mappings": ";;;;;;AAGA,IAAA,WAAA,IAAA,UAAA;iBAuBA;;;;;;;EAWA,YAAA,UAAA,CAAA,GACA;AACA,SAAA,aAAA,OAAA,QAAA,cAAA,YAAA,QAAA,YAAA;AACA,SAAA,UAAA,QAAA,UAAA;AACA,SAAA,cAAA,oBAAA,IAAA;EACA;;;;;;;EAQA,IAAA,QACA;AACA,SAAA,YAAA,IAAA,MAAA;AAEA,WAAA;EACA;;;;;;;EAQA,OAAA,SACA;AACA,aAAA,IAAA,GAAA,IAAA,QAAA,QAAA,IAAA,GAAA,KACA;AACA,WAAA,YAAA,IAAA,QAAA,CAAA,CAAA;IACA;AAEA,WAAA;EACA;;;;;;;EAQA,OAAA,QACA;AACA,SAAA,YAAA,OAAA,MAAA;AAEA,WAAA;EACA;;;;;;;EAQA,UAAA,SACA;AACA,aAAA,IAAA,GAAA,IAAA,QAAA,QAAA,IAAA,GAAA,KACA;AACA,WAAA,YAAA,OAAA,QAAA,CAAA,CAAA;IACA;AAEA,WAAA;EACA;;;;;;EAOA,QACA;AACA,SAAA,YAAA,MAAA;AAEA,WAAA;EACA;;;;;;;;EASA,KAAA,MAAA,aAAA,OACA;AACA,QAAA,CAAA,YACA;AACA,WAAA,OAAA;IACA;AAEA,SAAA,YAAA,QAAA,CAAA,WACA;AACA,UAAA,CAAA,YACA;AAEA,eAAA,UAAA,OAAA,QAAA;MACA;AAEA,UAAA,KAAA,YACA;AACA,aAAA,cAAA,MAAA,QAAA,UAAA;MACA,OAEA;AAEA,YAAA,YACA;AACA,iBAAA,QAAA,aAAA,IAAA;QACA;AAEA,eAAA,KAAA,OAAA,IAAA,SAAA,QAAA,KAAA,QACA,SAAA,OAAA,KAAA,SACA,SAAA,SAAA,KAAA,OACA,SAAA,MAAA,KAAA;MACA;IACA,CAAA;AAEA,WAAA;EACA;;;;;;;;;EAUA,SACA;AACA,SAAA,YAAA,QAAA,CAAA,WACA;AACA,UAAA,KAAA,YACA;AACA,aAAA,gBAAA,MAAA;MACA,OAEA;AACA,eAAA,KAAA,OAAA,IAAA;MACA;IACA,CAAA;AAEA,WAAA;EACA;;;;;;;;EASA,cAAA,MAAA,eAAA,YACA;AAEA,UAAA,SAAA,aACA,cAAA,QAAA,aAAA,QAAA,IACA,cAAA,UAAA,MAAA,QAAA;AAEA,kBAAA,KAAA,OAAA,IAAA,OAAA,QAAA,KAAA,QACA,OAAA,OAAA,KAAA,SACA,OAAA,SAAA,KAAA,OACA,OAAA,MAAA,KAAA;AAEA,UAAA,eAAA,OAAA,QAAA,KAAA,QACA,OAAA,OAAA,KAAA,OACA,OAAA,SAAA,KAAA,SACA,OAAA,UAAA,KAAA;AAMA,QAAA,CAAA,gBACA,cAAA,KAAA,OAAA,KACA,cAAA,YACA,cAAA,SAAA,QACA;AACA,YAAA,WAAA,cAAA;AAEA,eAAA,IAAA,GAAA,IAAA,SAAA,QAAA,IAAA,GAAA,KACA;AACA,aAAA,cAAA,MAAA,SAAA,CAAA,CAAA;MACA;IACA;EACA;;;;;;EAOA,gBAAA,eACA;AACA,kBAAA,KAAA,OAAA,IAAA;AAEA,QAAA,cAAA,YAAA,cAAA,SAAA,QACA;AACA,YAAA,WAAA,cAAA;AAEA,eAAA,IAAA,GAAA,IAAA,SAAA,QAAA,IAAA,GAAA,KACA;AACA,aAAA,gBAAA,SAAA,CAAA,CAAA;MACA;IACA;EACA;AACA;",
  "names": []
}
