{
  "version": 3,
  "sources": ["../../../pixi-graph/node_modules/@pixi/graphics/src/const.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/styles/FillStyle.ts", "../../../pixi-graph/node_modules/node_modules/tslib/tslib.es6.js", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/buildPoly.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/buildCircle.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/buildRectangle.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/buildRoundedRectangle.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/buildLine.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/ArcUtils.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/BezierUtils.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/QuadraticUtils.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/BatchPart.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/index.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/utils/isPolygonClockwise.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/GraphicsData.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/GraphicsGeometry.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/styles/LineStyle.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/Graphics.ts", "../../../pixi-graph/node_modules/@pixi/graphics/src/index.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/BatchDrawCall.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/BatchPart.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/FillStyle.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/LineStyle.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/BuildData.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/const.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/SegmentPacker.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/core/SmoothGraphicsData.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/shapes/CircleBuilder.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/shapes/RectangleBuilder.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/shapes/RoundedRectangleBuilder.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/shapes/PolyBuilder.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/shapes/index.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/SmoothGraphicsGeometry.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/SmoothShader.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/settings.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/SmoothGraphics.ts", "../../../pixi-graph/node_modules/@pixi/graphics-smooth/src/DashLineShader.ts"],
  "sourcesContent": ["/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nexport enum LINE_JOIN {\n    MITER = 'miter',\n    BEVEL = 'bevel',\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nexport enum LINE_CAP {\n    BUTT = 'butt',\n    ROUND = 'round',\n    SQUARE = 'square'\n}\n\nexport interface IGraphicsCurvesSettings {\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=true - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES: IGraphicsCurvesSettings = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n", "import { Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /** The alpha value used when filling the Graphics object. */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     *\n     * @member {PIXI.Texture}\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform applied to the texture.\n     *\n     * @member {PIXI.Matrix}\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /** If the current fill is visible. */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.FillStyle}\n     */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /**\n     * Reset\n     */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /**\n     * Destroy and don't use after this\n     */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n", "import { earcut } from '@pixi/utils';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Polygon } from '@pixi/math';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n", "// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse } from '@pixi/math';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape as Circle;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n\n        points.length = 0;\n\n        // TODO - bit hacky??\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            const ellipseData = graphicsData.shape as Ellipse;\n\n            width = ellipseData.width;\n            height = ellipseData.height;\n        }\n\n        if (width === 0 || height === 0)\n        {\n            return;\n        }\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(width + height));\n\n        totalSegs /= 2.3;\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n\n        points.push(points[0], points[1]);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        const circle = (graphicsData.shape) as Circle;\n        const matrix = graphicsData.matrix;\n        const x = circle.x;\n        const y = circle.y;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n    },\n};\n", "import type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Rectangle } from '@pixi/math';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n", "import { earcut } from '@pixi/utils';\n\n// for type only\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { RoundedRectangle } from '@pixi/math';\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1: number, n2: number, perc: number): number\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(\n    fromX: number, fromY: number,\n    cpX: number, cpY: number,\n    toX: number, toY: number,\n    out: Array<number> = []): Array<number>\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        // Handle case when first curve points overlaps and earcut fails to triangulate\n        if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y)\n        {\n            continue;\n        }\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        const rrectData = graphicsData.shape as RoundedRectangle;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        // Don't allow negative radius or greater than half the smallest width\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n\n        points.length = 0;\n\n        // No radius, do a simple rectangle\n        if (!radius)\n        {\n            points.push(x, y,\n                x + width, y,\n                x + width, y + height,\n                x, y + height);\n        }\n        else\n        {\n            quadraticBezierCurve(x, y + radius,\n                x, y,\n                x + radius, y,\n                points);\n            quadraticBezierCurve(x + width - radius,\n                y, x + width, y,\n                x + width, y + radius,\n                points);\n            quadraticBezierCurve(x + width, y + height - radius,\n                x + width, y + height,\n                x + width - radius, y + height,\n                points);\n            quadraticBezierCurve(x + radius, y + height,\n                x, y + height,\n                x, y + height - radius,\n                points);\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n", "import { Point, SHAPES } from '@pixi/math';\n\nimport type { Polygon } from '@pixi/math';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\nimport { LINE_JOIN, LINE_CAP, GRAPHICS_CURVES } from '../const';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly straight? */\n        if (Math.abs(cross) < 0.1)\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy);// inner miter point\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));// first segment's outer vertex\n                    verts.push(imx, imy);// inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));// second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));// first segment's inner vertex\n                    verts.push(omx, omy);// outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));// second segment's outer vertex\n                    verts.push(omx, omy);// outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                // Nothing needed\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n", "import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\ninterface IArcLikeShape {\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /* eslint-disable max-len */\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param {number} startX - Start x location of arc\n     * @param {number} startY - Start y location of arc\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param {number[]} points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n    /* eslint-enable max-len */\n}\n", "import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n", "import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n", "import type { LineStyle } from '../styles/LineStyle';\nimport type { FillStyle } from '../styles/FillStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} style\n     * @param {number} startIndex\n     * @param {number} attribStart\n     */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part\n     *\n     * @param {number} endIndex\n     * @param {number} endAttrib\n     */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n", "/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\n// for type only\nimport { BatchPart } from './BatchPart';\nimport { SHAPES } from '@pixi/math';\nimport { BatchDrawCall } from '@pixi/core';\nimport { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n", "import { Polygon } from '@pixi/math';\n\n/**\n * Determine if polygon is clockwise or counterclockwise.\n * @see {@link https://stackoverflow.com/questions/1165647}\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {Polygon} polygon\n * @return {boolean}\n */\nexport function isPolygonClockwise(polygon: Polygon): boolean\n{\n    const points = polygon.points;\n\n    let sum = 0;\n\n    for (let i = 0; i < points.length - 2; i += 2)\n    {\n        sum += (points[i + 2] - points[i]) * (points[i + 3] + points[i + 1]);\n    }\n\n    return sum > 0;\n}\n", "import type { Matrix, SHAPES, IShape } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    shape: IShape;\n    lineStyle: LineStyle;\n    fillStyle: FillStyle;\n    matrix: Matrix;\n    type: SHAPES;\n\n    /** The collection of points. */\n    points: number[] = [];\n\n    /**\n     * The collection of holes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     */\n    holes: Array<GraphicsData> = [];\n    /**\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n     * @param {PIXI.Matrix} [matrix] - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        /**\n         * The shape object to draw.\n         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n         */\n        this.shape = shape;\n\n        /**\n         * The style of the line.\n         * @member {PIXI.LineStyle}\n         */\n        this.lineStyle = lineStyle;\n\n        /**\n         * The style of the fill.\n         * @member {PIXI.FillStyle}\n         */\n        this.fillStyle = fillStyle;\n\n        /**\n         * The transform matrix.\n         * @member {PIXI.Matrix}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The type of the shape, see the Const.Shapes file for all the existing types,\n         * @member {number}\n         */\n        this.type = shape.type;\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return {PIXI.GraphicsData} Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /**\n     * Destroys the Graphics data.\n     *\n     */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n", "import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture,\n    Texture,\n} from '@pixi/core';\n\nimport { isPolygonClockwise } from './utils/isPolygonClockwise';\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n\\    */\n    public static BATCHABLE_SIZE = 100;\n\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /**\n     * Cached bounds.\n     *\n     * @member {PIXI.Bounds}\n     */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Destroys the GraphicsGeometry object.\n     *\n     */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     *\n     * @param {boolean} [allow32Indices] - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices\n     */\n    updateBatches(allow32Indices?: boolean): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length)\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            const need32\n                = attrib > 0xffff && allow32Indices;\n\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     *\n     * @protected\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /**\n     * Packs attributes to single buffer.\n     *\n     * @protected\n     */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            this.processHoles(data.holes);\n\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     *\n     * @param {PIXI.GraphicsData[]} holes - Holes to render\n     * @protected\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    if (isPolygonClockwise(shape as Polygon))\n                    {\n                        lineWidth = lineWidth * (1 - alignment);\n                    }\n                    else\n                    {\n                        lineWidth = lineWidth * alignment;\n                    }\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @protected\n     * @param {number[]} colors - List of colors to add to\n     * @param {number} color - Color to add\n     * @param {number} alpha - Alpha to use\n     * @param {number} size - Number of colors to add\n     * @param {number} offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     *\n     * @protected\n     * @param {number[]} textureIds\n     * @param {number} id\n     * @param {number} size\n     * @param {number} offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @protected\n     * @param {number[]} verts - Vertices\n     * @param {number[]} uvs - UVs\n     * @param {PIXI.Texture} texture - Reference to Texture\n     * @param {number} start - Index buffer start index.\n     * @param {number} size - The size/length for index buffer.\n     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number, size:\n        number, matrix:\n        Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     *\n     * @param {number[]} uvs - array\n     * @param {PIXI.Texture} texture - region\n     * @param {number} start - starting index for uvs\n     * @param {number} size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n", "import { FillStyle } from './FillStyle';\nimport { LINE_JOIN, LINE_CAP } from '../const';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nexport class LineStyle extends FillStyle\n{\n    /** The width (thickness) of any lines drawn. */\n    public width = 0;\n\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    public alignment = 0.5;\n\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP */\n    public native = false;\n\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /** Miter limit. */\n    public miterLimit = 10;\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.LineStyle}\n     */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /**\n     * Reset the line style to default.\n     */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n    }\n}\n", "import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport { Texture, UniformGroup, State, Renderer, BatchDrawCall, Shader } from '@pixi/core';\nimport { BezierUtils, QuadraticUtils, ArcUtils } from './utils';\nimport { hex2rgb } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { LINE_JOIN, LINE_CAP } from './const';\n\n/**\n * Batch element computed from Graphics geometry\n */\nexport interface IGraphicsBatchElement {\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions {\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * Temporary point to use for containsPoint\n     *\n     * @static\n     * @private\n     * @member {PIXI.Point}\n     */\n    static _TEMP_POINT = new Point();\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     *\n     * @member {PIXI.Shader}\n     */\n    public shader: Shader = null;\n\n    /** Renderer plugin for batching */\n    public pluginName = 'batch';\n\n    /**\n     * Current path\n     *\n     * @member {PIXI.Polygon}\n     * @readonly\n     */\n    public currentPath: Polygon = null;\n\n    /**\n     * A collections of batches! These can be drawn by the renderer batch system.\n     *\n     * @member {PIXI.IGraphicsBatchElement[]}\n     */\n    protected batches: Array<IGraphicsBatchElement> = [];\n\n    /** Update dirty for limiting calculating tints for batches. */\n    protected batchTint = -1;\n\n    /** Update dirty for limiting calculating batches.*/\n    protected batchDirty = -1;\n\n    /** Copy of the object vertex data. */\n    protected vertexData: Float32Array = null;\n\n    /**\n     * Current fill style\n     *\n     * @member {PIXI.FillStyle}\n     */\n    protected _fillStyle: FillStyle = new FillStyle();\n\n    /**\n     * Current line style\n     *\n     * @member {PIXI.LineStyle}\n     */\n    protected _lineStyle: LineStyle = new LineStyle();\n\n    /**\n     * Current shape transform matrix.\n     *\n     * @member {PIXI.Matrix}\n     */\n    protected _matrix: Matrix = null;\n\n    /**  Current hole mode is enabled. */\n    protected _holeMode = false;\n    protected _transformID: number;\n    protected _tint: number;\n\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     *\n     * @member {PIXI.State}\n     */\n    private state: State = State.for2d();\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @member {PIXI.GraphicsGeometry}\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n     *        will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, native?: boolean): this;\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {object} [options] - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color = 0x0, alpha = 1, alignment = 0.5, native = false): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            options = { width: options, color, alpha, alignment, native } as ILineStyleOptions;\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param {object} [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     *\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n     * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public beginFill(color = 0, alpha = 1): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param {object} [options] - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<Point>): this\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<Point>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n        if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuint32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches(hasuint32);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /** Populating batches for rendering. */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     *\n     * @param {PIXI.Renderer} renderer\n     * @param {PIXI.BatchDrawCall} drawCall\n     */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;\n                const sampleValues = new Int32Array(MAX_TEXTURES);\n\n                for (let i = 0; i < MAX_TEXTURES; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /** Retrieves the bounds of the graphic shape as a rectangle object. */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.IPointData} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recalculate the vertices.\n     */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n            // ensure that the polygon is completed, and is available for hit detection\n            // (even if the graphics is not rendered yet)\n            this.finishPoly();\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions|boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n", "export * from './const';\nexport * from './styles/FillStyle';\nexport * from './Graphics';\nexport * from './GraphicsData';\nexport * from './GraphicsGeometry';\nexport * from './styles/LineStyle';\n\nimport {\n    buildPoly,\n    buildCircle,\n    buildRectangle,\n    buildRoundedRectangle,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL\n} from './utils';\nimport type { BatchDrawCall } from '@pixi/core/';\nimport type { IShapeBuildCommand } from './utils/IShapeBuildCommand';\nimport type { SHAPES } from '@pixi/math';\n\nexport const graphicsUtils = {\n    buildPoly: buildPoly as IShapeBuildCommand,\n    buildCircle: buildCircle as IShapeBuildCommand,\n    buildRectangle: buildRectangle as IShapeBuildCommand,\n    buildRoundedRectangle: buildRoundedRectangle as IShapeBuildCommand,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS: FILL_COMMANDS as Record<SHAPES, IShapeBuildCommand>,\n    BATCH_POOL: BATCH_POOL as Array<BatchPart>,\n    DRAW_CALL_POOL: DRAW_CALL_POOL as Array<BatchDrawCall>\n};\n", "import { Matrix } from '@pixi/math';\nimport { BaseTexture, BatchTextureArray, Shader, Texture } from '@pixi/core';\nimport { BLEND_MODES } from '@pixi/constants';\n\nexport interface IGraphicsBatchSettings {\n    maxStyles: number;\n    maxTextures: number;\n}\n\nexport function matrixEquals(th: Matrix, matrix: Matrix, eps = 1e-3)\n{\n    return this === matrix || Math.abs(th.a - matrix.a) < eps\n        && Math.abs(th.b - matrix.b) < eps\n        && Math.abs(th.c - matrix.c) < eps\n        && Math.abs(th.d - matrix.d) < eps\n        && Math.abs(th.tx - matrix.tx) < eps\n        && Math.abs(th.ty - matrix.ty) < eps;\n}\n\nexport class BatchStyleArray\n{\n    public textureIds: number[];\n    public matrices: Matrix[];\n    public lines: number[];\n    public count: number;\n\n    constructor()\n    {\n        this.textureIds = [];\n        this.matrices = [];\n        this.lines = [];\n        this.count = 0;\n        // TODO: mapCoord for atlas cases\n        // TODO: gradients?\n    }\n\n    clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            this.textureIds[i] = null;\n            this.matrices[i] = null;\n        }\n        this.count = 0;\n    }\n\n    add(textureId: number, matrix: Matrix,\n        lineWidth: number, lineAlignment: number,\n        settings: IGraphicsBatchSettings): number\n    {\n        const { textureIds, matrices, lines, count } = this;\n\n        for (let i = 0; i < count; i++)\n        {\n            if (lines[i * 2] === lineWidth && lines[i * 2 + 1] === lineAlignment\n                && textureIds[i] === textureId && (matrixEquals(matrices[i], matrix)))\n            {\n                return i;\n            }\n        }\n        if (count >= settings.maxStyles)\n        {\n            return -1;\n        }\n        textureIds[count] = textureId;\n        matrices[count] = matrix;\n        lines[count * 2] = lineWidth;\n        lines[count * 2 + 1] = lineAlignment;\n        this.count++;\n\n        return count;\n    }\n}\n\nexport class BatchDrawCall\n{\n    texArray: BatchTextureArray;\n    styleArray: BatchStyleArray;\n    blend: BLEND_MODES;\n    start: number;\n    size: number;\n    data: any;\n    shader: Shader;\n    TICK: number;\n    settings: IGraphicsBatchSettings;\n\n    constructor()\n    {\n        this.texArray = new BatchTextureArray();\n        this.styleArray = new BatchStyleArray();\n        this.shader = null;\n        this.blend = BLEND_MODES.NORMAL;\n\n        this.start = 0;\n        this.size = 0;\n        this.TICK = 0; // for filling textures\n        this.settings = null;\n        /**\n         * data for uniforms or custom webgl state\n         * @member {object}\n         */\n        this.data = null;\n    }\n\n    clear()\n    {\n        this.texArray.clear();\n        this.styleArray.clear();\n        this.settings = null;\n        this.data = null;\n        this.shader = null;\n    }\n\n    begin(settings: IGraphicsBatchSettings, shader: Shader)\n    {\n        this.TICK = ++BaseTexture._globalBatch;\n        this.settings = settings;\n        this.shader = shader;\n        // start and size calculated outside\n        this.start = 0;\n        this.size = 0;\n        this.data = null;\n        if (shader && (shader as any).settings)\n        {\n            this.settings = (shader as any).settings;\n        }\n    }\n\n    check(shader: Shader): boolean\n    {\n        if (this.size === 0)\n        {\n            this.shader = shader;\n\n            return true;\n        }\n\n        return (this.shader === shader);\n    }\n\n    add(texture: Texture, matrix: Matrix, lineWidth: number, lineAlignment: number): number\n    {\n        const { texArray, TICK, styleArray, settings } = this;\n        const { baseTexture } = texture;\n        // check tex\n\n        if (baseTexture._batchEnabled !== TICK && texArray.count === settings.maxTextures)\n        {\n            return -1;\n        }\n        const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;\n        // check and add style\n        // add1 -> add2 only works in chain, not when there are several adds inside\n        const res = styleArray.add(loc, matrix || Matrix.IDENTITY, lineWidth, lineAlignment, settings);\n\n        if (res >= 0)\n        {\n            // SUCCESS here\n            // add tex\n            if (baseTexture._batchEnabled !== TICK)\n            {\n                baseTexture._batchEnabled = TICK;\n                baseTexture._batchLocation = texArray.count;\n                texArray.elements[texArray.count++] = baseTexture;\n            }\n        }\n\n        return res;\n    }\n}\n", "import { LineStyle } from './LineStyle';\r\nimport { FillStyle } from './FillStyle';\r\n\r\nexport class BatchPart\r\n{\r\n    public style: LineStyle | FillStyle;\r\n    public start: number;\r\n    public size: number;\r\n    public jointEnd: number;\r\n    public attribStart: number;\r\n    public attribSize: number;\r\n    public styleId: number;\r\n    public rgba: number;\r\n\r\n    constructor()\r\n    {\r\n        this.reset();\r\n    }\r\n\r\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\r\n    {\r\n        this.reset();\r\n        this.style = style;\r\n        this.start = startIndex;\r\n        this.attribStart = attribStart;\r\n        this.jointEnd = 0;\r\n    }\r\n\r\n    public end(endIndex: number, endAttrib: number): void\r\n    {\r\n        this.attribSize = endAttrib - this.attribStart;\r\n        this.size = endIndex - this.start;\r\n    }\r\n\r\n    public reset(): void\r\n    {\r\n        this.style = null;\r\n        this.size = 0;\r\n        this.start = 0;\r\n        this.attribStart = 0;\r\n        this.attribSize = 0;\r\n        this.styleId = -1;\r\n        this.rgba = 0;\r\n        this.jointEnd = 0;\r\n    }\r\n}\r\n", "import { Shader, Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\nexport class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    color: number;\n    alpha: number;\n    texture: Texture;\n    matrix: Matrix;\n    matrixTex: Matrix;\n    shader: Shader;\n    visible: boolean;\n    smooth: boolean;\n\n    toJSON()\n    {\n        return this.copyTo({});\n    }\n\n    clone(): FillStyle\n    {\n        return this.copyTo(new FillStyle());\n    }\n\n    copyTo(obj: any): any\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.smooth = this.smooth;\n        obj.matrixTex = null;\n\n        return obj;\n    }\n\n    /**\n     * returns width multiplied by scaleMode\n     */\n    packLineWidth(): number\n    {\n        return 0;\n    }\n\n    reset()\n    {\n        this.color = 0xFFFFFF;\n\n        this.alpha = 1;\n\n        this.texture = Texture.WHITE;\n\n        this.matrix = null;\n\n        this.shader = null;\n\n        this.visible = false;\n\n        this.smooth = false;\n\n        this.matrixTex = null;\n    }\n\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n        this.matrixTex = null;\n    }\n\n    getTextureMatrix()\n    {\n        const tex = this.texture;\n\n        if (!this.matrix)\n        {\n            return null;\n        }\n\n        if (tex.frame.width === tex.baseTexture.width\n            && tex.frame.height === tex.baseTexture.height)\n        {\n            return this.matrix;\n        }\n\n        if (!this.matrixTex)\n        {\n            this.matrixTex = this.matrix.clone();\n        }\n        else\n        {\n            this.matrixTex.copyFrom(this.matrix);\n        }\n        this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));\n\n        return this.matrixTex;\n    }\n}\n", "import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { FillStyle } from './FillStyle';\n\nexport enum LINE_SCALE_MODE {\n    NONE = 'none',\n    NORMAL = 'normal',\n}\n\nexport class LineStyle extends FillStyle\n{\n    width: number;\n    alignment: number;\n\n    cap: LINE_CAP;\n    join: LINE_JOIN;\n    miterLimit: number;\n    scaleMode: LINE_SCALE_MODE;\n\n    clone(): LineStyle\n    {\n        return this.copyTo(new LineStyle());\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    copyTo(obj: any): LineStyle\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n        obj.scaleMode = this.scaleMode;\n\n        return obj;\n    }\n\n    /**\n     * returns width multiplied by scaleMode\n     */\n    packLineWidth(): number\n    {\n        return this.scaleMode === LINE_SCALE_MODE.NORMAL ? this.width : -this.width;\n    }\n\n    reset(): void\n    {\n        super.reset();\n\n        this.smooth = true;\n\n        this.color = 0x0;\n\n        this.width = 0;\n\n        this.alignment = 0.5;\n\n        this.cap = LINE_CAP.BUTT;\n        this.join = LINE_JOIN.MITER;\n        this.miterLimit = 10;\n        this.scaleMode = LINE_SCALE_MODE.NORMAL;\n    }\n}\n", "export class BuildData\r\n{\r\n    verts: Array<number> = [];\r\n    joints: Array<number> = [];\r\n    vertexSize = 0;\r\n    indexSize = 0;\r\n    closePointEps = 1e-4;\r\n\r\n    clear()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n        this.vertexSize = 0;\r\n        this.indexSize = 0;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n    }\r\n}\r\n", "export enum JOINT_TYPE {\r\n    NONE = 0,\r\n    FILL = 1,\r\n    JOINT_BEVEL = 4,\r\n    JOINT_MITER = 8,\r\n    JOINT_ROUND = 12,\r\n    JOINT_CAP_BUTT = 16,\r\n    JOINT_CAP_SQUARE = 18,\r\n    JOINT_CAP_ROUND = 20,\r\n    FILL_EXPAND = 24,\r\n    CAP_BUTT = 1 << 5,\r\n    CAP_SQUARE = 2 << 5,\r\n    CAP_ROUND = 3 << 5,\r\n    CAP_BUTT2 = 4 << 5,\r\n}\r\n", "import { BuildData } from './BuildData';\nimport { JOINT_TYPE } from './const';\n\nexport class SegmentPacker\n{\n    static vertsByJoint: Array<number> = [];\n\n    strideFloats = 12;\n\n    updateBufferSize(jointStart: number, jointLen: number, triangles: number, target: BuildData)\n    {\n        const { joints } = target;\n        let foundTriangle = false;\n\n        let vertexSize = 0;\n        let indexSize = 0;\n\n        for (let i = jointStart; i < jointStart + jointLen; i++)\n        {\n            const prevCap = joints[i] & ~31;\n            const joint = joints[i] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                foundTriangle = true;\n                vertexSize++;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                vertexSize += 3;\n                indexSize += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs >= 4)\n            {\n                vertexSize += vs;\n                indexSize += 6 + (3 * Math.max(vs - 6, 0));\n            }\n        }\n        if (foundTriangle)\n        {\n            indexSize += triangles;\n        }\n\n        target.vertexSize += vertexSize;\n        target.indexSize += indexSize;\n    }\n\n    bufferPos = 0;\n    indexPos = 0;\n    bufFloat: Float32Array;\n    bufUint: Uint32Array;\n    indices: Uint16Array;\n    buildData: BuildData;\n\n    beginPack(buildData: BuildData, bufFloat: Float32Array, bufUint: Uint32Array, indices: Uint16Array, bufferPos = 0, indexPos = 0)\n    {\n        this.buildData = buildData;\n        this.bufFloat = bufFloat;\n        this.bufUint = bufUint;\n        this.indices = indices;\n        this.bufferPos = bufferPos;\n        this.indexPos = indexPos;\n    }\n\n    endPack()\n    {\n        this.buildData = null;\n        this.bufFloat = null;\n        this.bufUint = null;\n        this.indices = null;\n    }\n\n    packInterleavedGeometry(jointStart: number, jointLen: number, triangles: number[],\n        lineStyle: number, color: number)\n    {\n        const { bufFloat, bufUint, indices, buildData, strideFloats } = this;\n        const { joints, verts } = buildData;\n\n        let bufPos = this.bufferPos;\n        let indPos = this.indexPos;\n        let index = this.bufferPos / this.strideFloats;\n\n        // eslint-disable-next-line max-len\n        let x1: number; let y1: number; let x2: number; let y2: number; let prevX: number; let prevY: number; let nextX: number; let\n            nextY: number;\n        // let type: number;\n        let hasTriangle = false;\n\n        let travel = 0;\n\n        for (let j = jointStart; j < jointStart + jointLen; j++)\n        {\n            const fullJoint = joints[j];\n            const prevCap = joints[j] & ~31;\n            const joint = joints[j] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                // just one vertex\n                hasTriangle = true;\n                x1 = verts[(j * 2)];\n                y1 = verts[(j * 2) + 1];\n                bufFloat[bufPos] = x1;\n                bufFloat[bufPos + 1] = y1;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x1;\n                bufFloat[bufPos + 5] = y1;\n                bufFloat[bufPos + 6] = x1;\n                bufFloat[bufPos + 7] = y1;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = 16 * joint;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                prevX = verts[j * 2];\n                prevY = verts[(j * 2) + 1];\n                x1 = verts[(j * 2) + 2];\n                y1 = verts[(j * 2) + 3];\n                x2 = verts[(j * 2) + 4];\n                y2 = verts[(j * 2) + 5];\n\n                const bis = j + 3;\n\n                for (let i = 0; i < 3; i++)\n                {\n                    bufFloat[bufPos] = prevX;\n                    bufFloat[bufPos + 1] = prevY;\n                    bufFloat[bufPos + 2] = x1;\n                    bufFloat[bufPos + 3] = y1;\n                    bufFloat[bufPos + 4] = x2;\n                    bufFloat[bufPos + 5] = y2;\n                    bufFloat[bufPos + 6] = verts[(bis + i) * 2];\n                    bufFloat[bufPos + 7] = verts[((bis + i) * 2) + 1];\n\n                    bufFloat[bufPos + 8] = travel;\n                    bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                    bufFloat[bufPos + 10] = lineStyle;\n                    bufUint[bufPos + 11] = color;\n                    bufPos += strideFloats;\n                }\n\n                indices[indPos] = index;\n                indices[indPos + 1] = index + 1;\n                indices[indPos + 2] = index + 2;\n                indPos += 3;\n                index += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs === 0)\n            {\n                continue;\n            }\n            x1 = verts[j * 2];\n            y1 = verts[(j * 2) + 1];\n            x2 = verts[(j * 2) + 2];\n            y2 = verts[(j * 2) + 3];\n            // TODO: caps here\n            prevX = verts[(j * 2) - 2];\n            prevY = verts[(j * 2) - 1];\n\n            const dist = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\n\n            if (SegmentPacker.vertsByJoint[joint] === 0)\n            {\n                travel -= dist;\n            }\n\n            if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT)\n            {\n                nextX = verts[(j * 2) + 4];\n                nextY = verts[(j * 2) + 5];\n            }\n            else\n            {\n                nextX = x1;\n                nextY = y1;\n            }\n            // type = joint;\n\n            for (let i = 0; i < vs; i++)\n            {\n                bufFloat[bufPos] = prevX;\n                bufFloat[bufPos + 1] = prevY;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x2;\n                bufFloat[bufPos + 5] = y2;\n                bufFloat[bufPos + 6] = nextX;\n                bufFloat[bufPos + 7] = nextY;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n            }\n\n            travel += dist;\n\n            indices[indPos] = index;\n            indices[indPos + 1] = index + 1;\n            indices[indPos + 2] = index + 2;\n            indices[indPos + 3] = index;\n            indices[indPos + 4] = index + 2;\n            indices[indPos + 5] = index + 3;\n            indPos += 6;\n            for (let j = 5; j + 1 < vs; j++)\n            {\n                indices[indPos] = index + 4;\n                indices[indPos + 1] = index + j;\n                indices[indPos + 2] = index + j + 1;\n                indPos += 3;\n            }\n            index += vs;\n        }\n\n        if (hasTriangle)\n        {\n            for (let i = 0; i < triangles.length; i++)\n            {\n                indices[indPos + i] = triangles[i] + index;\n            }\n            indPos += triangles.length;\n        }\n\n        this.bufferPos = bufPos;\n        this.indexPos = indPos;\n    }\n}\n\nconst verts = SegmentPacker.vertsByJoint;\n\nfor (let i = 0; i < 256; i++)\n{ verts.push(0); }\n// simple fill\nverts[JOINT_TYPE.FILL] = 1;\n\nfor (let i = 0; i < 8; i++)\n{\n    verts[JOINT_TYPE.FILL_EXPAND + i] = 3;\n}\n\n// no caps for now\nverts[JOINT_TYPE.JOINT_BEVEL] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 3;\nverts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 2] = 4;\nverts[JOINT_TYPE.JOINT_MITER + 3] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 4;\n\nverts[JOINT_TYPE.CAP_ROUND] = 4;\n", "import type { Matrix, SHAPES, IShape } from '@pixi/math';\r\nimport { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\r\nimport { JOINT_TYPE } from './const';\r\nimport { FillStyle } from './FillStyle';\r\nimport { LineStyle } from './LineStyle';\r\n\r\n/**\r\n * A class to contain data useful for Graphics objects\r\n *\r\n * @class\r\n * @memberof PIXI\r\n */\r\nexport class SmoothGraphicsData\r\n{\r\n    shape: IShape;\r\n    lineStyle: LineStyle;\r\n    fillStyle: FillStyle;\r\n    matrix: Matrix;\r\n    type: SHAPES;\r\n    holes: Array<SmoothGraphicsData>;\r\n\r\n    // result of simplification\r\n    closeStroke: boolean;\r\n    points: number[];\r\n    triangles: number[];\r\n    // indices in build\r\n    attribStart: number;\r\n    fillStart: number;\r\n    fillLen: number;\r\n    strokeStart: number;\r\n    strokeLen: number;\r\n    fillAA: boolean;\r\n\r\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\r\n    {\r\n        this.shape = shape;\r\n\r\n        this.lineStyle = lineStyle;\r\n\r\n        this.fillStyle = fillStyle;\r\n\r\n        this.matrix = matrix;\r\n\r\n        this.type = shape.type;\r\n\r\n        this.points = [];\r\n\r\n        this.holes = [];\r\n\r\n        this.triangles = [];\r\n\r\n        this.closeStroke = false;\r\n\r\n        this.clearBuild();\r\n    }\r\n\r\n    public clearPath()\r\n    {\r\n        this.points.length = 0;\r\n        this.closeStroke = true;\r\n    }\r\n\r\n    public clearBuild()\r\n    {\r\n        this.triangles.length = 0;\r\n        this.fillStart = 0;\r\n        this.fillLen = 0;\r\n        this.strokeStart = 0;\r\n        this.strokeLen = 0;\r\n        this.fillAA = false;\r\n    }\r\n\r\n    public clone(): SmoothGraphicsData\r\n    {\r\n        return new SmoothGraphicsData(\r\n            this.shape,\r\n            this.fillStyle,\r\n            this.lineStyle,\r\n            this.matrix\r\n        );\r\n    }\r\n\r\n    public capType()\r\n    {\r\n        let cap: number;\r\n\r\n        switch (this.lineStyle.cap)\r\n        {\r\n            case LINE_CAP.SQUARE:\r\n                cap = JOINT_TYPE.CAP_SQUARE;\r\n                break;\r\n            case LINE_CAP.ROUND:\r\n                cap = JOINT_TYPE.CAP_ROUND;\r\n                break;\r\n            default:\r\n                cap = JOINT_TYPE.CAP_BUTT;\r\n                break;\r\n        }\r\n\r\n        return cap;\r\n    }\r\n\r\n    public goodJointType() {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER + 3;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public jointType()\r\n    {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this.shape = null;\r\n        this.holes.length = 0;\r\n        this.holes = null;\r\n        this.points.length = 0;\r\n        this.points = null;\r\n        this.lineStyle = null;\r\n        this.fillStyle = null;\r\n        this.triangles = null;\r\n    }\r\n}\r\n", "// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse } from '@pixi/math';\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\n\nexport class CircleBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape as Circle;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n        // TODO - bit hacky??\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            const ellipseData = graphicsData.shape as Ellipse;\n\n            width = ellipseData.width;\n            height = ellipseData.height;\n        }\n\n        if (width <= 0 || height <= 0)\n        {\n            return;\n        }\n\n        points.push(x, y);\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(width + height));\n\n        totalSegs /= 2.3;\n        if (totalSegs < 3)\n        {\n            totalSegs = 3;\n        }\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, target: BuildData)\n    {\n        const { verts, joints } = target;\n        const { points, triangles } = graphicsData;\n\n        let vertPos = 1;\n        const center = 0;\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n                if (i > 2)\n                {\n                    triangles.push(vertPos++, center, vertPos);\n                }\n            }\n            triangles.push(vertPos, center, 1);\n\n            return;\n        }\n\n        const cx = points[0]; const\n            cy = points[1];\n        const rad = (graphicsData.shape as Circle).radius;\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            // const prev = i;\n            const cur = i;\n            const next = i + 2 < points.length ? i + 2 : 2;\n\n            verts.push(cx);\n            verts.push(cy);\n            verts.push(points[cur]);\n            verts.push(points[cur + 1]);\n            verts.push(points[next]);\n            verts.push(points[next + 1]);\n\n            verts.push(0);\n            verts.push(0);\n            verts.push((points[cur] - cx) / rad);\n            verts.push((points[cur + 1] - cy) / rad);\n            verts.push((points[next] - cx) / rad);\n            verts.push((points[next + 1] - cy) / rad);\n\n            joints.push(JOINT_TYPE.FILL_EXPAND + 2);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        const { verts, joints } = target;\n        const { points } = graphicsData;\n        const joint = graphicsData.goodJointType();\n        const len = points.length;\n\n        verts.push(points[len - 2], points[len - 1]);\n        joints.push(JOINT_TYPE.NONE);\n        for (let i = 2; i < len; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n            joints.push(joint);\n        }\n        verts.push(points[2], points[3]);\n        joints.push(JOINT_TYPE.NONE);\n        verts.push(points[4], points[5]);\n        joints.push(JOINT_TYPE.NONE);\n    }\n}\n", "import type { Rectangle } from '@pixi/math';\r\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nexport class RectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        // --- //\r\n        // need to convert points to a nice regular data\r\n        //\r\n        const rectData = graphicsData.shape as Rectangle;\r\n        const x = rectData.x;\r\n        const y = rectData.y;\r\n        const width = rectData.width;\r\n        const height = rectData.height;\r\n        const points = graphicsData.points;\r\n\r\n        points.length = 0;\r\n\r\n        points.push(x, y,\r\n            x + width, y,\r\n            x + width, y + height,\r\n            x, y + height);\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        const joint = graphicsData.goodJointType();\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points, triangles } = graphicsData;\r\n\r\n        triangles.length = 0;\r\n\r\n        verts.push(points[0], points[1],\r\n            points[2], points[3],\r\n            points[4], points[5],\r\n            points[6], points[7]);\r\n\r\n        joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);\r\n        triangles.push(0, 1, 2, 0, 2, 3);\r\n    }\r\n}\r\n", "import type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { RoundedRectangle } from '@pixi/math';\r\nimport { earcut } from '@pixi/utils';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nfunction getPt(n1: number, n2: number, perc: number): number\r\n{\r\n    const diff = n2 - n1;\r\n\r\n    return n1 + (diff * perc);\r\n}\r\n\r\nfunction quadraticBezierCurve(\r\n    fromX: number, fromY: number,\r\n    cpX: number, cpY: number,\r\n    toX: number, toY: number,\r\n    out: Array<number> = []): Array<number>\r\n{\r\n    const n = 20;\r\n    const points = out;\r\n\r\n    let xa = 0;\r\n    let ya = 0;\r\n    let xb = 0;\r\n    let yb = 0;\r\n    let x = 0;\r\n    let y = 0;\r\n\r\n    for (let i = 0, j = 0; i <= n; ++i)\r\n    {\r\n        j = i / n;\r\n\r\n        // The Green Line\r\n        xa = getPt(fromX, cpX, j);\r\n        ya = getPt(fromY, cpY, j);\r\n        xb = getPt(cpX, toX, j);\r\n        yb = getPt(cpY, toY, j);\r\n\r\n        // The Black Dot\r\n        x = getPt(xa, xb, j);\r\n        y = getPt(ya, yb, j);\r\n\r\n        points.push(x, y);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nexport class RoundedRectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        const rrectData = graphicsData.shape as RoundedRectangle;\r\n        const { points } = graphicsData;\r\n        const x = rrectData.x;\r\n        const y = rrectData.y;\r\n        const width = rrectData.width;\r\n        const height = rrectData.height;\r\n\r\n        // Don't allow negative radius or greater than half the smallest width\r\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\r\n\r\n        points.length = 0;\r\n\r\n        // No radius, do a simple rectangle\r\n        if (!radius)\r\n        {\r\n            points.push(x, y,\r\n                x + width, y,\r\n                x + width, y + height,\r\n                x, y + height);\r\n        }\r\n        else\r\n        {\r\n            quadraticBezierCurve(x, y + radius,\r\n                x, y,\r\n                x + radius, y,\r\n                points);\r\n            quadraticBezierCurve(x + width - radius,\r\n                y, x + width, y,\r\n                x + width, y + radius,\r\n                points);\r\n            quadraticBezierCurve(x + width, y + height - radius,\r\n                x + width, y + height,\r\n                x + width - radius, y + height,\r\n                points);\r\n            quadraticBezierCurve(x + radius, y + height,\r\n                x, y + height,\r\n                x, y + height - radius,\r\n                points);\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n\r\n        const joint = points.length === 8 // we dont need joints for arcs\r\n            ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        graphicsData.triangles = earcut(points, null, 2);\r\n\r\n        for (let i = 0, j = points.length; i < j; i++)\r\n        {\r\n            verts.push(points[i], points[++i]);\r\n            joints.push(JOINT_TYPE.FILL);\r\n        }\r\n    }\r\n}\r\n", "import type { IShapeBuilder } from '../core/IShapeBuilder';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { Point, Polygon } from '@pixi/math';\nimport { earcut } from '@pixi/utils';\n\nconst tempArr: Array<number> = [];\n\nexport class PolyBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const shape = graphicsData.shape as Polygon;\n        const points = graphicsData.points = shape.points.slice();\n        const eps = buildData.closePointEps;\n        const eps2 = eps * eps;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const firstPoint = new Point(points[0], points[1]);\n        const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n        const closedShape = graphicsData.closeStroke = shape.closeStroke;\n\n        let len = points.length;\n        let newLen = 2;\n\n        // 1. remove equal points\n        for (let i = 2; i < len; i += 2)\n        {\n            const x1 = points[i - 2]; const y1 = points[i - 1]; const x2 = points[i]; const\n                y2 = points[i + 1];\n            let flag = true;\n\n            if (Math.abs(x1 - x2) < eps\n                && Math.abs(y1 - y2) < eps)\n            {\n                flag = false;\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points.length = len = newLen;\n\n        newLen = 2;\n        // 2. remove middle points\n        for (let i = 2; i + 2 < len; i += 2)\n        {\n            let x1 = points[i - 2]; let y1 = points[i - 1]; const x2 = points[i]; const y2 = points[i + 1];\n            let x3 = points[i + 2]; let\n                y3 = points[i + 3];\n\n            x1 -= x2;\n            y1 -= y2;\n            x3 -= x2;\n            y3 -= y2;\n            let flag = true;\n\n            if (Math.abs(x3 * y1 - y3 * x1) < eps2)\n            {\n                if (x1 * x3 + y1 * y3 < -eps2)\n                {\n                    flag = false;\n                }\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points[newLen] = points[len - 2];\n        points[newLen + 1] = points[len - 1];\n        newLen += 2;\n\n        points.length = len = newLen;\n\n        if (len <= 2)\n        {\n            // suddenly, nothing\n            return;\n        }\n\n        if (closedShape)\n        {\n            // first point should be last point in closed line!\n            const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n                && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n            if (closedPath)\n            {\n                points.pop();\n                points.pop();\n            }\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const { closeStroke, points } = graphicsData;\n        const eps = buildData.closePointEps;\n        // const eps2 = eps * eps;\n        const len = points.length;\n        // const style = graphicsData.lineStyle;\n\n        if (len <= 2)\n        {\n            return;\n        }\n        const { verts, joints } = buildData;\n\n        // TODO: alignment\n\n        const joint = graphicsData.jointType();\n        const cap = graphicsData.capType();\n        let prevCap = 0;\n\n        let prevX: number; let\n            prevY: number;\n\n        if (closeStroke)\n        {\n            prevX = points[len - 2];\n            prevY = points[len - 1];\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            prevX = points[2];\n            prevY = points[3];\n            if (cap === JOINT_TYPE.CAP_ROUND)\n            {\n                verts.push(points[0], points[1]);\n                joints.push(JOINT_TYPE.NONE);\n                joints.push(JOINT_TYPE.CAP_ROUND);\n                prevCap = 0;\n            }\n            else\n            {\n                prevCap = cap;\n                joints.push(JOINT_TYPE.NONE);\n            }\n        }\n        verts.push(prevX, prevY);\n\n        /* Line segments of interest where (x1,y1) forms the corner. */\n        for (let i = 0; i < len; i += 2)\n        {\n            const x1 = points[i]; const\n                y1 = points[i + 1];\n\n            let x2: number; let\n                y2: number;\n\n            if (i + 2 < len)\n            {\n                x2 = points[i + 2];\n                y2 = points[i + 3];\n            }\n            else\n            {\n                x2 = points[0];\n                y2 = points[1];\n            }\n\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            let nextX: number; let\n                nextY: number;\n\n            let endJoint = joint;\n\n            if (i + 2 >= len)\n            {\n                nextX = points[2];\n                nextY = points[3];\n                if (!closeStroke)\n                {\n                    endJoint = JOINT_TYPE.NONE;\n                }\n            }\n            else if (i + 4 >= len)\n            {\n                nextX = points[0];\n                nextY = points[1];\n                if (!closeStroke)\n                {\n                    if (cap === JOINT_TYPE.CAP_ROUND)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                    }\n                    if (cap === JOINT_TYPE.CAP_BUTT)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                    }\n                    if (cap === JOINT_TYPE.CAP_SQUARE)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\n                    }\n                }\n            }\n            else\n            {\n                nextX = points[i + 4];\n                nextY = points[i + 5];\n            }\n\n            const dx3 = x1 - prevX;\n            const dy3 = y1 - prevY;\n\n            if (joint >= JOINT_TYPE.JOINT_BEVEL && joint <= JOINT_TYPE.JOINT_MITER)\n            {\n                const dx2 = nextX - x2;\n                const dy2 = nextY - y2;\n\n                if (endJoint >= JOINT_TYPE.JOINT_BEVEL\n                    && endJoint <= JOINT_TYPE.JOINT_MITER + 3)\n                {\n                    const D = dx2 * dy - dy2 * dx;\n\n                    if (Math.abs(D) < eps)\n                    {\n                        switch (joint & ~3)\n                        {\n                            case JOINT_TYPE.JOINT_ROUND:\n                                endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                                break;\n                            default:\n                                endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                                break;\n                        }\n                    }\n                }\n\n                if (joint === JOINT_TYPE.JOINT_MITER)\n                {\n                    let jointAdd = 0;\n\n                    if (dx3 * dx + dy3 * dy > -eps)\n                    {\n                        jointAdd++;\n                    }\n                    if (endJoint === JOINT_TYPE.JOINT_MITER && dx2 * dx + dy2 * dy > -eps)\n                    {\n                        jointAdd += 2;\n                    }\n                    endJoint += jointAdd;\n                }\n            }\n            if (prevCap === 0)\n            {\n                if (Math.abs(dx3 * dy - dy3 * dx) < eps)\n                {\n                    prevCap = JOINT_TYPE.CAP_BUTT2;\n                }\n            }\n            endJoint += prevCap;\n            prevCap = 0;\n\n            verts.push(x1, y1);\n            joints.push(endJoint);\n\n            prevX = x1;\n            prevY = y1;\n        }\n\n        if (closeStroke)\n        {\n            verts.push(points[0], points[1]);\n            joints.push(JOINT_TYPE.NONE);\n            verts.push(points[2], points[3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            verts.push(points[len - 4], points[len - 3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        let points = graphicsData.points;\n        // TODO: simplify holes too!\n        const holes = graphicsData.holes;\n        const eps = buildData.closePointEps;\n\n        const { verts, joints } = buildData;\n\n        if (points.length < 6)\n        {\n            return;\n        }\n        const holeArray = [];\n        let len = points.length;\n        // Process holes..\n\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            holeArray.push(points.length / 2);\n            points = points.concat(hole.points);\n        }\n\n        // TODO: reduce size later?\n        const pn = tempArr;\n\n        if (pn.length < points.length)\n        {\n            pn.length = points.length;\n        }\n        const start = 0;\n\n        for (let i = 0; i <= holeArray.length; i++)\n        {\n            let finish = len / 2;\n\n            if (i > 0)\n            {\n                if (i < holeArray.length)\n                {\n                    finish = holeArray[i];\n                }\n                else\n                {\n                    finish = (points.length >> 1);\n                }\n            }\n            pn[start * 2] = finish - 1;\n            pn[(finish - 1) * 2 + 1] = 0;\n            for (let j = start; j + 1 < finish; j++)\n            {\n                pn[j * 2 + 1] = j + 1;\n                pn[j * 2 + 2] = j;\n            }\n        }\n\n        // sort color\n        graphicsData.triangles = earcut(points, holeArray, 2);\n\n        if (!graphicsData.triangles)\n        {\n            return;\n        }\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n            }\n\n            return;\n        }\n\n        const { triangles } = graphicsData;\n\n        len = points.length;\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            // TODO: holes prev/next!!!\n            let flag = 0;\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind1 = triangles[i + j];\n                const ind2 = triangles[i + (j + 1) % 3];\n\n                if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2)\n                {\n                    flag |= (1 << j);\n                }\n            }\n            joints.push(JOINT_TYPE.FILL_EXPAND + flag);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n\n        // bisect, re-using pn\n        for (let ind = 0; ind < len / 2; ind++)\n        {\n            const prev = pn[ind * 2];\n            const next = pn[ind * 2 + 1];\n            let nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); let\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            let nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); let\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n            const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);\n\n            nx1 /= D1;\n            ny1 /= D1;\n            const D2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n            nx2 /= D2;\n            ny2 /= D2;\n\n            let bx = (nx1 + nx2);\n            let by = (ny1 + ny2);\n            const D = bx * nx1 + by * ny1;\n\n            if (Math.abs(D) < eps)\n            {\n                bx = nx1;\n                by = ny1;\n            }\n            else\n            {\n                bx /= D;\n                by /= D;\n            }\n            pn[ind * 2] = bx;\n            pn[ind * 2 + 1] = by;\n        }\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            const prev = triangles[i];\n            const ind = triangles[i + 1];\n            const next = triangles[i + 2];\n            const nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); const\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            const nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); const\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n\n            let j1 = 1;\n\n            if (nx1 * ny2 - nx2 * ny1 > 0.0)\n            {\n                j1 = 2;\n            }\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(points[ind * 2], points[ind * 2 + 1]);\n            }\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(pn[ind * 2], pn[ind * 2 + 1]);\n            }\n        }\n    }\n}\n", "import { SHAPES } from '@pixi/math';\r\nimport { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { CircleBuilder } from './CircleBuilder';\r\nimport { RectangleBuilder } from './RectangleBuilder';\r\nimport { RoundedRectangleBuilder } from './RoundedRectangleBuilder';\r\nimport { PolyBuilder } from './PolyBuilder';\r\n\r\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuilder> = {\r\n    [SHAPES.POLY]: new PolyBuilder(),\r\n    [SHAPES.CIRC]: new CircleBuilder(),\r\n    [SHAPES.ELIP]: new CircleBuilder(),\r\n    [SHAPES.RECT]: new RectangleBuilder(),\r\n    [SHAPES.RREC]: new RoundedRectangleBuilder()\r\n};\r\n\r\nexport { CircleBuilder, RectangleBuilder, RoundedRectangleBuilder, PolyBuilder };\r\n", "import { SmoothGraphicsData } from './core/SmoothGraphicsData';\n\nimport { FILL_COMMANDS } from './shapes';\n\nimport {\n    Buffer,\n    Geometry,\n} from '@pixi/core';\n\nimport { WRAP_MODES, TYPES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\nimport { BuildData } from './core/BuildData';\nimport { SegmentPacker } from './core/SegmentPacker';\nimport { LineStyle } from './core/LineStyle';\nimport { FillStyle } from './core/FillStyle';\nimport { BatchPart } from './core/BatchPart';\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nexport const BATCH_POOL: Array<BatchPart> = [];\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\nexport class SmoothGraphicsGeometry extends Geometry\n{\n    public static BATCHABLE_SIZE = 100;\n\n    public boundsPadding: number;\n\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable: boolean;\n\n    buildData: BuildData;\n\n    get points()\n    {\n        return this.buildData.verts;\n    }\n\n    get closePointEps()\n    {\n        return this.buildData.closePointEps;\n    }\n\n    graphicsData: Array<SmoothGraphicsData>;\n    drawCalls: Array<BatchDrawCall>;\n    batchDirty: number;\n    batches: Array<BatchPart>;\n    packer: SegmentPacker;\n    packSize: number;\n    pack32index: boolean;\n    strideFloats: number;\n\n    protected dirty: number;\n    protected cacheDirty: number;\n    protected clearDirty: number;\n    protected shapeBuildIndex: number;\n    protected shapeBatchIndex: number;\n    protected _bounds: Bounds;\n    protected boundsDirty: number;\n\n    _buffer: Buffer;\n    _indexBuffer: Buffer;\n    _bufferFloats: Float32Array;\n    _bufferUint: Uint32Array;\n\n    initAttributes(_static: boolean)\n    {\n        this._buffer = new Buffer(null, _static, false);\n        this._bufferFloats = new Float32Array();\n        this._bufferUint = new Uint32Array();\n\n        this._indexBuffer = new Buffer(null, _static, true);\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\n            // number of vertex\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\n            // line width, alignment\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\n            // the usual\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addIndex(this._indexBuffer);\n\n        this.strideFloats = 12;\n    }\n\n    constructor()\n    {\n        super();\n\n        this.initAttributes(false);\n\n        this.buildData = new BuildData();\n\n        this.graphicsData = [];\n\n        this.dirty = 0;\n\n        this.batchDirty = -1;\n\n        this.cacheDirty = -1;\n\n        this.clearDirty = 0;\n\n        this.drawCalls = [];\n\n        this.batches = [];\n\n        this.shapeBuildIndex = 0;\n\n        this.shapeBatchIndex = 0;\n\n        this._bounds = new Bounds();\n\n        this.boundsDirty = -1;\n\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.packer = null;\n        this.packSize = 0;\n        this.pack32index = null;\n    }\n\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\n    {\n        if (this.packer)\n        {\n            return;\n        }\n        this.packer = new SegmentPacker();\n        this.pack32index = allow32Indices;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeBuildIndex = 0;\n        this.shapeBatchIndex = 0;\n        this.packSize = 0;\n\n        this.buildData.clear();\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    public clear(): SmoothGraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the SmoothGraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.buildData.destroy();\n        this.buildData = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    updatePoints(): void\n    {\n        // do nothing\n    }\n\n    updateBufferSize(): void\n    {\n        this._buffer.update(new Float32Array());\n    }\n\n    updateBuild(): void\n    {\n        const { graphicsData, buildData } = this;\n        const len = graphicsData.length;\n\n        for (let i = this.shapeBuildIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n\n            data.strokeStart = 0;\n            data.strokeLen = 0;\n            data.fillStart = 0;\n            data.fillLen = 0;\n            const { fillStyle, lineStyle, holes } = data;\n\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n\n            const command = FILL_COMMANDS[data.type];\n\n            data.clearPath();\n\n            command.path(data, buildData);\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            data.clearBuild();\n            if (data.points.length <= 2)\n            {\n                continue;\n            }\n            if (fillStyle.visible)\n            {\n                if (holes.length)\n                {\n                    this.processHoles(holes);\n                }\n                data.fillAA = (data.fillStyle as any).smooth\n                    && !(data.lineStyle.visible\n                    && data.lineStyle.alpha >= 0.99\n                    && data.lineStyle.width >= 0.99);\n\n                data.fillStart = buildData.joints.length;\n                command.fill(data, buildData);\n                data.fillLen = buildData.joints.length - data.fillStart;\n            }\n            if (lineStyle.visible)\n            {\n                data.strokeStart = buildData.joints.length;\n                command.line(data, buildData);\n                data.strokeLen = buildData.joints.length - data.strokeStart;\n            }\n        }\n        this.shapeBuildIndex = len;\n    }\n\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n        this.updateBuild();\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        const { buildData, graphicsData } = this;\n        const len = graphicsData.length;\n\n        this.cacheDirty = this.dirty;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeBatchIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const attribOld = buildData.vertexSize;\n                const indexOld = buildData.indexSize;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n                if (j === 0)\n                {\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\n                }\n                else\n                {\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\n                }\n\n                const attribSize = buildData.vertexSize;\n\n                if (attribSize === attribOld) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(indexOld, attribOld);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, indexOld, attribOld);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                if (j === 0)\n                {\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\n                }\n                else\n                {\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\n                }\n            }\n        }\n        this.shapeBatchIndex = len;\n\n        if (batchPart)\n        {\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in SmoothGraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls(shaderSettings);\n            this.updatePack();\n        }\n    }\n\n    updatePack()\n    {\n        const { vertexSize, indexSize } = this.buildData;\n\n        if (this.packSize === vertexSize)\n        {\n            return;\n        }\n\n        const { strideFloats, packer, buildData, batches } = this;\n        const buffer = this._buffer;\n        const index = this._indexBuffer;\n        const floatsSize = vertexSize * strideFloats;\n\n        if (buffer.data.length !== floatsSize)\n        {\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\n\n            this._bufferFloats = new Float32Array(arrBuf);\n            this._bufferUint = new Uint32Array(arrBuf);\n            buffer.data = this._bufferFloats;\n        }\n        if (index.data.length !== indexSize)\n        {\n            if (vertexSize > 0xffff && this.pack32index)\n            {\n                index.data = new Uint32Array(indexSize);\n            }\n            else\n            {\n                index.data = new Uint16Array(indexSize);\n            }\n        }\n\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\n\n        let j = 0;\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n\n            if (data.fillLen)\n            {\n                while (batches[j].jointEnd <= data.fillStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n            if (data.strokeLen)\n            {\n                while (batches[j].jointEnd <= data.strokeStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n        }\n\n        buffer.update();\n        index.update();\n        this.packSize = vertexSize;\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (styleA.packLineWidth() !== styleB.packLineWidth())\n        {\n            return false;\n        }\n\n        // TODO: propagate width for FillStyle\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\n        {\n            return false;\n        }\n\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\n\n        return matrixEquals(mat1, mat2);\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    protected isBatchable(): boolean\n    {\n        return false;\n\n        // prevent heavy mesh batching\n        // if (this.points.length > 0xffff * 2) {\n        //     return false;\n        // }\n        //\n        // const batches = this.batches;\n        //\n        // for (let i = 0; i < batches.length; i++) {\n        //     if ((batches[i].style as LineStyle).native) {\n        //         return false;\n        //     }\n        // }\n        //\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\n    {\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n\n        currentGroup.begin(shaderSettings, null);\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchData = this.batches[i];\n            const style = batchData.style as LineStyle;\n\n            if (batchData.attribSize === 0)\n            {\n                // I don't know how why do we have size=0 sometimes\n                continue;\n            }\n\n            let styleId = -1;\n            const mat = style.getTextureMatrix();\n\n            if (currentGroup.check(style.shader))\n            {\n                styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);\n            }\n            if (styleId < 0)\n            {\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n                this.drawCalls.push(currentGroup);\n                currentGroup.begin(shaderSettings, style.shader);\n                currentGroup.start = index;\n                styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);\n            }\n            currentGroup.size += batchData.size;\n            index += batchData.size;\n\n            const { color, alpha } = style;\n            const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n            batchData.rgba = premultiplyTint(rgb, alpha);\n            batchData.styleId = styleId;\n        }\n    }\n\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.path(hole, this.buildData);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n}\n", "import { Program, Shader } from '@pixi/core';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\n\nconst smoothVert = `precision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vSignedCoord;\nvarying vec4 vDistance;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n\n    vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n    float avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    if (lineWidth < 0.0) {\n        lineWidth = -lineWidth;\n    } else {\n        lineWidth = lineWidth * avgScale;\n    }\n    lineWidth *= 0.5;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureId = styleTextureId[styleId];\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n    }\n\n    if (type == FILL) {\n        pos = pointA;\n        vDistance = vec4(0.0, -0.5, -0.5, 1.0);\n        vType = 0.0;\n\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n        } else {\n            pos = pointB;\n        }\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 > 0.01) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n\n        vDistance.w = 1.0;\n        pos += bisect * expand;\n\n        vDistance = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vDistance.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vDistance.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vDistance.z = -dot(pos - pointB, n3);\n        }\n        vDistance.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float sign2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            sign2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= sign2;\n\n        if (abs(lineAlignment) > 0.01) {\n            float shift = lineWidth * lineAlignment;\n            pointA += norm * shift;\n            pointB += norm * shift;\n            if (abs(D) < 0.01) {\n                base += norm * shift;\n            } else {\n                base += doBisect(norm, len, norm2, len2, shift, 0.0);\n            }\n        }\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n        float dy3 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01) {\n                pos = dy * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = dy * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, inner);\n                }\n            }\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    dy3 = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    dy3 = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * vec2(-norm.y, norm.x);\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n            }\n            dy = -0.5;\n            dy2 = pos.x;\n            dy3 = pos.y;\n            vType = 3.0;\n        } else if (abs(D) < 0.01) {\n            pos = dy * norm;\n        } else {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                if (inner > 0.5) {\n                    dy = -dy;\n                    inner = 0.0;\n                }\n                if (vertexNum < 4.5) {\n                    pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n                } else if (vertexNum < 5.5) {\n                    pos = dy * norm;\n                } else if (vertexNum > 7.5) {\n                    pos = dy * norm2;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    float d2 = abs(dy);\n                    if (length(pos) > abs(dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = dy * norm.x - d2 * norm.y;\n                            pos.y = dy * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = dy * norm2.x + d2 * norm2.y;\n                            pos.y = dy * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                }\n                vec2 norm3 = normalize(norm - norm2);\n                dy = pos.x * norm3.y - pos.y * norm3.x - 3.0;\n                dy2 = pos.x;\n                dy3 = pos.y;\n                vType = 3.0;\n            } else {\n                if (type >= MITER && type < MITER + 3.5) {\n                    if (inner > 0.5) {\n                        dy = -dy;\n                        inner = 0.0;\n                    }\n                    float sign = step(0.0, dy) * 2.0 - 1.0;\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    if (length(pos) > abs(dy) * MITER_LIMIT) {\n                        type = BEVEL;\n                    } else {\n                        if (vertexNum < 4.5) {\n                            dy = -dy;\n                            pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        } else if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else if (vertexNum > 6.5) {\n                            pos = dy * norm2;\n                            // dy = ...\n                        }\n                    }\n                    vType = 1.0;\n                    dy = -sign * dot(pos, norm);\n                    dy2 = -sign * dot(pos, norm2);\n                }\n                if (type >= BEVEL && type < BEVEL + 1.5) {\n                    if (inner < 0.5) {\n                        dy = -dy;\n                        inner = 1.0;\n                    }\n                    vec2 norm3 = normalize((norm + norm2) / 2.0);\n                    if (vertexNum < 4.5) {\n                        pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        dy2 = -abs(dot(pos + dy * norm, norm3));\n                    } else {\n                        dy2 = 0.0;\n                        dy = -dy;\n                        if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else {\n                            pos = dy * norm2;\n                        }\n                    }\n                }\n            }\n        }\n\n        pos += base;\n        vDistance = vec4(dy, dy2, dy3, lineWidth) * resolution;\n        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}`;\n\nconst smoothFrag = `\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\nexport class SmoothGraphicsProgram extends Program\n{\n    settings: IGraphicsBatchSettings;\n\n    constructor(settings: IGraphicsBatchSettings,\n        vert = smoothVert,\n        frag = smoothFrag,\n        _uniforms = {})\n    {\n        const { maxStyles, maxTextures } = settings;\n\n        vert = vert.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            .replace(/%MAX_STYLES%/gi, `${maxStyles}`);\n        frag = frag.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            .replace(/%FOR_LOOP%/gi, SmoothGraphicsShader.generateSampleSrc(maxTextures));\n\n        super(vert, frag);\n        this.settings = settings;\n    }\n}\n\nexport class SmoothGraphicsShader extends Shader\n{\n    settings: IGraphicsBatchSettings;\n\n    constructor(settings: IGraphicsBatchSettings, prog = new SmoothGraphicsProgram(settings), uniforms = {})\n    {\n        const { maxStyles, maxTextures } = settings;\n        const sampleValues = new Int32Array(maxTextures);\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            sampleValues[i] = i;\n        }\n        super(prog, (Object as any).assign(uniforms, {\n            styleMatrix: new Float32Array(6 * maxStyles),\n            styleTextureId: new Float32Array(maxStyles),\n            styleLine: new Float32Array(2 * maxStyles),\n            samplerSize: new Float32Array(2 * maxTextures),\n            uSamplers: sampleValues,\n            tint: new Float32Array([1, 1, 1, 1]),\n            resolution: 1,\n            expand: 1,\n        }));\n        this.settings = settings;\n    }\n\n    static generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(textureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n", "import { LINE_SCALE_MODE } from \"./core/LineStyle\";\n\nexport interface ISettings {\n    LINE_SCALE_MODE: string;\n    SHADER_MAX_STYLES: number;\n    SHADER_MAX_TEXTURES: number;\n}\n\nexport const settings: ISettings = {\n    LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,\n    SHADER_MAX_STYLES: 24,\n    SHADER_MAX_TEXTURES: 4,\n};\n", "import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport { Texture, State, Renderer, Shader } from '@pixi/core';\nimport { graphicsUtils, LINE_JOIN, LINE_CAP, Graphics } from '@pixi/graphics';\nimport { hex2rgb } from '@pixi/utils';\nimport { SmoothGraphicsGeometry } from './SmoothGraphicsGeometry';\nimport { BLEND_MODES, DRAW_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\nimport { FillStyle } from './core/FillStyle';\nimport {LINE_SCALE_MODE, LineStyle} from './core/LineStyle';\nimport { SmoothGraphicsShader } from './SmoothShader';\nimport { settings } from \"./settings\";\n\nconst { BezierUtils, QuadraticUtils, ArcUtils } = graphicsUtils;\n\nconst temp = new Float32Array(3);\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: { [key: string]: Shader } = {};\n\nexport interface IFillStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n    smooth?: boolean;\n    shader?: Shader;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions {\n    width?: number;\n    alignment?: number;\n    scaleMode: LINE_SCALE_MODE;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nexport class SmoothGraphics extends Container\n{\n    static _TEMP_POINT = new Point();\n\n    public shader: Shader;\n    public shaderSettings: IGraphicsBatchSettings;\n    public pluginName: string;\n    public currentPath: Polygon;\n\n    protected batches: Array<any>;\n    protected batchTint: number;\n    protected batchDirty: number;\n    protected vertexData: Float32Array;\n\n    protected _fillStyle: FillStyle;\n    protected _lineStyle: LineStyle;\n    protected _matrix: Matrix;\n    protected _holeMode: boolean;\n    protected _transformID: number;\n    protected _tint: number;\n\n    private state: State;\n    private _geometry: SmoothGraphicsGeometry;\n\n    public get geometry(): SmoothGraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    constructor(geometry: SmoothGraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new SmoothGraphicsGeometry();\n        this._geometry.refCount++;\n\n        this.shader = null;\n\n        this.shaderSettings = {\n            maxStyles: settings.SHADER_MAX_STYLES,\n            maxTextures: settings.SHADER_MAX_TEXTURES,\n        };\n\n        this.state = State.for2d();\n\n        this._fillStyle = new FillStyle();\n\n        this._lineStyle = new LineStyle();\n\n        this._matrix = null;\n\n        this._holeMode = false;\n\n        this.currentPath = null;\n\n        this.batches = [];\n\n        this.batchTint = -1;\n\n        this.batchDirty = -1;\n\n        this.vertexData = null;\n\n        this.pluginName = 'smooth';\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    public clone(): SmoothGraphics\n    {\n        this.finishPoly();\n\n        return new SmoothGraphics(this._geometry);\n    }\n\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, scaleMode?: LINE_SCALE_MODE): this;\n\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color = 0x0, alpha = 1, alignment = 0.5, scaleMode = settings.LINE_SCALE_MODE): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            if (typeof scaleMode === 'boolean')\n            {\n                scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n            options = { width: options, color, alpha, alignment, scaleMode } as ILineStyleOptions;\n        }\n        else\n        {\n            const native: boolean = (options as any).native;\n\n            if (native !== undefined)\n            {\n                options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n            shader: null,\n            scaleMode: settings.LINE_SCALE_MODE,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    public beginFill(color = 0, alpha = 1, smooth = false): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha, smooth });\n    }\n\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n            smooth: false,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<Point>): this\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\n\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<Point>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    protected _renderCanvas(renderer: any): void\n    {\n        (Graphics.prototype as any)._renderCanvas.call(this, renderer);\n    }\n\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuint32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);\n\n        geometry.updateBatches(this.shaderSettings);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            // const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n            //     gI.attribStart * 4 * 2,\n            //     gI.attribSize * 2);\n\n            // const indices = new Uint16Array(geometry.indicesUint16.buffer,\n            //     gI.start * 2,\n            //     gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                // indices,\n                // uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1\n            };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const directShader = this._resolveDirectShader(renderer);\n        let shader: Shader = directShader;\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        uniforms.resolution = renderer.renderTexture.current\n            ? renderer.renderTexture.current.resolution : renderer.resolution;\n\n        const projTrans = renderer.projection.transform;\n\n        if (projTrans)\n        {\n            // only uniform scale is supported!\n            const scale = Math.sqrt(projTrans.a * projTrans.a + projTrans.b * projTrans.b);\n\n            uniforms.resolution *= scale;\n        }\n\n        uniforms.expand = (renderer.options.antialias ? 2 : 1) / uniforms.resolution;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        shader = null;\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            // TODO: refactor it to another class, that fills uniforms of this shader\n            const drawCall = geometry.drawCalls[i];\n\n            const shaderChange = shader !== drawCall.shader;\n\n            if (shaderChange)\n            {\n                shader = drawCall.shader;\n                if (shader)\n                {\n                    shader.uniforms.translationMatrix = this.transform.worldTransform;\n                    if (shader.uniforms.tint)\n                    {\n                        shader.uniforms.tint[0] = uniforms.tint[0];\n                        shader.uniforms.tint[1] = uniforms.tint[1];\n                        shader.uniforms.tint[2] = uniforms.tint[2];\n                        shader.uniforms.tint[3] = uniforms.tint[3];\n                    }\n                }\n            }\n\n            const { texArray, styleArray, size, start } = drawCall;\n            const groupTextureCount = texArray.count;\n            const shaderHere = shader || directShader;\n\n            const texs = shaderHere.uniforms.styleTextureId;\n            const mats = shaderHere.uniforms.styleMatrix;\n            const lines = shaderHere.uniforms.styleLine;\n\n            for (let i = 0; i < styleArray.count; i++)\n            {\n                texs[i] = styleArray.textureIds[i];\n                lines[i * 2] = styleArray.lines[i * 2];\n                lines[(i * 2) + 1] = styleArray.lines[(i * 2) + 1];\n                const m = styleArray.matrices[i];\n\n                mats[i * 6] = m.a;\n                mats[(i * 6) + 1] = m.c;\n                mats[(i * 6) + 2] = m.tx;\n                mats[(i * 6) + 3] = m.b;\n                mats[(i * 6) + 4] = m.d;\n                mats[(i * 6) + 5] = m.ty;\n            }\n            const sizes = shaderHere.uniforms.samplerSize;\n\n            for (let i = 0; i < groupTextureCount; i++)\n            {\n                sizes[i * 2] = texArray.elements[i].width;\n                sizes[(i * 2) + 1] = texArray.elements[i].height;\n            }\n\n            renderer.shader.bind(shaderHere);\n            if (shaderChange)\n            {\n                renderer.geometry.bind(geometry);\n            }\n\n            // TODO: bind styles!\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                renderer.texture.bind(texArray.elements[j], j);\n            }\n\n            // bind the geometry...\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);\n        }\n    }\n\n    protected _resolveDirectShader(_renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                DEFAULT_SHADERS[pluginName] = new SmoothGraphicsShader(this.shaderSettings);\n            }\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, SmoothGraphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT);\n    }\n\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                    + (color & 0xff00)\n                    + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n\n    drawStar(x: number, y: number,\n        points: number, radius: number, innerRadius: number, rotation = 0): SmoothGraphics\n    {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n    }\n}\n\nexport class Star extends Polygon\n{\n    constructor(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n", "import { SmoothGraphicsProgram, SmoothGraphicsShader } from './SmoothShader';\n\nconst dashFrag = `\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    if (dash + gap > 1.0)\n    {\n        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\n        float left = max(travel - 0.5, -0.5);\n        float right = min(travel + 0.5, gap + 0.5);\n        alpha *= max(0.0, right - left);\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\nexport interface IDashParams {\n    dash: number;\n    gap: number;\n}\n\nexport class DashLineShader extends SmoothGraphicsShader\n{\n    constructor(dashParams?: IDashParams)\n    {\n        const settings = { maxStyles: 16, maxTextures: 1 };\n\n        super(settings, new SmoothGraphicsProgram(settings, undefined, dashFrag),\n            dashParams || {\n                dash: 5.0,\n                gap: 8.0\n            });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAcY;CAAZ,SAAYA,YAAS;AACjB,EAAAA,WAAA,OAAA,IAAA;AACA,EAAAA,WAAA,OAAA,IAAA;AACA,EAAAA,WAAA,OAAA,IAAA;AACJ,GAJY,cAAA,YAAS,CAAA,EAAA;IAmBT;CAAZ,SAAYC,WAAQ;AAChB,EAAAA,UAAA,MAAA,IAAA;AACA,EAAAA,UAAA,OAAA,IAAA;AACA,EAAAA,UAAA,QAAA,IAAA;AACJ,GAJY,aAAA,WAAQ,CAAA,EAAA;IAgCP,kBAA2C;EACpD,UAAU;EACV,WAAW;EACX,aAAa;EACb,aAAc;EAEd,SAAS;EAET,gBAAA,SAAe,QAAgB,iBAAoB;AAApB,QAAA,oBAAA,QAAA;AAAA,wBAAA;IAAoB;AAE/C,QAAI,CAAC,KAAK,YAAY,CAAC,UAAU,MAAM,MAAM,GAC7C;AACI,aAAO;;AAGX,QAAI,SAAS,KAAK,KAAK,SAAS,KAAK,SAAS;AAE9C,QAAI,SAAS,KAAK,aAClB;AACI,eAAS,KAAK;eAET,SAAS,KAAK,aACvB;AACI,eAAS,KAAK;;AAGlB,WAAO;;;AClFf,IAAA,YAAA,WAAA;AA+BI,WAAAC,aAAA;AAxBO,SAAA,QAAQ;AAGR,SAAA,QAAQ;AAQR,SAAA,UAAmB,QAAQ;AAQ3B,SAAA,SAAiB;AAGjB,SAAA,UAAU;AAIb,SAAK,MAAK;;AAQP,EAAAA,WAAA,UAAA,QAAP,WAAA;AAEI,QAAM,MAAM,IAAIA,WAAS;AAEzB,QAAI,QAAQ,KAAK;AACjB,QAAI,QAAQ,KAAK;AACjB,QAAI,UAAU,KAAK;AACnB,QAAI,SAAS,KAAK;AAClB,QAAI,UAAU,KAAK;AAEnB,WAAO;;AAMJ,EAAAA,WAAA,UAAA,QAAP,WAAA;AAEI,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,UAAU,QAAQ;AACvB,SAAK,SAAS;AACd,SAAK,UAAU;;AAMZ,EAAAA,WAAA,UAAA,UAAP,WAAA;AAEI,SAAK,UAAU;AACf,SAAK,SAAS;;AAEtB,SAAAA;AAAA,EAAC;ACnED,IAAI,gBAAgB,SAAS,GAAG,GAAG;AAC/B,kBAAgB,OAAO,kBAClB,EAAE,WAAW,CAAA,EAAE,aAAc,SAAS,SAAUC,IAAGC,IAAG;AAAE,IAAAD,GAAE,YAAYC;EAAE,KACzE,SAAUD,IAAGC,IAAG;AAAE,aAAS,KAAKA,IAAC;AAAE,UAAIA,GAAE,eAAe,CAAC,GAAC;AAAE,QAAAD,GAAE,CAAC,IAAIC,GAAE,CAAC;MAAC;IAAA;EAAC;AAC5E,SAAO,cAAc,GAAG,CAAC;AAC7B;AAEO,SAAS,UAAU,GAAG,GAAG;AAC5B,gBAAc,GAAG,CAAC;AAClB,WAAS,KAAK;AAAE,SAAK,cAAc;EAAE;AACrC,IAAE,YAAY,MAAM,OAAO,OAAO,OAAO,CAAC,KAAK,GAAG,YAAY,EAAE,WAAW,IAAI,GAAE;AACrF;ACXO,IAAM,YAAgC;EAEzC,OAAA,SAAM,cAAY;AAEd,iBAAa,SAAU,aAAa,MAAkB,OAAO,MAAK;;EAGtE,aAAW,SAAC,cAAc,kBAAgB;AAEtC,QAAI,SAAS,aAAa;AAC1B,QAAM,QAAQ,aAAa;AAC3B,QAAMC,SAAQ,iBAAiB;AAC/B,QAAM,UAAU,iBAAiB;AAEjC,QAAI,OAAO,UAAU,GACrB;AACI,UAAM,YAAY,CAAA;AAGlB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,YAAM,OAAO,MAAM,CAAC;AAEpB,kBAAU,KAAK,OAAO,SAAS,CAAC;AAChC,iBAAS,OAAO,OAAO,KAAK,MAAM;;AAItC,UAAM,gBAAY,uBAAO,QAAQ,WAAW,CAAC;AAE7C,UAAI,CAAC,WACL;AACI;;AAGJ,UAAM,UAAUA,OAAM,SAAS;AAE/B,eAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAC3C;AACI,gBAAQ,KAAK,UAAU,CAAC,IAAI,OAAO;AACnC,gBAAQ,KAAK,UAAU,IAAI,CAAC,IAAI,OAAO;AACvC,gBAAQ,KAAK,UAAU,IAAI,CAAC,IAAI,OAAO;;AAG3C,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KACnC;AACI,QAAAA,OAAM,KAAK,OAAO,CAAC,CAAC;;;;;AC7C7B,IAAM,cAAkC;EAE3C,OAAA,SAAM,cAAY;AAGd,QAAM,aAAa,aAAa;AAChC,QAAM,SAAS,aAAa;AAC5B,QAAM,IAAI,WAAW;AACrB,QAAM,IAAI,WAAW;AACrB,QAAI;AACJ,QAAI;AAEJ,WAAO,SAAS;AAGhB,QAAI,aAAa,SAAS,OAAO,MACjC;AACI,cAAQ,WAAW;AACnB,eAAS,WAAW;WAGxB;AACI,UAAM,cAAc,aAAa;AAEjC,cAAQ,YAAY;AACpB,eAAS,YAAY;;AAGzB,QAAI,UAAU,KAAK,WAAW,GAC9B;AACI;;AAGJ,QAAI,YAAY,KAAK,MAAM,KAAK,KAAK,KAAK,WAAW,MAAM,CAAC,KACrD,KAAK,MAAM,KAAK,KAAK,KAAK,QAAQ,MAAM,CAAC;AAEhD,iBAAa;AAEb,QAAM,MAAO,KAAK,KAAK,IAAK;AAE5B,aAAS,IAAI,GAAG,IAAI,YAAY,KAAK,KACrC;AACI,aAAO,KACH,IAAK,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,OAC1B,IAAK,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,MAAO;;AAIzC,WAAO,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;;EAGpC,aAAA,SAAY,cAAc,kBAAgB;AAEtC,QAAM,SAAS,aAAa;AAC5B,QAAMA,SAAQ,iBAAiB;AAC/B,QAAM,UAAU,iBAAiB;AAEjC,QAAI,UAAUA,OAAM,SAAS;AAC7B,QAAM,SAAS;AAEf,QAAM,SAAU,aAAa;AAC7B,QAAM,SAAS,aAAa;AAC5B,QAAM,IAAI,OAAO;AACjB,QAAM,IAAI,OAAO;AAGjB,IAAAA,OAAM,KACF,aAAa,SAAU,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO,KAAK,GACpE,aAAa,SAAU,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO,KAAK,CAAC;AAEzE,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GACxC;AACI,MAAAA,OAAM,KAAK,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC;AAGnC,cAAQ,KAAK,WAAW,QAAQ,OAAO;;;;AC9E5C,IAAM,iBAAqC;EAE9C,OAAA,SAAM,cAAY;AAKd,QAAM,WAAW,aAAa;AAC9B,QAAM,IAAI,SAAS;AACnB,QAAM,IAAI,SAAS;AACnB,QAAM,QAAQ,SAAS;AACvB,QAAM,SAAS,SAAS;AAExB,QAAM,SAAS,aAAa;AAE5B,WAAO,SAAS;AAEhB,WAAO,KAAK,GAAG,GACX,IAAI,OAAO,GACX,IAAI,OAAO,IAAI,QACf,GAAG,IAAI,MAAM;;EAGrB,aAAW,SAAC,cAAc,kBAAgB;AAEtC,QAAM,SAAS,aAAa;AAC5B,QAAMA,SAAQ,iBAAiB;AAE/B,QAAM,UAAUA,OAAM,SAAS;AAE/B,IAAAA,OAAM,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,GAC1B,OAAO,CAAC,GAAG,OAAO,CAAC,GACnB,OAAO,CAAC,GAAG,OAAO,CAAC,GACnB,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAExB,qBAAiB,QAAQ,KAAK,SAAS,UAAU,GAAG,UAAU,GAC1D,UAAU,GAAG,UAAU,GAAG,UAAU,CAAC;;;AC/BjD,SAAS,MAAM,IAAY,IAAY,MAAY;AAE/C,MAAM,OAAO,KAAK;AAElB,SAAO,KAAM,OAAO;AACxB;AAmBA,SAAS,qBACL,OAAe,OACf,KAAa,KACb,KAAa,KACb,KAAuB;AAAvB,MAAA,QAAA,QAAA;AAAA,UAAA,CAAA;EAAuB;AAEvB,MAAM,IAAI;AACV,MAAM,SAAS;AAEf,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,KAAK;AACT,MAAI,IAAI;AACR,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,EAAE,GACjC;AACI,QAAI,IAAI;AAGR,SAAK,MAAM,OAAO,KAAK,CAAC;AACxB,SAAK,MAAM,OAAO,KAAK,CAAC;AACxB,SAAK,MAAM,KAAK,KAAK,CAAC;AACtB,SAAK,MAAM,KAAK,KAAK,CAAC;AAGtB,QAAI,MAAM,IAAI,IAAI,CAAC;AACnB,QAAI,MAAM,IAAI,IAAI,CAAC;AAGnB,QAAI,MAAM,KAAK,OAAO,OAAO,SAAS,CAAC,MAAM,KAAK,OAAO,OAAO,SAAS,CAAC,MAAM,GAChF;AACI;;AAGJ,WAAO,KAAK,GAAG,CAAC;;AAGpB,SAAO;AACX;AAaO,IAAM,wBAA4C;EAErD,OAAA,SAAM,cAAY;AAEd,QAAM,YAAY,aAAa;AAC/B,QAAM,SAAS,aAAa;AAC5B,QAAM,IAAI,UAAU;AACpB,QAAM,IAAI,UAAU;AACpB,QAAM,QAAQ,UAAU;AACxB,QAAM,SAAS,UAAU;AAGzB,QAAM,SAAS,KAAK,IAAI,GAAG,KAAK,IAAI,UAAU,QAAQ,KAAK,IAAI,OAAO,MAAM,IAAI,CAAC,CAAC;AAElF,WAAO,SAAS;AAGhB,QAAI,CAAC,QACL;AACI,aAAO,KAAK,GAAG,GACX,IAAI,OAAO,GACX,IAAI,OAAO,IAAI,QACf,GAAG,IAAI,MAAM;WAGrB;AACI,2BAAqB,GAAG,IAAI,QACxB,GAAG,GACH,IAAI,QAAQ,GACZ,MAAM;AACV,2BAAqB,IAAI,QAAQ,QAC7B,GAAG,IAAI,OAAO,GACd,IAAI,OAAO,IAAI,QACf,MAAM;AACV,2BAAqB,IAAI,OAAO,IAAI,SAAS,QACzC,IAAI,OAAO,IAAI,QACf,IAAI,QAAQ,QAAQ,IAAI,QACxB,MAAM;AACV,2BAAqB,IAAI,QAAQ,IAAI,QACjC,GAAG,IAAI,QACP,GAAG,IAAI,SAAS,QAChB,MAAM;;;EAIlB,aAAW,SAAC,cAAc,kBAAgB;AAEtC,QAAM,SAAS,aAAa;AAE5B,QAAMA,SAAQ,iBAAiB;AAC/B,QAAM,UAAU,iBAAiB;AAEjC,QAAM,SAASA,OAAM,SAAS;AAE9B,QAAM,gBAAY,uBAAO,QAAQ,MAAM,CAAC;AAExC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAAK,GAClD;AACI,cAAQ,KAAK,UAAU,CAAC,IAAI,MAAM;AAElC,cAAQ,KAAK,UAAU,IAAI,CAAC,IAAI,MAAM;AAEtC,cAAQ,KAAK,UAAU,IAAI,CAAC,IAAI,MAAM;;AAG1C,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAC1C;AACI,MAAAA,OAAM,KAAK,OAAO,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC;;;;AC9I7C,SAAS,OACL,GACA,GACA,IACA,IACA,aACA,aACA,WACAA,QAAoB;AAGpB,MAAM,KAAK,IAAK,KAAK;AACrB,MAAM,KAAK,IAAK,KAAK;AACrB,MAAM,KAAK,IAAK,KAAK;AACrB,MAAM,KAAK,IAAK,KAAK;AAGrB,MAAI;AAAK,MACL;AAEJ,MAAI,WACJ;AACI,UAAM;AACN,UAAM,CAAC;SAGX;AACI,UAAM,CAAC;AACP,UAAM;;AAIV,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AAGjB,EAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,EAAAA,OAAM,KAAK,KAAK,GAAG;AAEnB,SAAO;AACX;AAmBA,SAAS,MACL,IACA,IACA,IACA,IACA,IACA,IACAA,QACA,WAAkB;AAGlB,MAAM,SAAS,KAAK;AACpB,MAAM,SAAS,KAAK;AAEpB,MAAI,SAAS,KAAK,MAAM,QAAQ,MAAM;AACtC,MAAI,SAAS,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAExC,MAAI,aAAa,SAAS,QAC1B;AACI,cAAU,KAAK,KAAK;aAEf,CAAC,aAAa,SAAS,QAChC;AACI,cAAU,KAAK,KAAK;;AAGxB,MAAI,aAAa;AACjB,MAAM,YAAY,SAAS;AAC3B,MAAM,eAAe,KAAK,IAAI,SAAS;AAoBvC,MAAM,SAAS,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AAC9D,MAAM,YAAa,KAAK,eAAe,KAAK,KAAK,MAAM,IAAI,KAAK,MAAO,KAAK;AAC5E,MAAM,WAAW,YAAY;AAE7B,gBAAc;AAEd,MAAI,WACJ;AACI,IAAAA,OAAM,KAAK,IAAI,EAAE;AACjB,IAAAA,OAAM,KAAK,IAAI,EAAE;AAEjB,aAAS,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,MAAAA,OAAM,KAAK,IAAI,EAAE;AACjB,MAAAA,OAAM,KAAK,KAAO,KAAK,IAAI,KAAK,IAAI,QAChC,KAAO,KAAK,IAAI,KAAK,IAAI,MAAQ;;AAGzC,IAAAA,OAAM,KAAK,IAAI,EAAE;AACjB,IAAAA,OAAM,KAAK,IAAI,EAAE;SAGrB;AACI,IAAAA,OAAM,KAAK,IAAI,EAAE;AACjB,IAAAA,OAAM,KAAK,IAAI,EAAE;AAEjB,aAAS,IAAI,GAAG,QAAQ,YAAY,IAAI,UAAU,KAAK,SAAS,UAChE;AACI,MAAAA,OAAM,KAAK,KAAO,KAAK,IAAI,KAAK,IAAI,QAChC,KAAO,KAAK,IAAI,KAAK,IAAI,MAAQ;AACrC,MAAAA,OAAM,KAAK,IAAI,EAAE;;AAGrB,IAAAA,OAAM,KAAK,IAAI,EAAE;AACjB,IAAAA,OAAM,KAAK,IAAI,EAAE;;AAGrB,SAAO,WAAW;AACtB;AAYA,SAAS,mBAAmB,cAA4B,kBAAkC;AAEtF,MAAM,QAAQ,aAAa;AAC3B,MAAI,SAAS,aAAa,UAAU,MAAM,OAAO,MAAK;AACtD,MAAM,MAAM,iBAAiB;AAE7B,MAAI,OAAO,WAAW,GACtB;AACI;;AAYJ,MAAM,QAAQ,aAAa;AAG3B,MAAM,aAAa,IAAI,MAAM,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AACjD,MAAM,YAAY,IAAI,MAAM,OAAO,OAAO,SAAS,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;AAChF,MAAM,cAAc,MAAM,SAAS,OAAO,QAAQ,MAAM;AACxD,MAAM,aAAa,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI,OACnD,KAAK,IAAI,WAAW,IAAI,UAAU,CAAC,IAAI;AAG9C,MAAI,aACJ;AAEI,aAAS,OAAO,MAAK;AAErB,QAAI,YACJ;AACI,aAAO,IAAG;AACV,aAAO,IAAG;AACV,gBAAU,IAAI,OAAO,OAAO,SAAS,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;;AAGtE,QAAM,aAAa,WAAW,IAAI,UAAU,KAAK;AACjD,QAAM,aAAa,UAAU,IAAI,WAAW,KAAK;AAEjD,WAAO,QAAQ,WAAW,SAAS;AACnC,WAAO,KAAK,WAAW,SAAS;;AAGpC,MAAMA,SAAQ,iBAAiB;AAC/B,MAAM,SAAS,OAAO,SAAS;AAC/B,MAAI,aAAa,OAAO;AACxB,MAAM,aAAaA,OAAM,SAAS;AAGlC,MAAM,QAAQ,MAAM,QAAQ;AAC5B,MAAM,eAAe,QAAQ;AAC7B,MAAM,oBAAoB,MAAM,aAAa,MAAM;AAGnD,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK,OAAO,CAAC;AACjB,MAAI,KAAK;AACT,MAAI,KAAK;AAGT,MAAI,QAAQ,EAAE,KAAK;AACnB,MAAI,QAAQ,KAAK;AACjB,MAAI,SAAS;AACb,MAAI,SAAS;AAEb,MAAI,OAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAEtD,WAAS;AACT,WAAS;AACT,WAAS;AACT,WAAS;AAET,MAAM,QAAQ,MAAM;AACpB,MAAM,eAAe,IAAI,SAAS;AAClC,MAAM,cAAc,QAAQ;AAE5B,MAAI,CAAC,aACL;AACI,QAAI,MAAM,QAAQ,SAAS,OAC3B;AACI,oBAAc,MACV,KAAM,SAAS,cAAc,eAAe,KAC5C,KAAM,SAAS,cAAc,eAAe,KAC5C,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACdA,QACA,IAAI,IACJ;eAEC,MAAM,QAAQ,SAAS,QAChC;AACI,oBAAc,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,MAAMA,MAAK;;;AAKxF,EAAAA,OAAM,KACF,KAAM,QAAQ,aACd,KAAM,QAAQ,WAAY;AAC9B,EAAAA,OAAM,KACF,KAAM,QAAQ,aACd,KAAM,QAAQ,WAAY;AAE9B,WAAS,IAAI,GAAG,IAAI,SAAS,GAAG,EAAE,GAClC;AACI,SAAK,QAAQ,IAAI,KAAK,CAAC;AACvB,SAAK,QAAS,IAAI,KAAK,IAAK,CAAC;AAE7B,SAAK,OAAO,IAAI,CAAC;AACjB,SAAK,OAAQ,IAAI,IAAK,CAAC;AAEvB,SAAK,QAAQ,IAAI,KAAK,CAAC;AACvB,SAAK,QAAS,IAAI,KAAK,IAAK,CAAC;AAE7B,YAAQ,EAAE,KAAK;AACf,YAAQ,KAAK;AAEb,WAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAClD,aAAS;AACT,aAAS;AACT,aAAS;AACT,aAAS;AAET,aAAS,EAAE,KAAK;AAChB,aAAS,KAAK;AAEd,WAAO,KAAK,KAAM,SAAS,SAAW,SAAS,MAAO;AACtD,cAAU;AACV,cAAU;AACV,cAAU;AACV,cAAU;AAGV,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AACjB,QAAM,MAAM,KAAK;AAGjB,QAAM,QAAS,MAAM,MAAQ,MAAM;AACnC,QAAM,YAAa,QAAQ;AAG3B,QAAI,KAAK,IAAI,KAAK,IAAI,KACtB;AACI,MAAAA,OAAM,KACF,KAAM,QAAQ,aACd,KAAM,QAAQ,WAAY;AAC9B,MAAAA,OAAM,KACF,KAAM,QAAQ,aACd,KAAM,QAAQ,WAAY;AAE9B;;AAIJ,QAAM,MAAO,CAAC,QAAQ,OAAO,CAAC,QAAQ,OAAS,CAAC,QAAQ,OAAO,CAAC,QAAQ;AACxE,QAAM,MAAO,CAAC,SAAS,OAAO,CAAC,SAAS,OAAS,CAAC,SAAS,OAAO,CAAC,SAAS;AAC5E,QAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,QAAM,MAAO,MAAM,KAAO,MAAM,MAAO;AACvC,QAAM,SAAU,KAAK,OAAO,KAAK,OAAS,KAAK,OAAO,KAAK;AAG3D,QAAM,MAAM,MAAO,KAAK,MAAM;AAC9B,QAAM,MAAM,MAAO,KAAK,MAAM;AAE9B,QAAM,MAAM,MAAO,KAAK,MAAM;AAC9B,QAAM,MAAM,MAAO,KAAK,MAAM;AAG9B,QAAM,yBAAyB,KAAK,IAAK,MAAM,MAAQ,MAAM,KAAO,MAAM,MAAQ,MAAM,GAAI;AAC5F,QAAM,eAAe,YAAY,cAAc;AAC/C,QAAM,0BAA0B,yBAA0B,eAAe,eAAe;AACxF,QAAM,gBAAgB,SAAS;AAE/B,QAAI,eACJ;AACI,UAAI,MAAM,SAAS,UAAU,SAAS,QAAQ,eAAe,mBAC7D;AACI,YAAI,WACJ;AACI,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;eAGvE;AACI,UAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,UAAAA,OAAM,KAAK,KAAK,GAAG;;AAGvB,sBAAc;iBAET,MAAM,SAAS,UAAU,OAClC;AACI,YAAI,WACJ;AACI,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAEjE,wBAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5CA,QAAO,IAAI,IACX;AAEJ,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;eAGvE;AACI,UAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,UAAAA,OAAM,KAAK,KAAK,GAAG;AAEnB,wBAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5CA,QAAO,KAAK,IACZ;AAEJ,UAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,UAAAA,OAAM,KAAK,KAAK,GAAG;;aAI3B;AACI,QAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,QAAAA,OAAM,KAAK,KAAK,GAAG;;WAI3B;AACI,MAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,MAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,UAAI,MAAM,SAAS,UAAU,SAAS,QAAQ,eAAe;AAC7D;eAGS,MAAM,SAAS,UAAU,OAClC;AACI,YAAI,WACJ;AACI,wBAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5CA,QAAO,IAAI,IACX;eAGR;AACI,wBAAc,MACV,IAAI,IACJ,KAAM,QAAQ,aAAc,KAAM,QAAQ,aAC1C,KAAM,SAAS,aAAc,KAAM,SAAS,aAC5CA,QAAO,KAAK,IACZ;;aAIZ;AACI,YAAI,WACJ;AACI,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAK,GAAG;eAGvB;AACI,UAAAA,OAAM,KAAK,KAAK,GAAG;AACnB,UAAAA,OAAM,KAAK,KAAK,GAAG;;AAEvB,sBAAc;;AAElB,MAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,MAAAA,OAAM,KAAK,KAAM,SAAS,aAAc,KAAM,SAAS,WAAY;AACnE,oBAAc;;;AAItB,OAAK,QAAQ,SAAS,KAAK,CAAC;AAC5B,OAAK,QAAS,SAAS,KAAK,IAAK,CAAC;AAElC,OAAK,QAAQ,SAAS,KAAK,CAAC;AAC5B,OAAK,QAAS,SAAS,KAAK,IAAK,CAAC;AAElC,UAAQ,EAAE,KAAK;AACf,UAAQ,KAAK;AAEb,SAAO,KAAK,KAAM,QAAQ,QAAU,QAAQ,KAAM;AAClD,WAAS;AACT,WAAS;AACT,WAAS;AACT,WAAS;AAET,EAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AACjE,EAAAA,OAAM,KAAK,KAAM,QAAQ,aAAc,KAAM,QAAQ,WAAY;AAEjE,MAAI,CAAC,aACL;AACI,QAAI,MAAM,QAAQ,SAAS,OAC3B;AACI,oBAAc,MACV,KAAM,SAAS,cAAc,eAAe,KAC5C,KAAM,SAAS,cAAc,eAAe,KAC5C,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACd,KAAM,QAAQ,aACdA,QACA,KAAK,IACL;eAEC,MAAM,QAAQ,SAAS,QAChC;AACI,oBAAc,OAAO,IAAI,IAAI,OAAO,OAAO,aAAa,aAAa,OAAOA,MAAK;;;AAIzF,MAAM,UAAU,iBAAiB;AACjC,MAAM,OAAO,gBAAgB,UAAU,gBAAgB;AAGvD,WAAS,IAAI,YAAY,IAAI,aAAa,aAAa,GAAG,EAAE,GAC5D;AACI,SAAKA,OAAO,IAAI,CAAC;AACjB,SAAKA,OAAO,IAAI,IAAK,CAAC;AAEtB,SAAKA,QAAO,IAAI,KAAK,CAAC;AACtB,SAAKA,QAAQ,IAAI,KAAK,IAAK,CAAC;AAE5B,SAAKA,QAAO,IAAI,KAAK,CAAC;AACtB,SAAKA,QAAQ,IAAI,KAAK,IAAK,CAAC;AAG5B,QAAI,KAAK,IAAK,MAAM,KAAK,MAAQ,MAAM,KAAK,MAAQ,MAAM,KAAK,GAAI,IAAI,MACvE;AACI;;AAGJ,YAAQ,KAAK,GAAG,IAAI,GAAG,IAAI,CAAC;;AAEpC;AAYA,SAAS,gBAAgB,cAA4B,kBAAkC;AAEnF,MAAI,IAAI;AAER,MAAM,QAAQ,aAAa;AAC3B,MAAM,SAAS,aAAa,UAAU,MAAM;AAC5C,MAAM,cAAc,MAAM,SAAS,OAAO,QAAQ,MAAM;AAExD,MAAI,OAAO,WAAW;AAAG;EAAA;AAEzB,MAAMA,SAAQ,iBAAiB;AAC/B,MAAM,UAAU,iBAAiB;AACjC,MAAM,SAAS,OAAO,SAAS;AAE/B,MAAM,aAAaA,OAAM,SAAS;AAClC,MAAI,eAAe;AAEnB,EAAAA,OAAM,KAAK,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAE/B,OAAK,IAAI,GAAG,IAAI,QAAQ,KACxB;AACI,IAAAA,OAAM,KAAK,OAAO,IAAI,CAAC,GAAG,OAAQ,IAAI,IAAK,CAAC,CAAC;AAC7C,YAAQ,KAAK,cAAc,eAAe,CAAC;AAE3C;;AAGJ,MAAI,aACJ;AACI,YAAQ,KAAK,cAAc,UAAU;;AAE7C;AAYA,SAAgB,UAAU,cAA4B,kBAAkC;AAEpF,MAAI,aAAa,UAAU,QAC3B;AACI,oBAAgB,cAAc,gBAAgB;SAGlD;AACI,uBAAmB,cAAc,gBAAgB;;AAEzD;ACxkBA,IAAA,WAAA,WAAA;AAAA,WAAAC,YAAA;;AAeW,EAAAA,UAAA,UAAP,SAAe,IAAY,IAAY,IAAY,IAAY,QAAgB,QAAqB;AAEhG,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,QAAM,KAAK,QAAQ;AACnB,QAAM,KAAK,QAAQ;AACnB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK,IAAK,KAAK,KAAO,KAAK,EAAG;AAEzC,QAAI,KAAK,QAAU,WAAW,GAC9B;AACI,UAAI,OAAO,OAAO,SAAS,CAAC,MAAM,MAAM,OAAO,OAAO,SAAS,CAAC,MAAM,IACtE;AACI,eAAO,KAAK,IAAI,EAAE;;AAGtB,aAAO;;AAGX,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AACpC,QAAM,KAAK,SAAS,KAAK,KAAK,EAAE,IAAI;AACpC,QAAM,KAAK,KAAK,KAAK;AACrB,QAAM,KAAK,KAAK,KAAK;AACrB,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAM,KAAK,KAAO,KAAK;AAC7B,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,KAAK,MAAM,KAAK;AACtB,QAAM,aAAa,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAC9C,QAAM,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAE5C,WAAO;MACH,IAAK,KAAK;MACV,IAAK,KAAK;MACV;MACA;MACA;MACA,eAAgB,KAAK,KAAK,KAAK;;;AAsBhC,EAAAA,UAAA,MAAP,SAAW,SAAiB,SAAiB,IAAY,IAAY,QACjE,YAAoB,UAAkB,gBAAyB,QAAqB;AAEpF,QAAM,QAAQ,WAAW;AACzB,QAAM,IAAI,gBAAgB,eACtB,KAAK,IAAI,KAAK,IAAI,QAClB,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,EAAE;AAG1C,QAAM,QAAS,SAAU,IAAI;AAC7B,QAAM,SAAS,QAAQ;AACvB,QAAM,SAAS,KAAK,IAAI,KAAK;AAC7B,QAAM,SAAS,KAAK,IAAI,KAAK;AAC7B,QAAM,WAAW,IAAI;AACrB,QAAM,YAAa,WAAW,IAAK;AAEnC,aAAS,IAAI,GAAG,KAAK,UAAU,EAAE,GACjC;AACI,UAAM,OAAO,IAAK,YAAY;AAC9B,UAAM,QAAU,QAAS,aAAc,SAAS;AAChD,UAAM,IAAI,KAAK,IAAI,KAAK;AACxB,UAAM,IAAI,CAAC,KAAK,IAAI,KAAK;AAEzB,aAAO,MACA,SAAS,IAAM,SAAS,KAAM,SAAU,KACxC,SAAS,CAAC,IAAM,SAAS,KAAM,SAAU,EAAE;;;AAK9D,SAAAA;AAAA,EAAC;ACxHD,IAAA,cAAA,WAAA;AAAA,WAAAC,eAAA;;AAkBW,EAAAA,aAAA,cAAP,SACI,OAAe,OACf,KAAa,KACb,MAAc,MACd,KAAa,KAAW;AAExB,QAAM,IAAI;AACV,QAAI,SAAS;AACb,QAAI,IAAI;AACR,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,MAAM;AACV,QAAI,MAAM;AACV,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,KAAK;AACT,QAAI,KAAK;AACT,QAAI,QAAQ;AACZ,QAAI,QAAQ;AAEZ,aAAS,IAAI,GAAG,KAAK,GAAG,EAAE,GAC1B;AACI,UAAI,IAAI;AACR,WAAK,IAAI;AACT,WAAK,KAAK;AACV,WAAM,IAAM;AACZ,YAAM,KAAK;AACX,YAAM,MAAM;AAEZ,UAAK,MAAM,QAAU,IAAM,MAAM,IAAI,MAAQ,IAAM,KAAK,KAAK,OAAS,KAAK;AAC3E,UAAK,MAAM,QAAU,IAAM,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK;AACzE,WAAK,QAAQ;AACb,WAAK,QAAQ;AACb,cAAQ;AACR,cAAQ;AAER,gBAAU,KAAK,KAAM,KAAK,KAAO,KAAK,EAAG;;AAG7C,WAAO;;AAiBJ,EAAAA,aAAA,UAAP,SACI,KAAa,KACb,MAAc,MACd,KAAa,KACb,QAAqB;AAErB,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,WAAO,UAAU;AAEjB,QAAM,IAAI,gBAAgB,eACtBA,aAAY,YAAY,OAAO,OAAO,KAAK,KAAK,MAAM,MAAM,KAAK,GAAG,CAAC;AAGzE,QAAI,KAAK;AACT,QAAI,MAAM;AACV,QAAI,MAAM;AACV,QAAI,KAAK;AACT,QAAI,KAAK;AAET,WAAO,KAAK,OAAO,KAAK;AAExB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG,EAAE,GACjC;AACI,UAAI,IAAI;AAER,WAAM,IAAI;AACV,YAAM,KAAK;AACX,YAAM,MAAM;AAEZ,WAAK,IAAI;AACT,WAAK,KAAK;AAEV,aAAO,KACF,MAAM,QAAU,IAAI,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK,KAClE,MAAM,QAAU,IAAI,MAAM,IAAI,MAAQ,IAAI,KAAK,KAAK,OAAS,KAAK,GAAI;;;AAIvF,SAAAA;AAAA,EAAC;ACnHD,IAAA,iBAAA,WAAA;AAAA,WAAAC,kBAAA;;AAgBW,EAAAA,gBAAA,cAAP,SACI,OAAe,OACf,KAAa,KACb,KAAa,KAAW;AAExB,QAAM,KAAK,QAAS,IAAM,MAAO;AACjC,QAAM,KAAK,QAAS,IAAM,MAAO;AACjC,QAAM,KAAM,IAAM,MAAQ,IAAM;AAChC,QAAM,KAAM,IAAM,MAAQ,IAAM;AAChC,QAAM,IAAI,KAAQ,KAAK,KAAO,KAAK;AACnC,QAAM,IAAI,KAAQ,KAAK,KAAO,KAAK;AACnC,QAAM,IAAK,KAAK,KAAO,KAAK;AAE5B,QAAM,IAAI,IAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACnC,QAAM,KAAK,KAAK,KAAK,CAAC;AACtB,QAAM,MAAM,IAAM,IAAI;AACtB,QAAM,KAAK,IAAM,KAAK,KAAK,CAAC;AAC5B,QAAM,KAAK,IAAI;AAEf,YACK,MAAM,IACA,KAAK,KAAK,IAAI,OAEX,IAAM,IAAI,IAAM,IAAI,KACrB,KAAK,KAAM,IAAM,KAAM,KAAK,MAAM,KAAK,GAAG,MAElD,IAAM;;AAcR,EAAAA,gBAAA,UAAP,SAAe,KAAa,KAAa,KAAa,KAAa,QAAqB;AAEpF,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,QAAM,IAAI,gBAAgB,eACtBA,gBAAe,YAAY,OAAO,OAAO,KAAK,KAAK,KAAK,GAAG,CAAC;AAGhE,QAAI,KAAK;AACT,QAAI,KAAK;AAET,aAAS,IAAI,GAAG,KAAK,GAAG,EAAE,GAC1B;AACI,UAAM,IAAI,IAAI;AAEd,WAAK,SAAU,MAAM,SAAS;AAC9B,WAAK,SAAU,MAAM,SAAS;AAE9B,aAAO,KAAK,MAAQ,OAAQ,MAAM,OAAO,IAAM,MAAM,GACjD,MAAQ,OAAQ,MAAM,OAAO,IAAM,MAAM,CAAE;;;AAG3D,SAAAA;AAAA,EAAC;AC9ED,IAAA,YAAA,WAAA;AAQI,WAAAC,aAAA;AAEI,SAAK,MAAK;;AAUP,EAAAA,WAAA,UAAA,QAAP,SAAa,OAA8B,YAAoB,aAAmB;AAE9E,SAAK,MAAK;AACV,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,cAAc;;AAShB,EAAAA,WAAA,UAAA,MAAP,SAAW,UAAkB,WAAiB;AAE1C,SAAK,aAAa,YAAY,KAAK;AACnC,SAAK,OAAO,WAAW,KAAK;;AAGzB,EAAAA,WAAA,UAAA,QAAP,WAAA;AAEI,SAAK,QAAQ;AACb,SAAK,OAAO;AACZ,SAAK,QAAQ;AACb,SAAK,cAAc;AACnB,SAAK,aAAa;;AAE1B,SAAAA;AAAA,EAAC;;ACnBM,IAAM,iBAAa,KAAA,CAAA,GACtB,GAAC,OAAO,IAAI,IAAG,WACf,GAAC,OAAO,IAAI,IAAG,aACf,GAAC,OAAO,IAAI,IAAG,aACf,GAAC,OAAO,IAAI,IAAG,gBACf,GAAC,OAAO,IAAI,IAAG;AASZ,IAAM,aAA+B,CAAA;AAQrC,IAAM,iBAAuC,CAAA;AC9CpD,SAAgB,mBAAmB,SAAgB;AAE/C,MAAM,SAAS,QAAQ;AAEvB,MAAI,MAAM;AAEV,WAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK,GAC5C;AACI,YAAQ,OAAO,IAAI,CAAC,IAAI,OAAO,CAAC,MAAM,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC;;AAGtE,SAAO,MAAM;AACjB;ACfA,IAAA,eAAA,WAAA;AAwBI,WAAAC,cAAY,OAAe,WAA6B,WAA6B,QAAqB;AAA/E,QAAA,cAAA,QAAA;AAAA,kBAAA;IAA2B;AAAE,QAAA,cAAA,QAAA;AAAA,kBAAA;IAA2B;AAAE,QAAA,WAAA,QAAA;AAAA,eAAA;IAAqB;AAf1G,SAAA,SAAmB,CAAA;AAOnB,SAAA,QAA6B,CAAA;AAczB,SAAK,QAAQ;AAMb,SAAK,YAAY;AAMjB,SAAK,YAAY;AAMjB,SAAK,SAAS;AAMd,SAAK,OAAO,MAAM;;AAQf,EAAAA,cAAA,UAAA,QAAP,WAAA;AAEI,WAAO,IAAIA,cACP,KAAK,OACL,KAAK,WACL,KAAK,WACL,KAAK,MAAM;;AAQZ,EAAAA,cAAA,UAAA,UAAP,WAAA;AAEI,SAAK,QAAQ;AACb,SAAK,MAAM,SAAS;AACpB,SAAK,QAAQ;AACb,SAAK,OAAO,SAAS;AACrB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,YAAY;;AAEzB,SAAAA;AAAA,EAAC;AC9DD,IAAM,WAAW,IAAI,MAAK;AAC1B,IAAM,YAAY,IAAI,OAAM;AAa5B,IAAA,mBAAA,SAAA,QAAA;AAAsC,YAAAC,mBAAA,MAAA;AAoFlC,WAAAA,oBAAA;AAAA,QAAA,QAEI,OAAA,KAAA,IAAA,KAAO;AA1EJ,UAAA,gBAAgB;AAGhB,UAAA,gBAAgB;AAEvB,UAAA,aAA2B;AAC3B,UAAA,gBAA2C;AAC3C,UAAA,YAAY;AAGZ,UAAA,SAAmB,CAAA;AAGnB,UAAA,SAAmB,CAAA;AAGnB,UAAA,MAAgB,CAAA;AAGhB,UAAA,UAAoB,CAAA;AAGpB,UAAA,aAAuB,CAAA;AAOvB,UAAA,eAAoC,CAAA;AAOpC,UAAA,YAAkC,CAAA;AAGlC,UAAA,aAAa;AAQb,UAAA,UAA4B,CAAA;AAGlB,UAAA,QAAQ;AAGR,UAAA,aAAa;AAGb,UAAA,aAAa;AAGb,UAAA,aAAa;AAOb,UAAA,UAAkB,IAAI,OAAM;AAG5B,UAAA,cAAc;;;AAcxB,SAAA,eAAWA,kBAAA,WAAA,UAAM;;;;;;;SAAjB,WAAA;AAEI,UAAI,KAAK,gBAAgB,KAAK,OAC9B;AACI,aAAK,cAAc,KAAK;AACxB,aAAK,gBAAe;;AAGxB,aAAO,KAAK;;;;;AAON,EAAAA,kBAAA,UAAA,aAAV,WAAA;AAEI,SAAK,cAAc;AACnB,SAAK;AACL,SAAK;AACL,SAAK,aAAa;AAElB,SAAK,OAAO,SAAS;AACrB,SAAK,OAAO,SAAS;AACrB,SAAK,IAAI,SAAS;AAClB,SAAK,QAAQ,SAAS;AACtB,SAAK,WAAW,SAAS;AAEzB,aAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,KAC3C;AACI,WAAK,UAAU,CAAC,EAAE,SAAS,MAAK;AAChC,qBAAe,KAAK,KAAK,UAAU,CAAC,CAAC;;AAGzC,SAAK,UAAU,SAAS;AAExB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACI,UAAM,YAAY,KAAK,QAAQ,CAAC;AAEhC,gBAAU,MAAK;AACf,iBAAW,KAAK,SAAS;;AAG7B,SAAK,QAAQ,SAAS;;AAQnB,EAAAA,kBAAA,UAAA,QAAP,WAAA;AAEI,QAAI,KAAK,aAAa,SAAS,GAC/B;AACI,WAAK,WAAU;AACf,WAAK;AACL,WAAK,aAAa,SAAS;;AAG/B,WAAO;;AAYJ,EAAAA,kBAAA,UAAA,YAAP,SACI,OACA,WACA,WACA,QAAqB;AAFrB,QAAA,cAAA,QAAA;AAAA,kBAAA;IAA2B;AAC3B,QAAA,cAAA,QAAA;AAAA,kBAAA;IAA2B;AAC3B,QAAA,WAAA,QAAA;AAAA,eAAA;IAAqB;AAErB,QAAM,OAAO,IAAI,aAAa,OAAO,WAAW,WAAW,MAAM;AAEjE,SAAK,aAAa,KAAK,IAAI;AAC3B,SAAK;AAEL,WAAO;;AAUJ,EAAAA,kBAAA,UAAA,WAAP,SAAgB,OAAe,QAAqB;AAArB,QAAA,WAAA,QAAA;AAAA,eAAA;IAAqB;AAEhD,QAAI,CAAC,KAAK,aAAa,QACvB;AACI,aAAO;;AAGX,QAAM,OAAO,IAAI,aAAa,OAAO,MAAM,MAAM,MAAM;AAEvD,QAAM,YAAY,KAAK,aAAa,KAAK,aAAa,SAAS,CAAC;AAEhE,SAAK,YAAY,UAAU;AAE3B,cAAU,MAAM,KAAK,IAAI;AAEzB,SAAK;AAEL,WAAO;;AAOJ,EAAAA,kBAAA,UAAA,UAAP,WAAA;AAEI,WAAA,UAAM,QAAO,KAAA,IAAA;AAGb,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,EAAE,GAChD;AACI,WAAK,aAAa,CAAC,EAAE,QAAO;;AAGhC,SAAK,OAAO,SAAS;AACrB,SAAK,SAAS;AACd,SAAK,OAAO,SAAS;AACrB,SAAK,SAAS;AACd,SAAK,IAAI,SAAS;AAClB,SAAK,MAAM;AACX,SAAK,QAAQ,SAAS;AACtB,SAAK,UAAU;AACf,SAAK,YAAY,QAAO;AACxB,SAAK,cAAc;AACnB,SAAK,aAAa,SAAS;AAC3B,SAAK,eAAe;AACpB,SAAK,UAAU,SAAS;AACxB,SAAK,YAAY;AACjB,SAAK,QAAQ,SAAS;AACtB,SAAK,UAAU;AACf,SAAK,UAAU;;AASZ,EAAAA,kBAAA,UAAA,gBAAP,SAAqB,OAAiB;AAElC,QAAM,eAAe,KAAK;AAE1B,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,EAAE,GAC3C;AACI,UAAM,OAAO,aAAa,CAAC;AAE3B,UAAI,CAAC,KAAK,UAAU,SACpB;AACI;;AAIJ,UAAI,KAAK,OACT;AACI,YAAI,KAAK,QACT;AACI,eAAK,OAAO,aAAa,OAAO,QAAQ;eAG5C;AACI,mBAAS,SAAS,KAAK;;AAG3B,YAAI,KAAK,MAAM,SAAS,SAAS,GAAG,SAAS,CAAC,GAC9C;AACI,cAAI,UAAU;AAEd,cAAI,KAAK,OACT;AACI,qBAAS,MAAI,GAAG,MAAI,KAAK,MAAM,QAAQ,OACvC;AACI,kBAAM,OAAO,KAAK,MAAM,GAAC;AAEzB,kBAAI,KAAK,MAAM,SAAS,SAAS,GAAG,SAAS,CAAC,GAC9C;AACI,0BAAU;AACV;;;;AAKZ,cAAI,CAAC,SACL;AACI,mBAAO;;;;;AAMvB,WAAO;;AASX,EAAAA,kBAAA,UAAA,gBAAA,SAAc,gBAAwB;AAElC,QAAI,CAAC,KAAK,aAAa,QACvB;AACI,WAAK,YAAY;AAEjB;;AAGJ,QAAI,CAAC,KAAK,iBAAgB,GAC1B;AACI;;AAGJ,SAAK,aAAa,KAAK;AAEvB,QAAM,MAAM,KAAK;AACjB,QAAM,eAAe,KAAK;AAE1B,QAAI,YAAuB;AAE3B,QAAI,eAAe;AAEnB,QAAI,KAAK,QAAQ,SAAS,GAC1B;AACI,kBAAY,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AAChD,qBAAe,UAAU;;AAG7B,aAAS,IAAI,KAAK,YAAY,IAAI,aAAa,QAAQ,KACvD;AACI,WAAK;AAEL,UAAM,OAAO,aAAa,CAAC;AAC3B,UAAM,YAAY,KAAK;AACvB,UAAM,YAAY,KAAK;AACvB,UAAM,UAAU,cAAc,KAAK,IAAI;AAGvC,cAAQ,MAAM,IAAI;AAElB,UAAI,KAAK,QACT;AACI,aAAK,gBAAgB,KAAK,QAAQ,KAAK,MAAM;;AAGjD,eAAS,IAAI,GAAG,IAAI,GAAG,KACvB;AACI,YAAM,QAAS,MAAM,IAAK,YAAY;AAEtC,YAAI,CAAC,MAAM;AAAS;QAAA;AAEpB,YAAM,cAAc,MAAM,QAAQ;AAClC,YAAM,UAAQ,KAAK,QAAQ;AAC3B,YAAM,cAAc,KAAK,OAAO,SAAS;AAEzC,oBAAY,WAAW,WAAW;AAElC,YAAI,MAAM,GACV;AACI,eAAK,YAAY,IAAI;eAGzB;AACI,eAAK,YAAY,IAAI;;AAGzB,YAAM,OAAQ,KAAK,OAAO,SAAS,IAAK;AAExC,YAAI,SAAS;AAAG;QAAA;AAEhB,YAAI,aAAa,CAAC,KAAK,eAAe,cAAc,KAAK,GACzD;AACI,oBAAU,IAAI,SAAO,WAAW;AAChC,sBAAY;;AAGhB,YAAI,CAAC,WACL;AACI,sBAAY,WAAW,IAAG,KAAM,IAAI,UAAS;AAC7C,oBAAU,MAAM,OAAO,SAAO,WAAW;AACzC,eAAK,QAAQ,KAAK,SAAS;AAC3B,yBAAe;;AAGnB,aAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,SAAS,aAAa,MAAM,MAAM,MAAM;;;AAIpF,QAAM,QAAQ,KAAK,QAAQ;AAC3B,QAAM,SAAS,KAAK,OAAO,SAAS;AAEpC,QAAI,WACJ;AACI,gBAAU,IAAI,OAAO,MAAM;;AAG/B,QAAI,KAAK,QAAQ,WAAW,GAC5B;AAGI,WAAK,YAAY;AAEjB;;AAIJ,QAAI,KAAK,iBAAiB,KAAK,QAAQ,WAAW,KAAK,cAAc,QACrE;AACI,WAAK,cAAc,IAAI,KAAK,OAAO;WAGvC;AACI,UAAM,SACA,SAAS,SAAU;AAEzB,WAAK,gBAAgB,SAAS,IAAI,YAAY,KAAK,OAAO,IAAI,IAAI,YAAY,KAAK,OAAO;;AAI9F,SAAK,YAAY,KAAK,YAAW;AAEjC,QAAI,KAAK,WACT;AACI,WAAK,YAAW;WAGpB;AACI,WAAK,eAAc;;;AAUjB,EAAAA,kBAAA,UAAA,iBAAV,SAAyB,QAA+B,QAA6B;AAEjF,QAAI,CAAC,UAAU,CAAC,QAChB;AACI,aAAO;;AAGX,QAAI,OAAO,QAAQ,gBAAgB,OAAO,QAAQ,aAClD;AACI,aAAO;;AAGX,QAAI,OAAO,QAAQ,OAAO,UAAU,OAAO,QAAQ,OAAO,OAC1D;AACI,aAAO;;AAGX,QAAI,CAAC,CAAE,OAAqB,WAAW,CAAC,CAAE,OAAqB,QAC/D;AACI,aAAO;;AAGX,WAAO;;AAQD,EAAAA,kBAAA,UAAA,mBAAV,WAAA;AAEI,QAAI,KAAK,UAAU,KAAK,cAAc,CAAC,KAAK,aAAa,QACzD;AACI,aAAO;;AAGX,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,IAAI,GAAG,KACrD;AACI,UAAM,OAAO,KAAK,aAAa,CAAC;AAChC,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAElB,UAAI,QAAQ,CAAC,KAAK,QAAQ,YAAY;AAAO,eAAO;MAAK;AACzD,UAAI,QAAQ,CAAC,KAAK,QAAQ,YAAY;AAAO,eAAO;MAAK;;AAG7D,WAAO;;AAQD,EAAAA,kBAAA,UAAA,cAAV,WAAA;AAEI,SAAK;AACL,SAAK,aAAa,IAAI,aAAa,KAAK,GAAG;AAE3C,QAAM,UAAU,KAAK;AAErB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAAI,GAAG,KAC3C;AACI,UAAM,QAAQ,QAAQ,CAAC;AAEvB,eAAS,IAAI,GAAG,IAAI,MAAM,MAAM,KAChC;AACI,YAAM,QAAQ,MAAM,QAAQ;AAE5B,aAAK,cAAc,KAAK,IAAI,KAAK,cAAc,KAAK,IAAI,MAAM;;;;AAWhE,EAAAA,kBAAA,UAAA,cAAV,WAAA;AAGI,QAAI,KAAK,OAAO,SAAS,QAAS,GAClC;AACI,aAAO;;AAGX,QAAM,UAAU,KAAK;AAErB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KACpC;AACI,UAAK,QAAQ,CAAC,EAAE,MAAoB,QACpC;AACI,eAAO;;;AAIf,WAAQ,KAAK,OAAO,SAASA,kBAAiB,iBAAiB;;AAQzD,EAAAA,kBAAA,UAAA,iBAAV,WAAA;AAEI,QAAI,OAAO,EAAE,YAAY;AAEzB,aAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,KAC3C;AACI,WAAK,UAAU,CAAC,EAAE,SAAS,MAAK;AAChC,qBAAe,KAAK,KAAK,UAAU,CAAC,CAAC;;AAGzC,SAAK,UAAU,SAAS;AAExB,QAAM,SAAS,KAAK;AACpB,QAAM,aAAa,KAAK;AAExB,QAAI,eAA+B,eAAe,IAAG;AAErD,QAAI,CAAC,cACL;AACI,qBAAe,IAAI,cAAa;AAChC,mBAAa,WAAW,IAAI,kBAAiB;;AAEjD,iBAAa,SAAS,QAAQ;AAC9B,iBAAa,QAAQ;AACrB,iBAAa,OAAO;AACpB,iBAAa,OAAO,WAAW;AAE/B,QAAI,eAAe;AACnB,QAAI,iBAAiB;AACrB,QAAI,YAAY;AAChB,QAAI,SAAS;AACb,QAAI,WAAW,WAAW;AAE1B,QAAI,QAAQ;AAEZ,SAAK,UAAU,KAAK,YAAY;AAGhC,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACI,UAAM,OAAO,KAAK,QAAQ,CAAC;AAG3B,UAAM,eAAe;AAGrB,UAAM,QAAQ,KAAK;AAEnB,UAAM,cAAc,MAAM,QAAQ;AAElC,UAAI,WAAW,CAAC,CAAC,MAAM,QACvB;AACI,iBAAS,CAAC,CAAC,MAAM;AACjB,mBAAW,SAAS,WAAW,QAAQ,WAAW;AAGlD,yBAAiB;AACjB,uBAAe;AACf;;AAGJ,UAAI,mBAAmB,aACvB;AACI,yBAAiB;AAEjB,YAAI,YAAY,kBAAkB,MAClC;AACI,cAAI,iBAAiB,cACrB;AACI;AAEA,2BAAe;AAEf,gBAAI,aAAa,OAAO,GACxB;AACI,6BAAe,eAAe,IAAG;AACjC,kBAAI,CAAC,cACL;AACI,+BAAe,IAAI,cAAa;AAChC,6BAAa,WAAW,IAAI,kBAAiB;;AAEjD,mBAAK,UAAU,KAAK,YAAY;;AAGpC,yBAAa,QAAQ;AACrB,yBAAa,OAAO;AACpB,yBAAa,SAAS,QAAQ;AAC9B,yBAAa,OAAO;;AAKxB,sBAAY,UAAU;AAEtB,sBAAY,gBAAgB;AAC5B,sBAAY,iBAAiB;AAC7B,sBAAY,WAAW,WAAW;AAElC,uBAAa,SAAS,SAAS,aAAa,SAAS,OAAO,IAAI;AAChE;;;AAIR,mBAAa,QAAQ,KAAK;AAC1B,eAAS,KAAK;AAEd,kBAAY,YAAY;AAExB,WAAK,UAAU,QAAQ,MAAM,OAAO,MAAM,OAAO,KAAK,YAAY,KAAK,WAAW;AAClF,WAAK,cAAc,YAAY,WAAW,KAAK,YAAY,KAAK,WAAW;;AAG/E,gBAAY,eAAe;AAI3B,SAAK,eAAc;;AAQb,EAAAA,kBAAA,UAAA,iBAAV,WAAA;AAEI,QAAMN,SAAQ,KAAK;AACnB,QAAM,MAAM,KAAK;AACjB,QAAM,SAAS,KAAK;AACpB,QAAM,aAAa,KAAK;AAGxB,QAAM,WAAW,IAAI,YAAYA,OAAM,SAAS,IAAI,CAAC;AACrD,QAAM,MAAM,IAAI,aAAa,QAAQ;AACrC,QAAM,MAAM,IAAI,YAAY,QAAQ;AAEpC,QAAI,IAAI;AAER,aAAS,IAAI,GAAG,IAAIA,OAAM,SAAS,GAAG,KACtC;AACI,UAAI,GAAG,IAAIA,OAAM,IAAI,CAAC;AACtB,UAAI,GAAG,IAAIA,OAAO,IAAI,IAAK,CAAC;AAE5B,UAAI,GAAG,IAAI,IAAI,IAAI,CAAC;AACpB,UAAI,GAAG,IAAI,IAAK,IAAI,IAAK,CAAC;AAE1B,UAAI,GAAG,IAAI,OAAO,CAAC;AAEnB,UAAI,GAAG,IAAI,WAAW,CAAC;;AAG3B,SAAK,QAAQ,OAAO,QAAQ;AAC5B,SAAK,aAAa,OAAO,KAAK,aAAa;;AASrC,EAAAM,kBAAA,UAAA,cAAV,SAAsB,MAAkB;AAEpC,QAAI,KAAK,MAAM,QACf;AACI,WAAK,aAAa,KAAK,KAAK;AAE5B,gBAAU,YAAY,MAAM,IAAI;WAGpC;AACI,UAAM,UAAU,cAAc,KAAK,IAAI;AAEvC,cAAQ,YAAY,MAAM,IAAI;;;AAU5B,EAAAA,kBAAA,UAAA,cAAV,SAAsB,MAAkB;AAEpC,cAAU,MAAM,IAAI;AAEpB,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KACvC;AACI,gBAAU,KAAK,MAAM,CAAC,GAAG,IAAI;;;AAU3B,EAAAA,kBAAA,UAAA,eAAV,SAAuB,OAA0B;AAE7C,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAClC;AACI,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,UAAU,cAAc,KAAK,IAAI;AAEvC,cAAQ,MAAM,IAAI;AAElB,UAAI,KAAK,QACT;AACI,aAAK,gBAAgB,KAAK,QAAQ,KAAK,MAAM;;;;AAU/C,EAAAA,kBAAA,UAAA,kBAAV,WAAA;AAEI,QAAM,SAAS,KAAK;AACpB,QAAM,iBAAiB;AACvB,QAAI,YAAY,OAAO;AAEvB,SAAK,QAAQ,MAAK;AAClB,mBAAe,MAAK;AAEpB,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAC9C;AACI,UAAM,OAAO,KAAK,aAAa,CAAC;AAChC,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,KAAK;AAClB,UAAM,YAAY,KAAK;AACvB,UAAM,aAAa,KAAK,UAAU,OAAO;AACzC,UAAI,YAAY;AAEhB,UAAI,aAAa,UAAU,SAC3B;AACI,YAAM,YAAY,UAAU;AAE5B,oBAAY,UAAU;AAEtB,YAAI,SAAS,OAAO,MACpB;AACI,cAAI,mBAAmB,KAAgB,GACvC;AACI,wBAAY,aAAa,IAAI;iBAGjC;AACI,wBAAY,YAAY;;eAIhC;AACI,sBAAY,YAAY,KAAK,IAAI,GAAG,SAAS;;;AAIrD,UAAI,cAAc,YAClB;AACI,YAAI,CAAC,eAAe,QAAO,GAC3B;AACI,iBAAO,gBAAgB,gBAAgB,SAAS;AAChD,yBAAe,MAAK;;AAExB,oBAAY;;AAGhB,UAAI,SAAS,OAAO,QAAQ,SAAS,OAAO,MAC5C;AACI,YAAM,OAAO;AAEb,uBAAe,YAAY,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,KAAK,OAAO,KAAK,IAAI,KAAK,QAC1E,WAAW,SAAS;iBAEnB,SAAS,OAAO,MACzB;AACI,YAAM,SAAS;AAEf,uBAAe,YAAY,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,GAC5D,OAAO,SAAS,WAAW,OAAO,SAAS,SAAS;iBAEnD,SAAS,OAAO,MACzB;AACI,YAAM,UAAU;AAEhB,uBAAe,YAAY,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAChE,QAAQ,QAAQ,WAAW,QAAQ,SAAS,SAAS;aAG7D;AACI,YAAM,OAAO;AAGb,eAAO,kBAAkB,WAAY,KAAK,QAAgB,GAAG,KAAK,OAAO,QAAQ,WAAW,SAAS;;;AAI7G,QAAI,CAAC,eAAe,QAAO,GAC3B;AACI,aAAO,gBAAgB,gBAAgB,SAAS;;AAGpD,WAAO,IAAI,KAAK,eAAe,KAAK,aAAa;;AAU3C,EAAAA,kBAAA,UAAA,kBAAV,SAA0B,QAAuB,QAAc;AAE3D,aAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KACvC;AACI,UAAM,IAAI,OAAQ,IAAI,CAAC;AACvB,UAAM,IAAI,OAAQ,IAAI,IAAK,CAAC;AAE5B,aAAQ,IAAI,CAAC,IAAM,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AAC3D,aAAQ,IAAI,IAAK,CAAC,IAAK,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;;;AAc7D,EAAAA,kBAAA,UAAA,YAAV,SACI,QACA,OACA,OACA,MACA,QAAU;AAAV,QAAA,WAAA,QAAA;AAAA,eAAA;IAAU;AAGV,QAAM,OAAO,SAAS,OAAO,QAAQ,WAAY,QAAQ,QAAS;AAElE,QAAM,OAAQ,gBAAgB,KAAK,KAAK;AAExC,WAAO,SAAS,KAAK,IAAI,OAAO,QAAQ,SAAS,IAAI;AAErD,aAAS,IAAI,GAAG,IAAI,MAAM,KAC1B;AACI,aAAO,SAAS,CAAC,IAAI;;;AAanB,EAAAA,kBAAA,UAAA,gBAAV,SACI,YACA,IACA,MACA,QAAU;AAAV,QAAA,WAAA,QAAA;AAAA,eAAA;IAAU;AAEV,eAAW,SAAS,KAAK,IAAI,WAAW,QAAQ,SAAS,IAAI;AAE7D,aAAS,IAAI,GAAG,IAAI,MAAM,KAC1B;AACI,iBAAW,SAAS,CAAC,IAAI;;;AAevB,EAAAA,kBAAA,UAAA,SAAV,SACIN,QACA,KACA,SACA,OAAe,MACP,QACK;AADL,QAAA,WAAA,QAAA;AAAA,eAAA;IACK;AAEb,QAAI,QAAQ;AACZ,QAAM,WAAW,IAAI;AACrB,QAAM,QAAQ,QAAQ;AAEtB,WAAO,QAAQ,MACf;AACI,UAAI,IAAIA,QAAO,QAAQ,SAAS,CAAC;AACjC,UAAI,IAAIA,QAAQ,QAAQ,SAAS,IAAK,CAAC;AAEvC,UAAI,QACJ;AACI,YAAM,KAAM,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AAEpD,YAAK,OAAO,IAAI,IAAM,OAAO,IAAI,IAAK,OAAO;AAC7C,YAAI;;AAGR;AAEA,UAAI,KAAK,IAAI,MAAM,OAAO,IAAI,MAAM,MAAM;;AAG9C,QAAM,cAAc,QAAQ;AAE5B,QAAI,MAAM,QAAQ,YAAY,SACvB,MAAM,SAAS,YAAY,QAClC;AACI,WAAK,UAAU,KAAK,SAAS,UAAU,IAAI;;;AAazC,EAAAM,kBAAA,UAAA,YAAV,SAAoB,KAAoB,SAAkB,OAAe,MAAY;AAEjF,QAAM,cAAc,QAAQ;AAC5B,QAAM,MAAM;AACZ,QAAM,SAAS,QAAS,OAAO;AAC/B,QAAM,QAAQ,QAAQ;AACtB,QAAM,SAAS,MAAM,QAAQ,YAAY;AACzC,QAAM,SAAS,MAAM,SAAS,YAAY;AAC1C,QAAI,UAAU,MAAM,IAAI,MAAM;AAC9B,QAAI,UAAU,MAAM,IAAI,MAAM;AAC9B,QAAI,OAAO,KAAK,MAAM,IAAI,KAAK,IAAI,GAAG;AACtC,QAAI,OAAO,KAAK,MAAM,IAAI,QAAQ,CAAC,IAAI,GAAG;AAE1C,aAAS,IAAI,QAAQ,GAAG,IAAI,QAAQ,KAAK,GACzC;AACI,aAAO,KAAK,IAAI,MAAM,KAAK,MAAM,IAAI,CAAC,IAAI,GAAG,CAAC;AAC9C,aAAO,KAAK,IAAI,MAAM,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC;;AAEtD,eAAW;AACX,eAAW;AACX,aAAS,IAAI,OAAO,IAAI,QAAQ,KAAK,GACrC;AACI,UAAI,CAAC,KAAK,IAAI,CAAC,IAAI,WAAW;AAC9B,UAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,WAAW;;;AAl/BhC,EAAAA,kBAAA,iBAAiB;AAq/BnC,SAAAA;EA3/BsC,aAAa;ACvCnD,IAAA,YAAA,SAAA,QAAA;AAA+B,YAAAC,YAAA,MAAA;AAA/B,WAAAA,aAAA;AAAA,QAAA,QAAA,WAAA,QAAA,OAAA,MAAA,MAAA,SAAA,KAAA;AAGW,UAAA,QAAQ;AAGR,UAAA,YAAY;AAGZ,UAAA,SAAS;AAQT,UAAA,MAAM,SAAS;AAQf,UAAA,OAAO,UAAU;AAGjB,UAAA,aAAa;;;AAOb,EAAAA,WAAA,UAAA,QAAP,WAAA;AAEI,QAAM,MAAM,IAAIA,WAAS;AAEzB,QAAI,QAAQ,KAAK;AACjB,QAAI,QAAQ,KAAK;AACjB,QAAI,UAAU,KAAK;AACnB,QAAI,SAAS,KAAK;AAClB,QAAI,UAAU,KAAK;AACnB,QAAI,QAAQ,KAAK;AACjB,QAAI,YAAY,KAAK;AACrB,QAAI,SAAS,KAAK;AAClB,QAAI,MAAM,KAAK;AACf,QAAI,OAAO,KAAK;AAChB,QAAI,aAAa,KAAK;AAEtB,WAAO;;AAMJ,EAAAA,WAAA,UAAA,QAAP,WAAA;AAEI,WAAA,UAAM,MAAK,KAAA,IAAA;AAGX,SAAK,QAAQ;AAEb,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,SAAS;;AAEtB,SAAAA;AAAA,EApE+B,SAAS;AC+CxC,IAAM,OAAO,IAAI,aAAa,CAAC;AAG/B,IAAM,kBAA2C,CAAA;AAyBjD,IAAA,WAAA,SAAA,QAAA;AAA8B,YAAAC,WAAA,MAAA;AAkG1B,WAAAA,UAAY,UAAiC;AAAjC,QAAA,aAAA,QAAA;AAAA,iBAAA;IAAiC;AAA7C,QAAA,QAEI,OAAA,KAAA,IAAA,KAAO;AAnFJ,UAAA,SAAiB;AAGjB,UAAA,aAAa;AAQb,UAAA,cAAuB;AAOpB,UAAA,UAAwC,CAAA;AAGxC,UAAA,YAAY;AAGZ,UAAA,aAAa;AAGb,UAAA,aAA2B;AAO3B,UAAA,aAAwB,IAAI,UAAS;AAOrC,UAAA,aAAwB,IAAI,UAAS;AAOrC,UAAA,UAAkB;AAGlB,UAAA,YAAY;AAUd,UAAA,QAAe,MAAM,MAAK;AAwB9B,UAAK,YAAY,YAAY,IAAI,iBAAgB;AACjD,UAAK,UAAU;AAef,UAAK,eAAe;AAGpB,UAAK,OAAO;AACZ,UAAK,YAAY,YAAY;;;AAjCjC,SAAA,eAAWA,UAAA,WAAA,YAAQ;;;;;;;;;SAAnB,WAAA;AAEI,aAAO,KAAK;;;;;AAwCT,EAAAA,UAAA,UAAA,QAAP,WAAA;AAEI,SAAK,WAAU;AAEf,WAAO,IAAIA,UAAS,KAAK,SAAS;;AActC,SAAA,eAAWA,UAAA,WAAA,aAAS;SAKpB,WAAA;AAEI,aAAO,KAAK,MAAM;;;;;;;;;;;;;SAPtB,SAAqB,OAAkB;AAEnC,WAAK,MAAM,YAAY;;;;;AAe3B,SAAA,eAAWA,UAAA,WAAA,QAAI;;;;;;;;SAAf,WAAA;AAEI,aAAO,KAAK;;SAGhB,SAAgB,OAAa;AAEzB,WAAK,QAAQ;;;;;AASjB,SAAA,eAAWA,UAAA,WAAA,QAAI;;;;;;;SAAf,WAAA;AAEI,aAAO,KAAK;;;;;AAShB,SAAA,eAAWA,UAAA,WAAA,QAAI;;;;;;;SAAf,WAAA;AAEI,aAAO,KAAK;;;;;AAmCT,EAAAA,UAAA,UAAA,YAAP,SAAiB,SACb,OAAa,OAAW,WAAiB,QAAc;AAD1C,QAAA,YAAA,QAAA;AAAA,gBAAA;IAA0C;AACvD,QAAA,UAAA,QAAA;AAAA,cAAA;IAAW;AAAE,QAAA,UAAA,QAAA;AAAA,cAAA;IAAS;AAAE,QAAA,cAAA,QAAA;AAAA,kBAAA;IAAe;AAAE,QAAA,WAAA,QAAA;AAAA,eAAA;IAAc;AAGvD,QAAI,OAAO,YAAY,UACvB;AACI,gBAAU,EAAE,OAAO,SAAS,OAAO,OAAO,WAAW,OAAM;;AAG/D,WAAO,KAAK,iBAAiB,OAAO;;AAqBjC,EAAAA,UAAA,UAAA,mBAAP,SAAwB,SAA0B;AAG9C,cAAU,OAAO,OAAO;MACpB,OAAO;MACP,SAAS,QAAQ;MACjB,OAAQ,WAAW,QAAQ,UAAW,WAAW;MACjD,OAAO;MACP,QAAQ;MACR,WAAW;MACX,QAAQ;MACR,KAAK,SAAS;MACd,MAAM,UAAU;MAChB,YAAY;OACb,OAAO;AAEV,QAAI,KAAK,aACT;AACI,WAAK,UAAS;;AAGlB,QAAM,UAAU,QAAQ,QAAQ,KAAK,QAAQ,QAAQ;AAErD,QAAI,CAAC,SACL;AACI,WAAK,WAAW,MAAK;WAGzB;AACI,UAAI,QAAQ,QACZ;AACI,gBAAQ,SAAS,QAAQ,OAAO,MAAK;AACrC,gBAAQ,OAAO,OAAM;;AAGzB,aAAO,OAAO,KAAK,YAAY,EAAE,QAAO,GAAI,OAAO;;AAGvD,WAAO;;AAOD,EAAAA,UAAA,UAAA,YAAV,WAAA;AAEI,QAAI,KAAK,aACT;AACI,UAAM,SAAS,KAAK,YAAY;AAChC,UAAM,MAAM,KAAK,YAAY,OAAO;AAEpC,UAAI,MAAM,GACV;AACI,aAAK,UAAU,KAAK,WAAW;AAC/B,aAAK,cAAc,IAAI,QAAO;AAC9B,aAAK,YAAY,cAAc;AAC/B,aAAK,YAAY,OAAO,KAAK,OAAO,MAAM,CAAC,GAAG,OAAO,MAAM,CAAC,CAAC;;WAIrE;AACI,WAAK,cAAc,IAAI,QAAO;AAC9B,WAAK,YAAY,cAAc;;;AAQvC,EAAAA,UAAA,UAAA,aAAA,WAAA;AAEI,QAAI,KAAK,aACT;AACI,UAAI,KAAK,YAAY,OAAO,SAAS,GACrC;AACI,aAAK,UAAU,KAAK,WAAW;AAC/B,aAAK,cAAc;aAGvB;AACI,aAAK,YAAY,OAAO,SAAS;;;;AAYtC,EAAAA,UAAA,UAAA,SAAP,SAAc,GAAW,GAAS;AAE9B,SAAK,UAAS;AACd,SAAK,YAAY,OAAO,CAAC,IAAI;AAC7B,SAAK,YAAY,OAAO,CAAC,IAAI;AAE7B,WAAO;;AAWJ,EAAAA,UAAA,UAAA,SAAP,SAAc,GAAW,GAAS;AAE9B,QAAI,CAAC,KAAK,aACV;AACI,WAAK,OAAO,GAAG,CAAC;;AAIpB,QAAM,SAAS,KAAK,YAAY;AAChC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AACtC,QAAM,QAAQ,OAAO,OAAO,SAAS,CAAC;AAEtC,QAAI,UAAU,KAAK,UAAU,GAC7B;AACI,aAAO,KAAK,GAAG,CAAC;;AAGpB,WAAO;;AASD,EAAAA,UAAA,UAAA,aAAV,SAAqB,GAAO,GAAK;AAAZ,QAAA,MAAA,QAAA;AAAA,UAAA;IAAK;AAAE,QAAA,MAAA,QAAA;AAAA,UAAA;IAAK;AAE7B,QAAI,KAAK,aACT;AACI,UAAI,KAAK,YAAY,OAAO,WAAW,GACvC;AACI,aAAK,YAAY,SAAS,CAAC,GAAG,CAAC;;WAIvC;AACI,WAAK,OAAO,GAAG,CAAC;;;AAcjB,EAAAA,UAAA,UAAA,mBAAP,SAAwB,KAAa,KAAa,KAAa,KAAW;AAEtE,SAAK,WAAU;AAEf,QAAM,SAAS,KAAK,YAAY;AAEhC,QAAI,OAAO,WAAW,GACtB;AACI,WAAK,OAAO,GAAG,CAAC;;AAGpB,mBAAe,QAAQ,KAAK,KAAK,KAAK,KAAK,MAAM;AAEjD,WAAO;;AAcJ,EAAAA,UAAA,UAAA,gBAAP,SAAqB,KAAa,KAAa,MAAc,MAAc,KAAa,KAAW;AAE/F,SAAK,WAAU;AAEf,gBAAY,QAAQ,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,KAAK,YAAY,MAAM;AAE3E,WAAO;;AAeJ,EAAAA,UAAA,UAAA,QAAP,SAAa,IAAY,IAAY,IAAY,IAAY,QAAc;AAEvE,SAAK,WAAW,IAAI,EAAE;AAEtB,QAAM,SAAS,KAAK,YAAY;AAEhC,QAAM,SAAS,SAAS,QAAQ,IAAI,IAAI,IAAI,IAAI,QAAQ,MAAM;AAE9D,QAAI,QACJ;AACY,UAAA,KAAwD,OAAM,IAA1D,KAAoD,OAAM,IAAtD,WAAgD,OAAM,QAA9C,aAAwC,OAAM,YAAlC,WAA4B,OAAM,UAAxB,gBAAkB,OAAM;AAEtE,WAAK,IAAI,IAAI,IAAI,UAAQ,YAAY,UAAU,aAAa;;AAGhE,WAAO;;AAiBJ,EAAAA,UAAA,UAAA,MAAP,SAAW,IAAY,IAAY,QAAgB,YAAoB,UAAkB,eAAqB;AAArB,QAAA,kBAAA,QAAA;AAAA,sBAAA;IAAqB;AAE1G,QAAI,eAAe,UACnB;AACI,aAAO;;AAGX,QAAI,CAAC,iBAAiB,YAAY,YAClC;AACI,kBAAY;eAEP,iBAAiB,cAAc,UACxC;AACI,oBAAc;;AAGlB,QAAM,QAAQ,WAAW;AAEzB,QAAI,UAAU,GACd;AACI,aAAO;;AAGX,QAAM,SAAS,KAAM,KAAK,IAAI,UAAU,IAAI;AAC5C,QAAM,SAAS,KAAM,KAAK,IAAI,UAAU,IAAI;AAC5C,QAAM,MAAM,KAAK,UAAU;AAG3B,QAAI,SAAS,KAAK,cAAc,KAAK,YAAY,SAAS;AAE1D,QAAI,QACJ;AAII,UAAM,QAAQ,KAAK,IAAI,OAAO,OAAO,SAAS,CAAC,IAAI,MAAM;AACzD,UAAM,QAAQ,KAAK,IAAI,OAAO,OAAO,SAAS,CAAC,IAAI,MAAM;AAEzD,UAAI,QAAQ,OAAO,QAAQ;AAC3B;WAKA;AACI,eAAO,KAAK,QAAQ,MAAM;;WAIlC;AACI,WAAK,OAAO,QAAQ,MAAM;AAC1B,eAAS,KAAK,YAAY;;AAG9B,aAAS,IAAI,QAAQ,QAAQ,IAAI,IAAI,QAAQ,YAAY,UAAU,eAAe,MAAM;AAExF,WAAO;;AAWJ,EAAAA,UAAA,UAAA,YAAP,SAAiB,OAAW,OAAS;AAApB,QAAA,UAAA,QAAA;AAAA,cAAA;IAAS;AAAE,QAAA,UAAA,QAAA;AAAA,cAAA;IAAS;AAEjC,WAAO,KAAK,iBAAiB,EAAE,SAAS,QAAQ,OAAO,OAAO,MAAK,CAAE;;AAazE,EAAAA,UAAA,UAAA,mBAAA,SAAiB,SAA2B;AAGxC,cAAU,OAAO,OAAO;MACpB,SAAS,QAAQ;MACjB,OAAO;MACP,OAAO;MACP,QAAQ;OACT,OAAO;AAEV,QAAI,KAAK,aACT;AACI,WAAK,UAAS;;AAGlB,QAAM,UAAU,QAAQ,QAAQ;AAEhC,QAAI,CAAC,SACL;AACI,WAAK,WAAW,MAAK;WAGzB;AACI,UAAI,QAAQ,QACZ;AACI,gBAAQ,SAAS,QAAQ,OAAO,MAAK;AACrC,gBAAQ,OAAO,OAAM;;AAGzB,aAAO,OAAO,KAAK,YAAY,EAAE,QAAO,GAAI,OAAO;;AAGvD,WAAO;;AAQJ,EAAAA,UAAA,UAAA,UAAP,WAAA;AAEI,SAAK,WAAU;AAEf,SAAK,WAAW,MAAK;AAErB,WAAO;;AAYJ,EAAAA,UAAA,UAAA,WAAP,SAAgB,GAAW,GAAW,OAAe,QAAc;AAE/D,WAAO,KAAK,UAAU,IAAI,UAAU,GAAG,GAAG,OAAO,MAAM,CAAC;;AAarD,EAAAA,UAAA,UAAA,kBAAP,SAAuB,GAAW,GAAW,OAAe,QAAgB,QAAc;AAEtF,WAAO,KAAK,UAAU,IAAI,iBAAiB,GAAG,GAAG,OAAO,QAAQ,MAAM,CAAC;;AAWpE,EAAAA,UAAA,UAAA,aAAP,SAAkB,GAAW,GAAW,QAAc;AAElD,WAAO,KAAK,UAAU,IAAI,OAAO,GAAG,GAAG,MAAM,CAAC;;AAY3C,EAAAA,UAAA,UAAA,cAAP,SAAmB,GAAW,GAAW,OAAe,QAAc;AAElE,WAAO,KAAK,UAAU,IAAI,QAAQ,GAAG,GAAG,OAAO,MAAM,CAAC;;AAYnD,EAAAA,UAAA,UAAA,cAAP,WAAA;;AAAmB,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,WAAA,EAAA,IAAA,YAAA,EAAA;;AAEf,QAAI;AACJ,QAAI,cAAc;AAElB,QAAM,OAAO,KAAK,CAAC;AAGnB,QAAI,KAAK,QACT;AACI,oBAAc,KAAK;AACnB,eAAS,KAAK;eAGd,MAAM,QAAQ,KAAK,CAAC,CAAC,GACzB;AACI,eAAS,KAAK,CAAC;WAGnB;AACI,eAAS;;AAGb,QAAM,QAAQ,IAAI,QAAQ,MAAM;AAEhC,UAAM,cAAc;AAEpB,SAAK,UAAU,KAAK;AAEpB,WAAO;;AASJ,EAAAA,UAAA,UAAA,YAAP,SAAiB,OAAa;AAE1B,QAAI,CAAC,KAAK,WACV;AACI,WAAK,UAAU,UACX,OACA,KAAK,WAAW,MAAK,GACrB,KAAK,WAAW,MAAK,GACrB,KAAK,OAAO;WAIpB;AACI,WAAK,UAAU,SAAS,OAAO,KAAK,OAAO;;AAG/C,WAAO;;AAQJ,EAAAA,UAAA,UAAA,QAAP,WAAA;AAEI,SAAK,UAAU,MAAK;AACpB,SAAK,WAAW,MAAK;AACrB,SAAK,WAAW,MAAK;AAErB,SAAK;AACL,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,cAAc;AAEnB,WAAO;;AASJ,EAAAA,UAAA,UAAA,aAAP,WAAA;AAEI,QAAM,OAAO,KAAK,UAAU;AAE5B,WAAO,KAAK,WAAW,KAChB,KAAK,CAAC,EAAE,MAAM,SAAS,OAAO,QAC9B,CAAC,KAAK,CAAC,EAAE,MAAM,UACf,EAAE,KAAK,CAAC,EAAE,UAAU,WAAW,KAAK,CAAC,EAAE,UAAU;;AAQlD,EAAAA,UAAA,UAAA,UAAV,SAAkB,UAAkB;AAEhC,SAAK,WAAU;AAEf,QAAM,WAAW,KAAK;AACtB,QAAM,YAAY,SAAS,QAAQ,SAAS;AAI5C,aAAS,cAAc,SAAS;AAEhC,QAAI,SAAS,WACb;AACI,UAAI,KAAK,eAAe,SAAS,YACjC;AACI,aAAK,iBAAgB;;AAGzB,WAAK,eAAe,QAAQ;WAGhC;AAEI,eAAS,MAAM,MAAK;AAEpB,WAAK,cAAc,QAAQ;;;AAKzB,EAAAA,UAAA,UAAA,mBAAV,WAAA;AAEI,QAAM,WAAW,KAAK;AACtB,QAAM,YAAY,KAAK;AACvB,QAAM,MAAM,SAAS,QAAQ;AAE7B,SAAK,YAAY;AACjB,SAAK,eAAe;AACpB,SAAK,aAAa,SAAS;AAC3B,SAAK,QAAQ,SAAS;AAEtB,SAAK,aAAa,IAAI,aAAa,SAAS,MAAM;AAElD,aAAS,IAAI,GAAG,IAAI,KAAK,KACzB;AACI,UAAM,KAAK,SAAS,QAAQ,CAAC;AAC7B,UAAM,QAAQ,GAAG,MAAM;AACvB,UAAM,aAAa,IAAI,aAAa,KAAK,WAAW,QAChD,GAAG,cAAc,IAAI,GACrB,GAAG,aAAa,CAAC;AAErB,UAAM,MAAM,IAAI,aAAa,SAAS,WAAW,QAC7C,GAAG,cAAc,IAAI,GACrB,GAAG,aAAa,CAAC;AAErB,UAAM,UAAU,IAAI,YAAY,SAAS,cAAc,QACnD,GAAG,QAAQ,GACX,GAAG,IAAI;AAEX,UAAM,QAAQ;QACV;QACA;QACA;QACA;QACA,WAAW,QAAQ,KAAK;QACxB,UAAU;QACV,UAAU,GAAG,MAAM;QACnB,OAAO,GAAG,MAAM;QAChB,YAAY;;AAEhB,WAAK,QAAQ,CAAC,IAAI;;;AAShB,EAAAA,UAAA,UAAA,iBAAV,SAAyB,UAAkB;AAEvC,QAAI,CAAC,KAAK,QAAQ,QAClB;AACI;;AAGJ,aAAS,MAAM,kBAAkB,SAAS,QAAQ,KAAK,UAAU,CAAC;AAElE,SAAK,kBAAiB;AACtB,SAAK,eAAc;AAEnB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,IAAI,GAAG,KAChD;AACI,UAAM,QAAQ,KAAK,QAAQ,CAAC;AAE5B,YAAM,aAAa,KAAK,aAAa,MAAM;AAE3C,eAAS,QAAQ,KAAK,UAAU,EAAE,OAAO,KAAK;;;AAS5C,EAAAA,UAAA,UAAA,gBAAV,SAAwB,UAAkB;AAEtC,QAAM,SAAS,KAAK,qBAAqB,QAAQ;AAEjD,QAAM,WAAW,KAAK;AACtB,QAAM,OAAO,KAAK;AAClB,QAAM,aAAa,KAAK;AACxB,QAAM,WAAW,OAAO;AACxB,QAAM,YAAY,SAAS;AAG3B,aAAS,oBAAoB,KAAK,UAAU;AAG5C,aAAS,KAAK,CAAC,KAAO,QAAQ,KAAM,OAAQ,MAAO;AACnD,aAAS,KAAK,CAAC,KAAO,QAAQ,IAAK,OAAQ,MAAO;AAClD,aAAS,KAAK,CAAC,KAAM,OAAO,OAAQ,MAAO;AAC3C,aAAS,KAAK,CAAC,IAAI;AAOnB,aAAS,OAAO,KAAK,MAAM;AAC3B,aAAS,SAAS,KAAK,UAAU,MAAM;AAGvC,aAAS,MAAM,IAAI,KAAK,KAAK;AAG7B,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAC7C;AACI,WAAK,sBAAsB,UAAU,SAAS,UAAU,CAAC,CAAC;;;AAUxD,EAAAA,UAAA,UAAA,wBAAV,SAAgC,UAAoB,UAAuB;AAE/D,QAAA,WAAgC,SAAQ,UAA9B,OAAsB,SAAQ,MAAxB,OAAgB,SAAQ,MAAlB,QAAU,SAAQ;AAChD,QAAM,oBAAoB,SAAS;AAEnC,aAAS,IAAI,GAAG,IAAI,mBAAmB,KACvC;AACI,eAAS,QAAQ,KAAK,SAAS,SAAS,CAAC,GAAG,CAAC;;AAGjD,aAAS,SAAS,KAAK,MAAM,MAAM,KAAK;;AAQlC,EAAAA,UAAA,UAAA,uBAAV,SAA+B,UAAkB;AAE7C,QAAI,SAAS,KAAK;AAElB,QAAM,aAAa,KAAK;AAExB,QAAI,CAAC,QACL;AAII,UAAI,CAAC,gBAAgB,UAAU,GAC/B;AACI,YAAM,eAAe,SAAS,QAAQ,MAAM;AAC5C,YAAM,eAAe,IAAI,WAAW,YAAY;AAEhD,iBAAS,IAAI,GAAG,IAAI,cAAc,KAClC;AACI,uBAAa,CAAC,IAAI;;AAGtB,YAAM,WAAW;UACb,MAAM,IAAI,aAAa,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;UACnC,mBAAmB,IAAI,OAAM;UAC7B,SAAS,aAAa,KAAK,EAAE,WAAW,aAAY,GAAI,IAAI;;AAGhE,YAAM,UAAU,SAAS,QAAQ,UAAU,EAAE,QAAQ;AAErD,wBAAgB,UAAU,IAAI,IAAI,OAAO,SAAS,QAAQ;;AAG9D,eAAS,gBAAgB,UAAU;;AAGvC,WAAO;;AAID,EAAAA,UAAA,UAAA,mBAAV,WAAA;AAEI,SAAK,WAAU;AAEf,QAAM,WAAW,KAAK;AAGtB,QAAI,CAAC,SAAS,aAAa,QAC3B;AACI;;AAGE,QAAAC,MAA6B,SAAS,QAApC,OAAIA,IAAA,MAAE,OAAIA,IAAA,MAAE,OAAIA,IAAA,MAAE,OAAIA,IAAA;AAE9B,SAAK,QAAQ,SAAS,KAAK,WAAW,MAAM,MAAM,MAAM,IAAI;;AASzD,EAAAD,UAAA,UAAA,gBAAP,SAAqB,OAAiB;AAElC,SAAK,eAAe,aAAa,OAAOA,UAAS,WAAW;AAE5D,WAAO,KAAK,UAAU,cAAcA,UAAS,WAAW;;AAIlD,EAAAA,UAAA,UAAA,iBAAV,WAAA;AAEI,QAAI,KAAK,cAAc,KAAK,MAC5B;AACI,WAAK,YAAY,KAAK;AAEtB,UAAM,UAAU,QAAQ,KAAK,MAAM,IAAI;AAEvC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KACzC;AACI,YAAM,QAAQ,KAAK,QAAQ,CAAC;AAE5B,YAAM,YAAY,MAAM;AAExB,YAAM,IAAK,QAAQ,CAAC,IAAI,UAAU,CAAC,IAAK;AACxC,YAAM,IAAK,QAAQ,CAAC,IAAI,UAAU,CAAC,IAAK;AACxC,YAAM,IAAK,QAAQ,CAAC,IAAI,UAAU,CAAC,IAAK;AAGxC,YAAM,SAAS,KAAK,OAAO,KAAK,MAAM,IAAI;AAE1C,cAAM,YAAY,SAAS,OAChB,QAAQ,WACP,QAAQ,QAAS;;;;AAS/B,EAAAA,UAAA,UAAA,oBAAV,WAAA;AAEI,QAAM,OAAO,KAAK,UAAU;AAE5B,QAAI,KAAK,iBAAiB,MAC1B;AACI;;AAGJ,SAAK,eAAe;AAEpB,QAAM,KAAK,KAAK,UAAU;AAC1B,QAAM,IAAI,GAAG;AACb,QAAM,IAAI,GAAG;AACb,QAAM,IAAI,GAAG;AACb,QAAM,IAAI,GAAG;AACb,QAAM,KAAK,GAAG;AACd,QAAM,KAAK,GAAG;AAEd,QAAM,OAAO,KAAK,UAAU;AAC5B,QAAM,aAAa,KAAK;AAExB,QAAI,QAAQ;AAEZ,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GACtC;AACI,UAAM,IAAI,KAAK,CAAC;AAChB,UAAM,IAAI,KAAK,IAAI,CAAC;AAEpB,iBAAW,OAAO,IAAK,IAAI,IAAM,IAAI,IAAK;AAC1C,iBAAW,OAAO,IAAK,IAAI,IAAM,IAAI,IAAK;;;AAS3C,EAAAA,UAAA,UAAA,YAAP,WAAA;AAEI,QAAM,cAAc,KAAK;AAEzB,QAAI,aACJ;AAEI,kBAAY,cAAc;AAG1B,WAAK,WAAU;;AAGnB,WAAO;;AASJ,EAAAA,UAAA,UAAA,YAAP,SAAiB,QAAc;AAE3B,SAAK,UAAU;AAEf,WAAO;;AAWJ,EAAAA,UAAA,UAAA,YAAP,WAAA;AAEI,SAAK,WAAU;AACf,SAAK,YAAY;AAEjB,WAAO;;AAOJ,EAAAA,UAAA,UAAA,UAAP,WAAA;AAEI,SAAK,WAAU;AACf,SAAK,YAAY;AAEjB,WAAO;;AAeJ,EAAAA,UAAA,UAAA,UAAP,SAAe,SAAiC;AAE5C,SAAK,UAAU;AACf,QAAI,KAAK,UAAU,aAAa,GAChC;AACI,WAAK,UAAU,QAAO;;AAG1B,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,WAAW,QAAO;AACvB,SAAK,aAAa;AAClB,SAAK,WAAW,QAAO;AACvB,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,aAAa;AAClB,SAAK,QAAQ,SAAS;AACtB,SAAK,UAAU;AAEf,WAAA,UAAM,QAAO,KAAA,MAAC,OAAO;;AA/pClB,EAAAA,UAAA,cAAc,IAAI,MAAK;AAiqClC,SAAAA;EA1qC8B,SAAS;IC3D1B,gBAAgB;EACzB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;;8CC3BJ;AACA,SAAA,SAAA,UAAA,KAAA,IAAA,GAAA,IAAA,OAAA,CAAA,IAAA,OACA,KAAA,IAAA,GAAA,IAAA,OAAA,CAAA,IAAA,OACA,KAAA,IAAA,GAAA,IAAA,OAAA,CAAA,IAAA,OACA,KAAA,IAAA,GAAA,IAAA,OAAA,CAAA,IAAA,OACA,KAAA,IAAA,GAAA,KAAA,OAAA,EAAA,IAAA,OACA,KAAA,IAAA,GAAA,KAAA,OAAA,EAAA,IAAA;AACA;4BAGA;EAMA,cACA;AACA,SAAA,aAAA,CAAA;AACA,SAAA,WAAA,CAAA;AACA,SAAA,QAAA,CAAA;AACA,SAAA,QAAA;EAGA;EAEA,QACA;AACA,aAAA,IAAA,GAAA,IAAA,KAAA,OAAA,KACA;AACA,WAAA,WAAA,CAAA,IAAA;AACA,WAAA,SAAA,CAAA,IAAA;IACA;AACA,SAAA,QAAA;EACA;EAEA,IAAA,WAAA,QACA,WAAA,eACAE,WACA;AACA,UAAA,EAAA,YAAA,UAAA,OAAA,MAAA,IAAA;AAEA,aAAA,IAAA,GAAA,IAAA,OAAA,KACA;AACA,UAAA,MAAA,IAAA,CAAA,MAAA,aAAA,MAAA,IAAA,IAAA,CAAA,MAAA,iBACA,WAAA,CAAA,MAAA,aAAA,aAAA,SAAA,CAAA,GAAA,MAAA,GACA;AACA,eAAA;MACA;IACA;AACA,QAAA,SAAAA,UAAA,WACA;AACA,aAAA;IACA;AACA,eAAA,KAAA,IAAA;AACA,aAAA,KAAA,IAAA;AACA,UAAA,QAAA,CAAA,IAAA;AACA,UAAA,QAAA,IAAA,CAAA,IAAA;AACA,SAAA;AAEA,WAAA;EACA;AACA;2BAGA;EAWA,cACA;AACA,SAAA,WAAA,IAAA,kBAAA;AACA,SAAA,aAAA,IAAA,gBAAA;AACA,SAAA,SAAA;AACA,SAAA,QAAA,YAAA;AAEA,SAAA,QAAA;AACA,SAAA,OAAA;AACA,SAAA,OAAA;AACA,SAAA,WAAA;AAKA,SAAA,OAAA;EACA;EAEA,QACA;AACA,SAAA,SAAA,MAAA;AACA,SAAA,WAAA,MAAA;AACA,SAAA,WAAA;AACA,SAAA,OAAA;AACA,SAAA,SAAA;EACA;EAEA,MAAAA,WAAA,QACA;AACA,SAAA,OAAA,EAAA,YAAA;AACA,SAAA,WAAAA;AACA,SAAA,SAAA;AAEA,SAAA,QAAA;AACA,SAAA,OAAA;AACA,SAAA,OAAA;AACA,QAAA,UAAA,OAAA,UACA;AACA,WAAA,WAAA,OAAA;IACA;EACA;EAEA,MAAA,QACA;AACA,QAAA,KAAA,SAAA,GACA;AACA,WAAA,SAAA;AAEA,aAAA;IACA;AAEA,WAAA,KAAA,WAAA;EACA;EAEA,IAAA,SAAA,QAAA,WAAA,eACA;AACA,UAAA,EAAA,UAAA,MAAA,YAAA,UAAAA,UAAA,IAAA;AACA,UAAA,EAAA,YAAA,IAAA;AAGA,QAAA,YAAA,kBAAA,QAAA,SAAA,UAAAA,UAAA,aACA;AACA,aAAA;IACA;AACA,UAAA,MAAA,YAAA,kBAAA,OAAA,SAAA,QAAA,YAAA;AAGA,UAAA,MAAA,WAAA,IAAA,KAAA,UAAA,OAAA,UAAA,WAAA,eAAAA,SAAA;AAEA,QAAA,OAAA,GACA;AAGA,UAAA,YAAA,kBAAA,MACA;AACA,oBAAA,gBAAA;AACA,oBAAA,iBAAA,SAAA;AACA,iBAAA,SAAA,SAAA,OAAA,IAAA;MACA;IACA;AAEA,WAAA;EACA;AACA;uBCrKA;EAUA,cACA;AACA,SAAA,MAAA;EACA;EAEA,MAAA,OAAA,YAAA,aACA;AACA,SAAA,MAAA;AACA,SAAA,QAAA;AACA,SAAA,QAAA;AACA,SAAA,cAAA;AACA,SAAA,WAAA;EACA;EAEA,IAAA,UAAA,WACA;AACA,SAAA,aAAA,YAAA,KAAA;AACA,SAAA,OAAA,WAAA,KAAA;EACA;EAEA,QACA;AACA,SAAA,QAAA;AACA,SAAA,OAAA;AACA,SAAA,QAAA;AACA,SAAA,cAAA;AACA,SAAA,aAAA;AACA,SAAA,UAAA;AACA,SAAA,OAAA;AACA,SAAA,WAAA;EACA;AACA;uBCzCA;EACA,cACA;AACA,SAAA,MAAA;EACA;EAWA,SACA;AACA,WAAA,KAAA,OAAA,CAAA,CAAA;EACA;EAEA,QACA;AACA,WAAA,KAAA,OAAA,IAAAC,WAAA,CAAA;EACA;EAEA,OAAA,KACA;AACA,QAAA,QAAA,KAAA;AACA,QAAA,QAAA,KAAA;AACA,QAAA,UAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,UAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,YAAA;AAEA,WAAA;EACA;;;;EAKA,gBACA;AACA,WAAA;EACA;EAEA,QACA;AACA,SAAA,QAAA;AAEA,SAAA,QAAA;AAEA,SAAA,UAAA,QAAA;AAEA,SAAA,SAAA;AAEA,SAAA,SAAA;AAEA,SAAA,UAAA;AAEA,SAAA,SAAA;AAEA,SAAA,YAAA;EACA;EAEA,UACA;AACA,SAAA,UAAA;AACA,SAAA,SAAA;AACA,SAAA,YAAA;EACA;EAEA,mBACA;AACA,UAAA,MAAA,KAAA;AAEA,QAAA,CAAA,KAAA,QACA;AACA,aAAA;IACA;AAEA,QAAA,IAAA,MAAA,UAAA,IAAA,YAAA,SACA,IAAA,MAAA,WAAA,IAAA,YAAA,QACA;AACA,aAAA,KAAA;IACA;AAEA,QAAA,CAAA,KAAA,WACA;AACA,WAAA,YAAA,KAAA,OAAA,MAAA;IACA,OAEA;AACA,WAAA,UAAA,SAAA,KAAA,MAAA;IACA;AACA,SAAA,UAAA,UAAA,OAAA,IAAA,MAAA,CAAA,GAAA,OAAA,IAAA,MAAA,CAAA,CAAA;AAEA,WAAA,KAAA;EACA;AACA;;;ACpGA,QAAA,OAAA;AAAA,EAAAC,iBAAA,MAAA,IAAA;AACA,QAAA,SAAA;AAAA,EAAAA,iBAAA,QAAA,IAAA;AACA,GAAA,oBAAA,kBAAA,CAAA,EAAA;0CAGA;EASA,QACA;AACA,WAAA,KAAA,OAAA,IAAAC,WAAA,CAAA;EACA;;EAGA,OAAA,KACA;AACA,QAAA,QAAA,KAAA;AACA,QAAA,QAAA,KAAA;AACA,QAAA,UAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,UAAA,KAAA;AACA,QAAA,QAAA,KAAA;AACA,QAAA,YAAA,KAAA;AACA,QAAA,MAAA,KAAA;AACA,QAAA,OAAA,KAAA;AACA,QAAA,aAAA,KAAA;AACA,QAAA,YAAA,KAAA;AAEA,WAAA;EACA;;;;EAKA,gBACA;AACA,WAAA,KAAA,cAAA,gBAAA,SAAA,KAAA,QAAA,CAAA,KAAA;EACA;EAEA,QACA;AACA,UAAA,MAAA;AAEA,SAAA,SAAA;AAEA,SAAA,QAAA;AAEA,SAAA,QAAA;AAEA,SAAA,YAAA;AAEA,SAAA,MAAA,SAAA;AACA,SAAA,OAAA,UAAA;AACA,SAAA,aAAA;AACA,SAAA,YAAA,gBAAA;EACA;AACA;sBClEA;EAAA,cAAA;AAAA,cAAA,UAAA,OAAA,KAAA,IAAA;AAAA,cAAA,UAAA,QAAA,KAAA,IAAA;AAAA,cAAA,UAAA,QAAA,KAAA,IAAA;AAAA,cAAA,UAAA,QAAA,KAAA,IAAA;AAAA,cAAA,UAAA,QAAA,KAAA,IAAA;EAAA;EACA,SAAA;AAAA,SAAA,QAAA,CAAA;EAAA;EACA,UAAA;AAAA,SAAA,SAAA,CAAA;EAAA;EACA,UAAA;AAAA,SAAA,aAAA;EAAA;EACA,UAAA;AAAA,SAAA,YAAA;EAAA;EACA,UAAA;AAAA,SAAA,gBAAA;EAAA;EAEA,QACA;AACA,SAAA,MAAA,SAAA;AACA,SAAA,OAAA,SAAA;AACA,SAAA,aAAA;AACA,SAAA,YAAA;EACA;EAEA,UACA;AACA,SAAA,MAAA,SAAA;AACA,SAAA,OAAA,SAAA;EACA;AACA;;;ACpBA,QAAA,OAAA;AAAA,EAAAC,YAAAA,YAAA,MAAA,IAAA,IAAA,IAAA;AACA,QAAA,OAAA;AAAA,EAAAA,YAAAA,YAAA,MAAA,IAAA,IAAA,IAAA;AACA,QAAA,cAAA;AAAA,EAAAA,YAAAA,YAAA,aAAA,IAAA,WAAA,IAAA;AACA,QAAA,cAAA;AAAA,EAAAA,YAAAA,YAAA,aAAA,IAAA,WAAA,IAAA;AACA,QAAA,cAAA;AAAA,EAAAA,YAAAA,YAAA,aAAA,IAAA,WAAA,IAAA;AACA,QAAA,iBAAA;AAAA,EAAAA,YAAAA,YAAA,gBAAA,IAAA,cAAA,IAAA;AACA,QAAA,mBAAA;AAAA,EAAAA,YAAAA,YAAA,kBAAA,IAAA,gBAAA,IAAA;AACA,QAAA,kBAAA;AAAA,EAAAA,YAAAA,YAAA,iBAAA,IAAA,eAAA,IAAA;AACA,QAAA,cAAA;AAAA,EAAAA,YAAAA,YAAA,aAAA,IAAA,WAAA,IAAA;AACA,QAAA,WAAA,KAAA;AAAA,EAAAA,YAAAA,YAAA,UAAA,IAAA,QAAA,IAAA;AACA,QAAA,aAAA,KAAA;AAAA,EAAAA,YAAAA,YAAA,YAAA,IAAA,UAAA,IAAA;AACA,QAAA,YAAA,KAAA;AAAA,EAAAA,YAAAA,YAAA,WAAA,IAAA,SAAA,IAAA;AACA,QAAA,YAAA,KAAA;AAAA,EAAAA,YAAAA,YAAA,WAAA,IAAA,SAAA,IAAA;AACA,GAAA,eAAA,aAAA,CAAA,EAAA;0BCVA;EAAA,cAAA;AAAA,kBAAA,UAAA,OAAA,KAAA,IAAA;AAAA,kBAAA,UAAA,QAAA,KAAA,IAAA;AAAA,kBAAA,UAAA,QAAA,KAAA,IAAA;EAAA;EACA,OAAA,eAAA;AAAA,SAAA,eAAA,CAAA;EAAA;EAEA,SAAA;AAAA,SAAA,eAAA;EAAA;EAEA,iBAAA,YAAA,UAAA,WAAA,QACA;AACA,UAAA,EAAA,OAAA,IAAA;AACA,QAAA,gBAAA;AAEA,QAAA,aAAA;AACA,QAAA,YAAA;AAEA,aAAA,IAAA,YAAA,IAAA,aAAA,UAAA,KACA;AACA,YAAA,UAAA,OAAA,CAAA,IAAA,CAAA;AACA,YAAA,QAAA,OAAA,CAAA,IAAA;AAEA,UAAA,UAAA,WAAA,MACA;AACA,wBAAA;AACA;AACA;MACA;AAEA,UAAA,SAAA,WAAA,aACA;AACA,sBAAA;AACA,qBAAA;AACA;MACA;AAEA,YAAA,KAAA,cAAA,aAAA,KAAA,IAAA,cAAA,aAAA,OAAA;AAEA,UAAA,MAAA,GACA;AACA,sBAAA;AACA,qBAAA,IAAA,IAAA,KAAA,IAAA,KAAA,GAAA,CAAA;MACA;IACA;AACA,QAAA,eACA;AACA,mBAAA;IACA;AAEA,WAAA,cAAA;AACA,WAAA,aAAA;EACA;EAEA,UAAA;AAAA,SAAA,YAAA;EAAA;EACA,UAAA;AAAA,SAAA,WAAA;EAAA;EAMA,UAAA,WAAA,UAAA,SAAA,SAAA,YAAA,GAAA,WAAA,GACA;AACA,SAAA,YAAA;AACA,SAAA,WAAA;AACA,SAAA,UAAA;AACA,SAAA,UAAA;AACA,SAAA,YAAA;AACA,SAAA,WAAA;EACA;EAEA,UACA;AACA,SAAA,YAAA;AACA,SAAA,WAAA;AACA,SAAA,UAAA;AACA,SAAA,UAAA;EACA;EAEA,wBAAA,YAAA,UAAA,WACA,WAAA,OACA;AACA,UAAA,EAAA,UAAA,SAAA,SAAA,WAAA,aAAA,IAAA;AACA,UAAA,EAAA,QAAA,OAAAC,OAAA,IAAA;AAEA,QAAA,SAAA,KAAA;AACA,QAAA,SAAA,KAAA;AACA,QAAA,QAAA,KAAA,YAAA,KAAA;AAGA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QAAA;AAAA,QACA;AAEA,QAAA,cAAA;AAEA,QAAA,SAAA;AAEA,aAAA,IAAA,YAAA,IAAA,aAAA,UAAA,KACA;AACA,YAAA,YAAA,OAAA,CAAA;AACA,YAAA,UAAA,OAAA,CAAA,IAAA,CAAA;AACA,YAAA,QAAA,OAAA,CAAA,IAAA;AAEA,UAAA,UAAA,WAAA,MACA;AAEA,sBAAA;AACA,aAAAA,OAAA,IAAA,CAAA;AACA,aAAAA,OAAA,IAAA,IAAA,CAAA;AACA,iBAAA,MAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA,KAAA;AACA,iBAAA,SAAA,EAAA,IAAA;AACA,gBAAA,SAAA,EAAA,IAAA;AACA,kBAAA;AACA;MACA;AAEA,UAAA,SAAA,WAAA,aACA;AACA,gBAAAA,OAAA,IAAA,CAAA;AACA,gBAAAA,OAAA,IAAA,IAAA,CAAA;AACA,aAAAA,OAAA,IAAA,IAAA,CAAA;AACA,aAAAA,OAAA,IAAA,IAAA,CAAA;AACA,aAAAA,OAAA,IAAA,IAAA,CAAA;AACA,aAAAA,OAAA,IAAA,IAAA,CAAA;AAEA,cAAA,MAAA,IAAA;AAEA,iBAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,mBAAA,MAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAAA,QAAA,MAAA,KAAA,CAAA;AACA,mBAAA,SAAA,CAAA,IAAAA,QAAA,MAAA,KAAA,IAAA,CAAA;AAEA,mBAAA,SAAA,CAAA,IAAA;AACA,mBAAA,SAAA,CAAA,IAAA,KAAA,YAAA;AACA,mBAAA,SAAA,EAAA,IAAA;AACA,kBAAA,SAAA,EAAA,IAAA;AACA,oBAAA;QACA;AAEA,gBAAA,MAAA,IAAA;AACA,gBAAA,SAAA,CAAA,IAAA,QAAA;AACA,gBAAA,SAAA,CAAA,IAAA,QAAA;AACA,kBAAA;AACA,iBAAA;AACA;MACA;AAEA,YAAA,KAAA,cAAA,aAAA,KAAA,IAAA,cAAA,aAAA,OAAA;AAEA,UAAA,OAAA,GACA;AACA;MACA;AACA,WAAAA,OAAA,IAAA,CAAA;AACA,WAAAA,OAAA,IAAA,IAAA,CAAA;AACA,WAAAA,OAAA,IAAA,IAAA,CAAA;AACA,WAAAA,OAAA,IAAA,IAAA,CAAA;AAEA,cAAAA,OAAA,IAAA,IAAA,CAAA;AACA,cAAAA,OAAA,IAAA,IAAA,CAAA;AAEA,YAAA,OAAA,KAAA,MAAA,KAAA,OAAA,KAAA,OAAA,KAAA,OAAA,KAAA,GAAA;AAEA,UAAA,cAAA,aAAA,KAAA,MAAA,GACA;AACA,kBAAA;MACA;AAEA,WAAA,QAAA,CAAA,OAAA,WAAA,gBACA;AACA,gBAAAA,OAAA,IAAA,IAAA,CAAA;AACA,gBAAAA,OAAA,IAAA,IAAA,CAAA;MACA,OAEA;AACA,gBAAA;AACA,gBAAA;MACA;AAGA,eAAA,IAAA,GAAA,IAAA,IAAA,KACA;AACA,iBAAA,MAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA;AACA,iBAAA,SAAA,CAAA,IAAA,KAAA,YAAA;AACA,iBAAA,SAAA,EAAA,IAAA;AACA,gBAAA,SAAA,EAAA,IAAA;AACA,kBAAA;MACA;AAEA,gBAAA;AAEA,cAAA,MAAA,IAAA;AACA,cAAA,SAAA,CAAA,IAAA,QAAA;AACA,cAAA,SAAA,CAAA,IAAA,QAAA;AACA,cAAA,SAAA,CAAA,IAAA;AACA,cAAA,SAAA,CAAA,IAAA,QAAA;AACA,cAAA,SAAA,CAAA,IAAA,QAAA;AACA,gBAAA;AACA,eAAAC,KAAA,GAAAA,KAAA,IAAA,IAAAA,MACA;AACA,gBAAA,MAAA,IAAA,QAAA;AACA,gBAAA,SAAA,CAAA,IAAA,QAAAA;AACA,gBAAA,SAAA,CAAA,IAAA,QAAAA,KAAA;AACA,kBAAA;MACA;AACA,eAAA;IACA;AAEA,QAAA,aACA;AACA,eAAA,IAAA,GAAA,IAAA,UAAA,QAAA,KACA;AACA,gBAAA,SAAA,CAAA,IAAA,UAAA,CAAA,IAAA;MACA;AACA,gBAAA,UAAA;IACA;AAEA,SAAA,YAAA;AACA,SAAA,WAAA;EACA;AACA;AAAA,cAAA,aAAA;AAEA,IAAA,QAAA,cAAA;AAEA,SAAA,IAAA,GAAA,IAAA,KAAA,KACA;AAAA,QAAA,KAAA,CAAA;AAAA;AAEA,MAAA,WAAA,IAAA,IAAA;AAEA,SAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,QAAA,WAAA,cAAA,CAAA,IAAA;AACA;AAGA,MAAA,WAAA,WAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,WAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,WAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA;AACA,MAAA,WAAA,cAAA,CAAA,IAAA;AACA,MAAA,WAAA,cAAA,IAAA;AACA,MAAA,WAAA,iBAAA,CAAA,IAAA;AACA,MAAA,WAAA,gBAAA,IAAA;AACA,MAAA,WAAA,mBAAA,CAAA,IAAA;AACA,MAAA,WAAA,eAAA,IAAA,IAAA;AACA,MAAA,WAAA,kBAAA,CAAA,IAAA,IAAA;AAEA,MAAA,WAAA,SAAA,IAAA;+BCvQA;;;EAoBA,YAAA,OAAA,YAAA,MAAA,YAAA,MAAA,SAAA,MACA;AACA,SAAA,QAAA;AAEA,SAAA,YAAA;AAEA,SAAA,YAAA;AAEA,SAAA,SAAA;AAEA,SAAA,OAAA,MAAA;AAEA,SAAA,SAAA,CAAA;AAEA,SAAA,QAAA,CAAA;AAEA,SAAA,YAAA,CAAA;AAEA,SAAA,cAAA;AAEA,SAAA,WAAA;EACA;EAEA,YACA;AACA,SAAA,OAAA,SAAA;AACA,SAAA,cAAA;EACA;EAEA,aACA;AACA,SAAA,UAAA,SAAA;AACA,SAAA,YAAA;AACA,SAAA,UAAA;AACA,SAAA,cAAA;AACA,SAAA,YAAA;AACA,SAAA,SAAA;EACA;EAEA,QACA;AACA,WAAA,IAAA;MACA,KAAA;MACA,KAAA;MACA,KAAA;MACA,KAAA;IACA;EACA;EAEA,UACA;AACA,QAAA;AAEA,YAAA,KAAA,UAAA,KACA;MACA,KAAA,SAAA;AACA,cAAA,WAAA;AACA;MACA,KAAA,SAAA;AACA,cAAA,WAAA;AACA;MACA;AACA,cAAA,WAAA;AACA;IACA;AAEA,WAAA;EACA;EAEA,gBAAA;AACA,QAAA;AAEA,YAAA,KAAA,UAAA,MACA;MACA,KAAA,UAAA;AACA,gBAAA,WAAA;AACA;MACA,KAAA,UAAA;AACA,gBAAA,WAAA;AACA;MACA;AACA,gBAAA,WAAA,cAAA;AACA;IACA;AAEA,WAAA;EACA;EAEA,YACA;AACA,QAAA;AAEA,YAAA,KAAA,UAAA,MACA;MACA,KAAA,UAAA;AACA,gBAAA,WAAA;AACA;MACA,KAAA,UAAA;AACA,gBAAA,WAAA;AACA;MACA;AACA,gBAAA,WAAA;AACA;IACA;AAEA,WAAA;EACA;EAEA,UACA;AACA,SAAA,QAAA;AACA,SAAA,MAAA,SAAA;AACA,SAAA,QAAA;AACA,SAAA,OAAA,SAAA;AACA,SAAA,SAAA;AACA,SAAA,YAAA;AACA,SAAA,YAAA;AACA,SAAA,YAAA;EACA;AACA;0BC9IA;EACA,KAAA,cAAA,SACA;AAEA,UAAA,aAAA,aAAA;AACA,UAAA,SAAA,aAAA;AACA,UAAA,IAAA,WAAA;AACA,UAAA,IAAA,WAAA;AACA,QAAA;AACA,QAAA;AAGA,QAAA,aAAA,SAAA,OAAA,MACA;AACA,cAAA,WAAA;AACA,eAAA,WAAA;IACA,OAEA;AACA,YAAA,cAAA,aAAA;AAEA,cAAA,YAAA;AACA,eAAA,YAAA;IACA;AAEA,QAAA,SAAA,KAAA,UAAA,GACA;AACA;IACA;AAEA,WAAA,KAAA,GAAA,CAAA;AAEA,QAAA,YAAA,KAAA,MAAA,KAAA,KAAA,KAAA,WAAA,MAAA,CAAA,KACA,KAAA,MAAA,KAAA,KAAA,KAAA,QAAA,MAAA,CAAA;AAEA,iBAAA;AACA,QAAA,YAAA,GACA;AACA,kBAAA;IACA;AAEA,UAAA,MAAA,KAAA,KAAA,IAAA;AAEA,aAAA,IAAA,GAAA,IAAA,YAAA,KAAA,KACA;AACA,aAAA;QACA,IAAA,KAAA,IAAA,CAAA,MAAA,CAAA,IAAA;QACA,IAAA,KAAA,IAAA,CAAA,MAAA,CAAA,IAAA;MACA;IACA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAD,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,QAAA,UAAA,IAAA;AAEA,QAAA,UAAA;AACA,UAAA,SAAA;AAEA,QAAA,CAAA,aAAA,QACA;AACA,eAAA,IAAA,GAAA,IAAA,OAAA,QAAA,KAAA,GACA;AACA,QAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,IAAA,CAAA,CAAA;AACA,eAAA,KAAA,WAAA,IAAA;AACA,YAAA,IAAA,GACA;AACA,oBAAA,KAAA,WAAA,QAAA,OAAA;QACA;MACA;AACA,gBAAA,KAAA,SAAA,QAAA,CAAA;AAEA;IACA;AAEA,UAAA,KAAA,OAAA,CAAA;AAAA,UACA,KAAA,OAAA,CAAA;AACA,UAAA,MAAA,aAAA,MAAA;AAEA,aAAA,IAAA,GAAA,IAAA,OAAA,QAAA,KAAA,GACA;AAEA,YAAA,MAAA;AACA,YAAA,OAAA,IAAA,IAAA,OAAA,SAAA,IAAA,IAAA;AAEA,MAAAA,OAAA,KAAA,EAAA;AACA,MAAAA,OAAA,KAAA,EAAA;AACA,MAAAA,OAAA,KAAA,OAAA,GAAA,CAAA;AACA,MAAAA,OAAA,KAAA,OAAA,MAAA,CAAA,CAAA;AACA,MAAAA,OAAA,KAAA,OAAA,IAAA,CAAA;AACA,MAAAA,OAAA,KAAA,OAAA,OAAA,CAAA,CAAA;AAEA,MAAAA,OAAA,KAAA,CAAA;AACA,MAAAA,OAAA,KAAA,CAAA;AACA,MAAAA,OAAA,MAAA,OAAA,GAAA,IAAA,MAAA,GAAA;AACA,MAAAA,OAAA,MAAA,OAAA,MAAA,CAAA,IAAA,MAAA,GAAA;AACA,MAAAA,OAAA,MAAA,OAAA,IAAA,IAAA,MAAA,GAAA;AACA,MAAAA,OAAA,MAAA,OAAA,OAAA,CAAA,IAAA,MAAA,GAAA;AAEA,aAAA,KAAA,WAAA,cAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,OAAA,IAAA;AACA,UAAA,QAAA,aAAA,cAAA;AACA,UAAA,MAAA,OAAA;AAEA,IAAAA,OAAA,KAAA,OAAA,MAAA,CAAA,GAAA,OAAA,MAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,aAAA,IAAA,GAAA,IAAA,KAAA,KAAA,GACA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,IAAA,CAAA,CAAA;AACA,aAAA,KAAA,KAAA;IACA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;EACA;AACA;6BCnIA;EACA,KAAA,cAAA,SACA;AAIA,UAAA,WAAA,aAAA;AACA,UAAA,IAAA,SAAA;AACA,UAAA,IAAA,SAAA;AACA,UAAA,QAAA,SAAA;AACA,UAAA,SAAA,SAAA;AACA,UAAA,SAAA,aAAA;AAEA,WAAA,SAAA;AAEA,WAAA;MAAA;MAAA;MACA,IAAA;MAAA;MACA,IAAA;MAAA,IAAA;MACA;MAAA,IAAA;IAAA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,OAAA,IAAA;AAEA,UAAA,QAAA,aAAA,cAAA;AACA,UAAA,MAAA,OAAA;AAEA,IAAAA,OAAA,KAAA,OAAA,MAAA,CAAA,GAAA,OAAA,MAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,aAAA,IAAA,GAAA,IAAA,KAAA,KAAA,GACA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,IAAA,CAAA,CAAA;AACA,aAAA,KAAA,KAAA;IACA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,QAAA,UAAA,IAAA;AAEA,cAAA,SAAA;AAEA,IAAAA,OAAA;MAAA,OAAA,CAAA;MAAA,OAAA,CAAA;MACA,OAAA,CAAA;MAAA,OAAA,CAAA;MACA,OAAA,CAAA;MAAA,OAAA,CAAA;MACA,OAAA,CAAA;MAAA,OAAA,CAAA;IAAA;AAEA,WAAA,KAAA,WAAA,MAAA,WAAA,MAAA,WAAA,MAAA,WAAA,IAAA;AACA,cAAA,KAAA,GAAA,GAAA,GAAA,GAAA,GAAA,CAAA;EACA;AACA;ACzDA,SAAAE,OAAA,IAAA,IAAA,MACA;AACA,QAAA,OAAA,KAAA;AAEA,SAAA,KAAA,OAAA;AACA;AAEA,SAAAC,sBACA,OAAA,OACA,KAAA,KACA,KAAA,KACA,MAAA,CAAA,GACA;AACA,QAAA,IAAA;AACA,QAAA,SAAA;AAEA,MAAA,KAAA;AACA,MAAA,KAAA;AACA,MAAA,KAAA;AACA,MAAA,KAAA;AACA,MAAA,IAAA;AACA,MAAA,IAAA;AAEA,WAAA,IAAA,GAAA,IAAA,GAAA,KAAA,GAAA,EAAA,GACA;AACA,QAAA,IAAA;AAGA,SAAAD,OAAA,OAAA,KAAA,CAAA;AACA,SAAAA,OAAA,OAAA,KAAA,CAAA;AACA,SAAAA,OAAA,KAAA,KAAA,CAAA;AACA,SAAAA,OAAA,KAAA,KAAA,CAAA;AAGA,QAAAA,OAAA,IAAA,IAAA,CAAA;AACA,QAAAA,OAAA,IAAA,IAAA,CAAA;AAEA,WAAA,KAAA,GAAA,CAAA;EACA;AAEA,SAAA;AACA;oCAGA;EACA,KAAA,cAAA,SACA;AACA,UAAA,YAAA,aAAA;AACA,UAAA,EAAA,OAAA,IAAA;AACA,UAAA,IAAA,UAAA;AACA,UAAA,IAAA,UAAA;AACA,UAAA,QAAA,UAAA;AACA,UAAA,SAAA,UAAA;AAGA,UAAA,SAAA,KAAA,IAAA,GAAA,KAAA,IAAA,UAAA,QAAA,KAAA,IAAA,OAAA,MAAA,IAAA,CAAA,CAAA;AAEA,WAAA,SAAA;AAGA,QAAA,CAAA,QACA;AACA,aAAA;QAAA;QAAA;QACA,IAAA;QAAA;QACA,IAAA;QAAA,IAAA;QACA;QAAA,IAAA;MAAA;IACA,OAEA;AACA,MAAAC;QAAA;QAAA,IAAA;QACA;QAAA;QACA,IAAA;QAAA;QACA;MAAA;AACA,MAAAA;QAAA,IAAA,QAAA;QACA;QAAA,IAAA;QAAA;QACA,IAAA;QAAA,IAAA;QACA;MAAA;AACA,MAAAA;QAAA,IAAA;QAAA,IAAA,SAAA;QACA,IAAA;QAAA,IAAA;QACA,IAAA,QAAA;QAAA,IAAA;QACA;MAAA;AACA,MAAAA;QAAA,IAAA;QAAA,IAAA;QACA;QAAA,IAAA;QACA;QAAA,IAAA,SAAA;QACA;MAAA;IACA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAH,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,OAAA,IAAA;AAGA,UAAA,QAAA,OAAA,WAAA,IACA,aAAA,cAAA,IAAA,WAAA,cAAA;AACA,UAAA,MAAA,OAAA;AAEA,IAAAA,OAAA,KAAA,OAAA,MAAA,CAAA,GAAA,OAAA,MAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,aAAA,IAAA,GAAA,IAAA,KAAA,KAAA,GACA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,IAAA,CAAA,CAAA;AACA,aAAA,KAAA,KAAA;IACA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;AACA,IAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,WAAA,KAAA,WAAA,IAAA;EACA;EAEA,KAAA,cAAA,QACA;AACA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AACA,UAAA,EAAA,OAAA,IAAA;AAEA,iBAAA,gBAAA,uBAAA,QAAA,MAAA,CAAA;AAEA,aAAA,IAAA,GAAA,IAAA,OAAA,QAAA,IAAA,GAAA,KACA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,EAAA,CAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA;EACA;AACA;AC5HA,IAAA,UAAA,CAAA;wBAGA;EACA,KAAA,cAAA,WACA;AACA,UAAA,QAAA,aAAA;AACA,UAAA,SAAA,aAAA,SAAA,MAAA,OAAA,MAAA;AACA,UAAA,MAAA,UAAA;AACA,UAAA,OAAA,MAAA;AAEA,QAAA,OAAA,WAAA,GACA;AACA;IACA;AAEA,UAAA,aAAA,IAAA,MAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,UAAA,YAAA,IAAA,MAAA,OAAA,OAAA,SAAA,CAAA,GAAA,OAAA,OAAA,SAAA,CAAA,CAAA;AACA,UAAA,cAAA,aAAA,cAAA,MAAA;AAEA,QAAA,MAAA,OAAA;AACA,QAAA,SAAA;AAGA,aAAA,IAAA,GAAA,IAAA,KAAA,KAAA,GACA;AACA,YAAA,KAAA,OAAA,IAAA,CAAA;AAAA,YAAA,KAAA,OAAA,IAAA,CAAA;AAAA,YAAA,KAAA,OAAA,CAAA;AAAA,YACA,KAAA,OAAA,IAAA,CAAA;AACA,UAAA,OAAA;AAEA,UAAA,KAAA,IAAA,KAAA,EAAA,IAAA,OACA,KAAA,IAAA,KAAA,EAAA,IAAA,KACA;AACA,eAAA;MACA;AAEA,UAAA,MACA;AACA,eAAA,MAAA,IAAA,OAAA,CAAA;AACA,eAAA,SAAA,CAAA,IAAA,OAAA,IAAA,CAAA;AACA,kBAAA;MACA;IACA;AACA,WAAA,SAAA,MAAA;AAEA,aAAA;AAEA,aAAA,IAAA,GAAA,IAAA,IAAA,KAAA,KAAA,GACA;AACA,UAAA,KAAA,OAAA,IAAA,CAAA;AAAA,UAAA,KAAA,OAAA,IAAA,CAAA;AAAA,YAAA,KAAA,OAAA,CAAA;AAAA,YAAA,KAAA,OAAA,IAAA,CAAA;AACA,UAAA,KAAA,OAAA,IAAA,CAAA;AAAA,UACA,KAAA,OAAA,IAAA,CAAA;AAEA,YAAA;AACA,YAAA;AACA,YAAA;AACA,YAAA;AACA,UAAA,OAAA;AAEA,UAAA,KAAA,IAAA,KAAA,KAAA,KAAA,EAAA,IAAA,MACA;AACA,YAAA,KAAA,KAAA,KAAA,KAAA,CAAA,MACA;AACA,iBAAA;QACA;MACA;AAEA,UAAA,MACA;AACA,eAAA,MAAA,IAAA,OAAA,CAAA;AACA,eAAA,SAAA,CAAA,IAAA,OAAA,IAAA,CAAA;AACA,kBAAA;MACA;IACA;AACA,WAAA,MAAA,IAAA,OAAA,MAAA,CAAA;AACA,WAAA,SAAA,CAAA,IAAA,OAAA,MAAA,CAAA;AACA,cAAA;AAEA,WAAA,SAAA,MAAA;AAEA,QAAA,OAAA,GACA;AAEA;IACA;AAEA,QAAA,aACA;AAEA,YAAA,aAAA,KAAA,IAAA,WAAA,IAAA,UAAA,CAAA,IAAA,OACA,KAAA,IAAA,WAAA,IAAA,UAAA,CAAA,IAAA;AAEA,UAAA,YACA;AACA,eAAA,IAAA;AACA,eAAA,IAAA;MACA;IACA;EACA;EAEA,KAAA,cAAA,WACA;AACA,UAAA,EAAA,aAAA,OAAA,IAAA;AACA,UAAA,MAAA,UAAA;AAEA,UAAA,MAAA,OAAA;AAGA,QAAA,OAAA,GACA;AACA;IACA;AACA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AAIA,UAAA,QAAA,aAAA,UAAA;AACA,UAAA,MAAA,aAAA,QAAA;AACA,QAAA,UAAA;AAEA,QAAA;AAAA,QACA;AAEA,QAAA,aACA;AACA,cAAA,OAAA,MAAA,CAAA;AACA,cAAA,OAAA,MAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA,OAEA;AACA,cAAA,OAAA,CAAA;AACA,cAAA,OAAA,CAAA;AACA,UAAA,QAAA,WAAA,WACA;AACA,QAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,eAAA,KAAA,WAAA,IAAA;AACA,eAAA,KAAA,WAAA,SAAA;AACA,kBAAA;MACA,OAEA;AACA,kBAAA;AACA,eAAA,KAAA,WAAA,IAAA;MACA;IACA;AACA,IAAAA,OAAA,KAAA,OAAA,KAAA;AAGA,aAAA,IAAA,GAAA,IAAA,KAAA,KAAA,GACA;AACA,YAAA,KAAA,OAAA,CAAA;AAAA,YACA,KAAA,OAAA,IAAA,CAAA;AAEA,UAAA;AAAA,UACA;AAEA,UAAA,IAAA,IAAA,KACA;AACA,aAAA,OAAA,IAAA,CAAA;AACA,aAAA,OAAA,IAAA,CAAA;MACA,OAEA;AACA,aAAA,OAAA,CAAA;AACA,aAAA,OAAA,CAAA;MACA;AAEA,YAAA,KAAA,KAAA;AACA,YAAA,KAAA,KAAA;AACA,UAAA;AAAA,UACA;AAEA,UAAA,WAAA;AAEA,UAAA,IAAA,KAAA,KACA;AACA,gBAAA,OAAA,CAAA;AACA,gBAAA,OAAA,CAAA;AACA,YAAA,CAAA,aACA;AACA,qBAAA,WAAA;QACA;MACA,WACA,IAAA,KAAA,KACA;AACA,gBAAA,OAAA,CAAA;AACA,gBAAA,OAAA,CAAA;AACA,YAAA,CAAA,aACA;AACA,cAAA,QAAA,WAAA,WACA;AACA,uBAAA,WAAA;UACA;AACA,cAAA,QAAA,WAAA,UACA;AACA,uBAAA,WAAA;UACA;AACA,cAAA,QAAA,WAAA,YACA;AACA,uBAAA,WAAA;UACA;QACA;MACA,OAEA;AACA,gBAAA,OAAA,IAAA,CAAA;AACA,gBAAA,OAAA,IAAA,CAAA;MACA;AAEA,YAAA,MAAA,KAAA;AACA,YAAA,MAAA,KAAA;AAEA,UAAA,SAAA,WAAA,eAAA,SAAA,WAAA,aACA;AACA,cAAA,MAAA,QAAA;AACA,cAAA,MAAA,QAAA;AAEA,YAAA,YAAA,WAAA,eACA,YAAA,WAAA,cAAA,GACA;AACA,gBAAA,IAAA,MAAA,KAAA,MAAA;AAEA,cAAA,KAAA,IAAA,CAAA,IAAA,KACA;AACA,oBAAA,QAAA,CAAA,GACA;cACA,KAAA,WAAA;AACA,2BAAA,WAAA;AACA;cACA;AACA,2BAAA,WAAA;AACA;YACA;UACA;QACA;AAEA,YAAA,UAAA,WAAA,aACA;AACA,cAAA,WAAA;AAEA,cAAA,MAAA,KAAA,MAAA,KAAA,CAAA,KACA;AACA;UACA;AACA,cAAA,aAAA,WAAA,eAAA,MAAA,KAAA,MAAA,KAAA,CAAA,KACA;AACA,wBAAA;UACA;AACA,sBAAA;QACA;MACA;AACA,UAAA,YAAA,GACA;AACA,YAAA,KAAA,IAAA,MAAA,KAAA,MAAA,EAAA,IAAA,KACA;AACA,oBAAA,WAAA;QACA;MACA;AACA,kBAAA;AACA,gBAAA;AAEA,MAAAA,OAAA,KAAA,IAAA,EAAA;AACA,aAAA,KAAA,QAAA;AAEA,cAAA;AACA,cAAA;IACA;AAEA,QAAA,aACA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,MAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,CAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA,OAEA;AACA,MAAAA,OAAA,KAAA,OAAA,MAAA,CAAA,GAAA,OAAA,MAAA,CAAA,CAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA;EACA;EAEA,KAAA,cAAA,WACA;AACA,QAAA,SAAA,aAAA;AAEA,UAAA,QAAA,aAAA;AACA,UAAA,MAAA,UAAA;AAEA,UAAA,EAAA,OAAAA,QAAA,OAAA,IAAA;AAEA,QAAA,OAAA,SAAA,GACA;AACA;IACA;AACA,UAAA,YAAA,CAAA;AACA,QAAA,MAAA,OAAA;AAGA,aAAA,IAAA,GAAA,IAAA,MAAA,QAAA,KACA;AACA,YAAA,OAAA,MAAA,CAAA;AAEA,gBAAA,KAAA,OAAA,SAAA,CAAA;AACA,eAAA,OAAA,OAAA,KAAA,MAAA;IACA;AAGA,UAAA,KAAA;AAEA,QAAA,GAAA,SAAA,OAAA,QACA;AACA,SAAA,SAAA,OAAA;IACA;AACA,UAAA,QAAA;AAEA,aAAA,IAAA,GAAA,KAAA,UAAA,QAAA,KACA;AACA,UAAA,SAAA,MAAA;AAEA,UAAA,IAAA,GACA;AACA,YAAA,IAAA,UAAA,QACA;AACA,mBAAA,UAAA,CAAA;QACA,OAEA;AACA,mBAAA,OAAA,UAAA;QACA;MACA;AACA,SAAA,QAAA,CAAA,IAAA,SAAA;AACA,UAAA,SAAA,KAAA,IAAA,CAAA,IAAA;AACA,eAAA,IAAA,OAAA,IAAA,IAAA,QAAA,KACA;AACA,WAAA,IAAA,IAAA,CAAA,IAAA,IAAA;AACA,WAAA,IAAA,IAAA,CAAA,IAAA;MACA;IACA;AAGA,iBAAA,gBAAA,uBAAA,QAAA,WAAA,CAAA;AAEA,QAAA,CAAA,aAAA,WACA;AACA;IACA;AAEA,QAAA,CAAA,aAAA,QACA;AACA,eAAA,IAAA,GAAA,IAAA,OAAA,QAAA,KAAA,GACA;AACA,QAAAA,OAAA,KAAA,OAAA,CAAA,GAAA,OAAA,IAAA,CAAA,CAAA;AACA,eAAA,KAAA,WAAA,IAAA;MACA;AAEA;IACA;AAEA,UAAA,EAAA,UAAA,IAAA;AAEA,UAAA,OAAA;AAEA,aAAA,IAAA,GAAA,IAAA,UAAA,QAAA,KAAA,GACA;AAEA,UAAA,OAAA;AAEA,eAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,cAAA,OAAA,UAAA,IAAA,CAAA;AACA,cAAA,OAAA,UAAA,KAAA,IAAA,KAAA,CAAA;AAEA,YAAA,GAAA,OAAA,CAAA,MAAA,QAAA,GAAA,OAAA,IAAA,CAAA,MAAA,MACA;AACA,kBAAA,KAAA;QACA;MACA;AACA,aAAA,KAAA,WAAA,cAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;AACA,aAAA,KAAA,WAAA,IAAA;IACA;AAGA,aAAA,MAAA,GAAA,MAAA,MAAA,GAAA,OACA;AACA,YAAA,OAAA,GAAA,MAAA,CAAA;AACA,YAAA,OAAA,GAAA,MAAA,IAAA,CAAA;AACA,UAAA,MAAA,OAAA,OAAA,IAAA,CAAA,IAAA,OAAA,MAAA,IAAA,CAAA;AAAA,UACA,MAAA,EAAA,OAAA,OAAA,CAAA,IAAA,OAAA,MAAA,CAAA;AACA,UAAA,MAAA,OAAA,MAAA,IAAA,CAAA,IAAA,OAAA,OAAA,IAAA,CAAA;AAAA,UACA,MAAA,EAAA,OAAA,MAAA,CAAA,IAAA,OAAA,OAAA,CAAA;AACA,YAAA,KAAA,KAAA,KAAA,MAAA,MAAA,MAAA,GAAA;AAEA,aAAA;AACA,aAAA;AACA,YAAA,KAAA,KAAA,KAAA,MAAA,MAAA,MAAA,GAAA;AAEA,aAAA;AACA,aAAA;AAEA,UAAA,KAAA,MAAA;AACA,UAAA,KAAA,MAAA;AACA,YAAA,IAAA,KAAA,MAAA,KAAA;AAEA,UAAA,KAAA,IAAA,CAAA,IAAA,KACA;AACA,aAAA;AACA,aAAA;MACA,OAEA;AACA,cAAA;AACA,cAAA;MACA;AACA,SAAA,MAAA,CAAA,IAAA;AACA,SAAA,MAAA,IAAA,CAAA,IAAA;IACA;AAEA,aAAA,IAAA,GAAA,IAAA,UAAA,QAAA,KAAA,GACA;AACA,YAAA,OAAA,UAAA,CAAA;AACA,YAAA,MAAA,UAAA,IAAA,CAAA;AACA,YAAA,OAAA,UAAA,IAAA,CAAA;AACA,YAAA,MAAA,OAAA,OAAA,IAAA,CAAA,IAAA,OAAA,MAAA,IAAA,CAAA;AAAA,YACA,MAAA,EAAA,OAAA,OAAA,CAAA,IAAA,OAAA,MAAA,CAAA;AACA,YAAA,MAAA,OAAA,MAAA,IAAA,CAAA,IAAA,OAAA,OAAA,IAAA,CAAA;AAAA,YACA,MAAA,EAAA,OAAA,MAAA,CAAA,IAAA,OAAA,OAAA,CAAA;AAEA,UAAA,KAAA;AAEA,UAAA,MAAA,MAAA,MAAA,MAAA,GACA;AACA,aAAA;MACA;AAEA,eAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,cAAAI,OAAA,UAAA,IAAA,IAAA,KAAA,CAAA;AAEA,QAAAJ,OAAA,KAAA,OAAAI,OAAA,CAAA,GAAA,OAAAA,OAAA,IAAA,CAAA,CAAA;MACA;AACA,eAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,cAAAA,OAAA,UAAA,IAAA,IAAA,KAAA,CAAA;AAEA,QAAAJ,OAAA,KAAA,GAAAI,OAAA,CAAA,GAAA,GAAAA,OAAA,IAAA,CAAA,CAAA;MACA;IACA;EACA;AACA;;ECrcA,CAAA,OAAA,IAAA,GAAA,IAAA,YAAA;EACA,CAAA,OAAA,IAAA,GAAA,IAAA,cAAA;EACA,CAAA,OAAA,IAAA,GAAA,IAAA,cAAA;EACA,CAAA,OAAA,IAAA,GAAA,IAAA,iBAAA;EACA,CAAA,OAAA,IAAA,GAAA,IAAA,wBAAA;AACA;;;ACkBA,IAAAC,YAAA,IAAA,MAAA;AACA,IAAAC,aAAA,IAAA,OAAA;oDAGA;EACA,OAAA,eAAA;AAAA,SAAA,iBAAA;EAAA;EAIA,SAAA;AAAA,SAAA,gBAAA;EAAA;EAKA,IAAA,SACA;AACA,WAAA,KAAA,UAAA;EACA;EAEA,IAAA,gBACA;AACA,WAAA,KAAA,UAAA;EACA;EAwBA,eAAA,SACA;AACA,SAAA,UAAA,IAAA,OAAA,MAAA,SAAA,KAAA;AACA,SAAA,gBAAA,IAAA,aAAA;AACA,SAAA,cAAA,IAAA,YAAA;AAEA,SAAA,eAAA,IAAA,OAAA,MAAA,SAAA,IAAA;AACA,SAAA,aAAA,SAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EACA,aAAA,WAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EACA,aAAA,WAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EACA,aAAA,SAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EACA,aAAA,WAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EAEA,aAAA,gBAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EAEA,aAAA,YAAA,KAAA,SAAA,GAAA,OAAA,MAAA,KAAA,EAEA,aAAA,UAAA,KAAA,SAAA,GAAA,MAAA,MAAA,aAAA,EACA,SAAA,KAAA,YAAA;AAEA,SAAA,eAAA;EACA;EAEA,cACA;AACA,UAAA;AAAA,2BAAA,UAAA,OAAA,KAAA,IAAA;AAEA,SAAA,eAAA,KAAA;AAEA,SAAA,YAAA,IAAA,UAAA;AAEA,SAAA,eAAA,CAAA;AAEA,SAAA,QAAA;AAEA,SAAA,aAAA;AAEA,SAAA,aAAA;AAEA,SAAA,aAAA;AAEA,SAAA,YAAA,CAAA;AAEA,SAAA,UAAA,CAAA;AAEA,SAAA,kBAAA;AAEA,SAAA,kBAAA;AAEA,SAAA,UAAA,IAAA,OAAA;AAEA,SAAA,cAAA;AAEA,SAAA,gBAAA;AAEA,SAAA,YAAA;AAEA,SAAA,gBAAA;AAEA,SAAA,SAAA;AACA,SAAA,WAAA;AACA,SAAA,cAAA;EACA;EAEA,gBAAA,WAAA,gBACA;AACA,QAAA,KAAA,QACA;AACA;IACA;AACA,SAAA,SAAA,IAAA,cAAA;AACA,SAAA,cAAA;EACA;;;;;;;EAQA,IAAA,SACA;AACA,QAAA,KAAA,gBAAA,KAAA,OACA;AACA,WAAA,cAAA,KAAA;AACA,WAAA,gBAAA;IACA;AAEA,WAAA,KAAA;EACA;;;;;EAMA,aACA;AACA,SAAA,cAAA;AACA,SAAA;AACA,SAAA;AACA,SAAA,kBAAA;AACA,SAAA,kBAAA;AACA,SAAA,WAAA;AAEA,SAAA,UAAA,MAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,UAAA,QAAA,KACA;AACA,WAAA,UAAA,CAAA,EAAA,MAAA;AACA,MAAAC,gBAAA,KAAA,KAAA,UAAA,CAAA,CAAA;IACA;AAEA,SAAA,UAAA,SAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,QAAA,QAAA,KACA;AACA,YAAA,YAAA,KAAA,QAAA,CAAA;AAEA,gBAAA,MAAA;AACA,MAAAC,YAAA,KAAA,SAAA;IACA;AAEA,SAAA,QAAA,SAAA;EACA;EAEA,QACA;AACA,QAAA,KAAA,aAAA,SAAA,GACA;AACA,WAAA,WAAA;AACA,WAAA;AACA,WAAA,aAAA,SAAA;IACA;AAEA,WAAA;EACA;EAEA,UACA,OACA,YAAA,MACA,YAAA,MACA,SAAA,MACA;AACA,UAAA,OAAA,IAAA,mBAAA,OAAA,WAAA,WAAA,MAAA;AAEA,SAAA,aAAA,KAAA,IAAA;AACA,SAAA;AAEA,WAAA;EACA;EAEA,SAAA,OAAA,SAAA,MACA;AACA,QAAA,CAAA,KAAA,aAAA,QACA;AACA,aAAA;IACA;AAEA,UAAA,OAAA,IAAA,mBAAA,OAAA,MAAA,MAAA,MAAA;AAEA,UAAA,YAAA,KAAA,aAAA,KAAA,aAAA,SAAA,CAAA;AAEA,SAAA,YAAA,UAAA;AAEA,cAAA,MAAA,KAAA,IAAA;AAEA,SAAA;AAEA,WAAA;EACA;EAEA,UACA;AACA,UAAA,QAAA;AAGA,aAAA,IAAA,GAAA,IAAA,KAAA,aAAA,QAAA,EAAA,GACA;AACA,WAAA,aAAA,CAAA,EAAA,QAAA;IACA;AAEA,SAAA,UAAA,QAAA;AACA,SAAA,YAAA;AACA,SAAA,YAAA,QAAA;AACA,SAAA,cAAA;AACA,SAAA,aAAA,SAAA;AACA,SAAA,eAAA;AACA,SAAA,UAAA,SAAA;AACA,SAAA,YAAA;AACA,SAAA,QAAA,SAAA;AACA,SAAA,UAAA;AACA,SAAA,UAAA;EACA;;;;;;;EAQA,cAAA,OACA;AACA,UAAA,eAAA,KAAA;AAEA,aAAA,IAAA,GAAA,IAAA,aAAA,QAAA,EAAA,GACA;AACA,YAAA,OAAA,aAAA,CAAA;AAEA,UAAA,CAAA,KAAA,UAAA,SACA;AACA;MACA;AAGA,UAAA,KAAA,OACA;AACA,YAAA,KAAA,QACA;AACA,eAAA,OAAA,aAAA,OAAAH,SAAA;QACA,OAEA;AACA,UAAAA,UAAA,SAAA,KAAA;QACA;AAEA,YAAA,KAAA,MAAA,SAAAA,UAAA,GAAAA,UAAA,CAAA,GACA;AACA,cAAA,UAAA;AAEA,cAAA,KAAA,OACA;AACA,qBAAAI,KAAA,GAAAA,KAAA,KAAA,MAAA,QAAAA,MACA;AACA,oBAAA,OAAA,KAAA,MAAAA,EAAA;AAEA,kBAAA,KAAA,MAAA,SAAAJ,UAAA,GAAAA,UAAA,CAAA,GACA;AACA,0BAAA;AACA;cACA;YACA;UACA;AAEA,cAAA,CAAA,SACA;AACA,mBAAA;UACA;QACA;MACA;IACA;AAEA,WAAA;EACA;EAEA,eACA;EAEA;EAEA,mBACA;AACA,SAAA,QAAA,OAAA,IAAA,aAAA,CAAA;EACA;EAEA,cACA;AACA,UAAA,EAAA,cAAA,UAAA,IAAA;AACA,UAAA,MAAA,aAAA;AAEA,aAAA,IAAA,KAAA,iBAAA,IAAA,KAAA,KACA;AACA,YAAA,OAAA,aAAA,CAAA;AAEA,WAAA,cAAA;AACA,WAAA,YAAA;AACA,WAAA,YAAA;AACA,WAAA,UAAA;AACA,YAAA,EAAA,WAAA,WAAA,MAAA,IAAA;AAEA,UAAA,CAAA,UAAA,WAAA,CAAA,UAAA,SACA;AACA;MACA;AAEA,YAAA,UAAAK,eAAA,KAAA,IAAA;AAEA,WAAA,UAAA;AAEA,cAAA,KAAA,MAAA,SAAA;AACA,UAAA,KAAA,QACA;AACA,aAAA,gBAAA,KAAA,QAAA,KAAA,MAAA;MACA;AAEA,WAAA,WAAA;AACA,UAAA,KAAA,OAAA,UAAA,GACA;AACA;MACA;AACA,UAAA,UAAA,SACA;AACA,YAAA,MAAA,QACA;AACA,eAAA,aAAA,KAAA;QACA;AACA,aAAA,SAAA,KAAA,UAAA,UACA,EAAA,KAAA,UAAA,WACA,KAAA,UAAA,SAAA,QACA,KAAA,UAAA,SAAA;AAEA,aAAA,YAAA,UAAA,OAAA;AACA,gBAAA,KAAA,MAAA,SAAA;AACA,aAAA,UAAA,UAAA,OAAA,SAAA,KAAA;MACA;AACA,UAAA,UAAA,SACA;AACA,aAAA,cAAA,UAAA,OAAA;AACA,gBAAA,KAAA,MAAA,SAAA;AACA,aAAA,YAAA,UAAA,OAAA,SAAA,KAAA;MACA;IACA;AACA,SAAA,kBAAA;EACA;EAEA,cAAA,gBACA;AACA,QAAA,CAAA,KAAA,aAAA,QACA;AACA,WAAA,YAAA;AAEA;IACA;AACA,SAAA,YAAA;AAEA,QAAA,CAAA,KAAA,iBAAA,GACA;AACA;IACA;AAEA,UAAA,EAAA,WAAA,aAAA,IAAA;AACA,UAAA,MAAA,aAAA;AAEA,SAAA,aAAA,KAAA;AAEA,QAAA,YAAA;AAEA,QAAA,eAAA;AAEA,QAAA,KAAA,QAAA,SAAA,GACA;AACA,kBAAA,KAAA,QAAA,KAAA,QAAA,SAAA,CAAA;AACA,qBAAA,UAAA;IACA;AAEA,aAAA,IAAA,KAAA,iBAAA,IAAA,KAAA,KACA;AACA,YAAA,OAAA,aAAA,CAAA;AACA,YAAA,YAAA,KAAA;AACA,YAAA,YAAA,KAAA;AAEA,UAAA,KAAA,QACA;AACA,aAAA,gBAAA,KAAA,QAAA,KAAA,MAAA;MACA;AACA,UAAA,CAAA,UAAA,WAAA,CAAA,UAAA,SACA;AACA;MACA;AACA,eAAA,IAAA,GAAA,IAAA,GAAA,KACA;AACA,cAAA,QAAA,MAAA,IAAA,YAAA;AAEA,YAAA,CAAA,MAAA;AAAA;AAEA,cAAA,cAAA,MAAA,QAAA;AACA,cAAA,YAAA,UAAA;AACA,cAAA,WAAA,UAAA;AAEA,oBAAA,WAAA,WAAA;AACA,YAAA,MAAA,GACA;AACA,eAAA,OAAA,iBAAA,KAAA,WAAA,KAAA,SAAA,KAAA,UAAA,QAAA,SAAA;QACA,OAEA;AACA,eAAA,OAAA,iBAAA,KAAA,aAAA,KAAA,WAAA,KAAA,UAAA,QAAA,SAAA;QACA;AAEA,cAAA,aAAA,UAAA;AAEA,YAAA,eAAA;AAAA;AAEA,YAAA,aAAA,CAAA,KAAA,eAAA,cAAA,KAAA,GACA;AACA,oBAAA,IAAA,UAAA,SAAA;AACA,sBAAA;QACA;AAEA,YAAA,CAAA,WACA;AACA,sBAAAF,YAAA,IAAA,KAAA,IAAAG,WAAA;AACA,oBAAA,MAAA,OAAA,UAAA,SAAA;AACA,eAAA,QAAA,KAAA,SAAA;AACA,yBAAA;QACA;AAEA,YAAA,MAAA,GACA;AACA,oBAAA,WAAA,KAAA,YAAA,KAAA;QACA,OAEA;AACA,oBAAA,WAAA,KAAA,cAAA,KAAA;QACA;MACA;IACA;AACA,SAAA,kBAAA;AAEA,QAAA,WACA;AACA,gBAAA,IAAA,UAAA,WAAA,UAAA,UAAA;IACA;AAEA,QAAA,KAAA,QAAA,WAAA,GACA;AAGA,WAAA,YAAA;AAEA;IACA;AAGA,SAAA,YAAA,KAAA,YAAA;AAEA,QAAA,KAAA,WACA;AACA,WAAA,YAAA;IACA,OAEA;AACA,WAAA,eAAA,cAAA;AACA,WAAA,WAAA;IACA;EACA;EAEA,aACA;AACA,UAAA,EAAA,YAAA,UAAA,IAAA,KAAA;AAEA,QAAA,KAAA,aAAA,YACA;AACA;IACA;AAEA,UAAA,EAAA,cAAA,QAAA,WAAA,QAAA,IAAA;AACA,UAAA,SAAA,KAAA;AACA,UAAA,QAAA,KAAA;AACA,UAAA,aAAA,aAAA;AAEA,QAAA,OAAA,KAAA,WAAA,YACA;AACA,YAAA,SAAA,IAAA,YAAA,aAAA,CAAA;AAEA,WAAA,gBAAA,IAAA,aAAA,MAAA;AACA,WAAA,cAAA,IAAA,YAAA,MAAA;AACA,aAAA,OAAA,KAAA;IACA;AACA,QAAA,MAAA,KAAA,WAAA,WACA;AACA,UAAA,aAAA,SAAA,KAAA,aACA;AACA,cAAA,OAAA,IAAA,YAAA,SAAA;MACA,OAEA;AACA,cAAA,OAAA,IAAA,YAAA,SAAA;MACA;IACA;AAEA,WAAA,UAAA,WAAA,KAAA,eAAA,KAAA,aAAA,MAAA,IAAA;AAEA,QAAA,IAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,aAAA,QAAA,KACA;AACA,YAAA,OAAA,KAAA,aAAA,CAAA;AAEA,UAAA,KAAA,SACA;AACA,eAAA,QAAA,CAAA,EAAA,YAAA,KAAA,WACA;AACA;QACA;AACA,eAAA;UAAA,KAAA;UAAA,KAAA;UAAA,KAAA;UACA,QAAA,CAAA,EAAA;UAAA,QAAA,CAAA,EAAA;QAAA;MACA;AACA,UAAA,KAAA,WACA;AACA,eAAA,QAAA,CAAA,EAAA,YAAA,KAAA,aACA;AACA;QACA;AACA,eAAA;UAAA,KAAA;UAAA,KAAA;UAAA,KAAA;UACA,QAAA,CAAA,EAAA;UAAA,QAAA,CAAA,EAAA;QAAA;MACA;IACA;AAEA,WAAA,OAAA;AACA,UAAA,OAAA;AACA,SAAA,WAAA;EACA;;;;;;;EAQA,eAAA,QAAA,QACA;AACA,QAAA,CAAA,UAAA,CAAA,QACA;AACA,aAAA;IACA;AAEA,QAAA,OAAA,QAAA,gBAAA,OAAA,QAAA,aACA;AACA,aAAA;IACA;AAEA,QAAA,OAAA,QAAA,OAAA,UAAA,OAAA,QAAA,OAAA,OACA;AACA,aAAA;IACA;AAEA,QAAA,OAAA,cAAA,MAAA,OAAA,cAAA,GACA;AACA,aAAA;IACA;AAGA,QAAA,OAAA,cAAA,OAAA,WACA;AACA,aAAA;IACA;AAEA,UAAA,OAAA,OAAA,UAAA,OAAA;AACA,UAAA,OAAA,OAAA,UAAA,OAAA;AAEA,WAAA,aAAA,MAAA,IAAA;EACA;;;;;;EAOA,mBACA;AACA,QAAA,KAAA,UAAA,KAAA,cAAA,CAAA,KAAA,aAAA,QACA;AACA,aAAA;IACA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,aAAA,QAAA,IAAA,GAAA,KACA;AACA,YAAA,OAAA,KAAA,aAAA,CAAA;AACA,YAAA,OAAA,KAAA;AACA,YAAA,OAAA,KAAA;AAEA,UAAA,QAAA,CAAA,KAAA,QAAA,YAAA;AAAA,eAAA;AACA,UAAA,QAAA,CAAA,KAAA,QAAA,YAAA;AAAA,eAAA;IACA;AAEA,WAAA;EACA;;;;;;EAOA,cACA;AACA,SAAA;AACA,UAAA,UAAA,KAAA;AAEA,aAAA,IAAA,GAAA,IAAA,QAAA,QAAA,IAAA,GAAA,KACA;AACA,YAAA,QAAA,QAAA,CAAA;AAEA,eAAA,IAAA,GAAA,IAAA,MAAA,MAAA,KACA;AACA,cAAA,QAAA,MAAA,QAAA;AAEA,aAAA,cAAA,KAAA,IAAA,KAAA,cAAA,KAAA,IAAA,MAAA;MACA;IACA;EACA;EAEA,cACA;AACA,WAAA;EAgBA;;;;;;EAOA,eAAA,gBACA;AACA,aAAA,IAAA,GAAA,IAAA,KAAA,UAAA,QAAA,KACA;AACA,WAAA,UAAA,CAAA,EAAA,MAAA;AACA,MAAAJ,gBAAA,KAAA,KAAA,UAAA,CAAA,CAAA;IACA;AAEA,SAAA,UAAA,SAAA;AAEA,QAAA,eAAAA,gBAAA,IAAA,KAAA,IAAAK,eAAA;AAEA,iBAAA,MAAA,gBAAA,IAAA;AAEA,QAAA,QAAA;AAEA,SAAA,UAAA,KAAA,YAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,QAAA,QAAA,KACA;AACA,YAAA,YAAA,KAAA,QAAA,CAAA;AACA,YAAA,QAAA,UAAA;AAEA,UAAA,UAAA,eAAA,GACA;AAEA;MACA;AAEA,UAAA,UAAA;AACA,YAAA,MAAA,MAAA,iBAAA;AAEA,UAAA,aAAA,MAAA,MAAA,MAAA,GACA;AACA,kBAAA,aAAA,IAAA,MAAA,SAAA,KAAA,MAAA,cAAA,GAAA,MAAA,aAAA,CAAA;MACA;AACA,UAAA,UAAA,GACA;AACA,uBAAAL,gBAAA,IAAA,KAAA,IAAAK,eAAA;AACA,aAAA,UAAA,KAAA,YAAA;AACA,qBAAA,MAAA,gBAAA,MAAA,MAAA;AACA,qBAAA,QAAA;AACA,kBAAA,aAAA,IAAA,MAAA,SAAA,KAAA,MAAA,cAAA,GAAA,MAAA,aAAA,CAAA;MACA;AACA,mBAAA,QAAA,UAAA;AACA,eAAA,UAAA;AAEA,YAAA,EAAA,OAAA,MAAA,IAAA;AACA,YAAA,OAAA,SAAA,OAAA,QAAA,WAAA,QAAA,QAAA;AAEA,gBAAA,OAAA,gBAAA,KAAA,KAAA;AACA,gBAAA,UAAA;IACA;EACA;EAEA,aAAA,OACA;AACA,aAAA,IAAA,GAAA,IAAA,MAAA,QAAA,KACA;AACA,YAAA,OAAA,MAAA,CAAA;AACA,YAAA,UAAAF,eAAA,KAAA,IAAA;AAEA,cAAA,KAAA,MAAA,KAAA,SAAA;AAEA,UAAA,KAAA,QACA;AACA,aAAA,gBAAA,KAAA,QAAA,KAAA,MAAA;MACA;IACA;EACA;;;;;;EAOA,kBACA;AACA,UAAA,SAAA,KAAA;AACA,UAAA,iBAAAJ;AACA,QAAA,YAAA,OAAA;AAEA,SAAA,QAAA,MAAA;AACA,mBAAA,MAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,aAAA,QAAA,KACA;AACA,YAAA,OAAA,KAAA,aAAA,CAAA;AACA,YAAA,QAAA,KAAA;AACA,YAAA,OAAA,KAAA;AACA,YAAA,YAAA,KAAA;AACA,YAAA,aAAA,KAAA,UAAA,OAAA;AACA,UAAA,YAAA;AAEA,UAAA,aAAA,UAAA,SACA;AACA,cAAA,YAAA,UAAA;AAEA,oBAAA,UAAA;AAEA,YAAA,SAAA,OAAA,MACA;AACA,sBAAA,aAAA,MAAA,KAAA,IAAA,MAAA,SAAA;QACA,OAEA;AACA,sBAAA,YAAA,KAAA,IAAA,GAAA,SAAA;QACA;MACA;AAEA,UAAA,cAAA,YACA;AACA,YAAA,CAAA,eAAA,QAAA,GACA;AACA,iBAAA,gBAAA,gBAAA,SAAA;AACA,yBAAA,MAAA;QACA;AACA,oBAAA;MACA;AAEA,UAAA,SAAA,OAAA,QAAA,SAAA,OAAA,MACA;AACA,cAAA,OAAA;AAEA,uBAAA;UAAA,KAAA;UAAA,KAAA;UAAA,KAAA,IAAA,KAAA;UAAA,KAAA,IAAA,KAAA;UACA;UAAA;QAAA;MACA,WACA,SAAA,OAAA,MACA;AACA,cAAA,SAAA;AAEA,uBAAA;UAAA,OAAA;UAAA,OAAA;UAAA,OAAA;UAAA,OAAA;UACA,OAAA,SAAA;UAAA,OAAA,SAAA;QAAA;MACA,WACA,SAAA,OAAA,MACA;AACA,cAAA,UAAA;AAEA,uBAAA;UAAA,QAAA;UAAA,QAAA;UAAA,QAAA;UAAA,QAAA;UACA,QAAA,QAAA;UAAA,QAAA,SAAA;QAAA;MACA,OAEA;AACA,cAAA,OAAA;AAGA,eAAA,kBAAA,WAAA,KAAA,QAAA,GAAA,KAAA,OAAA,QAAA,WAAA,SAAA;MACA;IACA;AAEA,QAAA,CAAA,eAAA,QAAA,GACA;AACA,aAAA,gBAAA,gBAAA,SAAA;IACA;AAEA,WAAA,IAAA,KAAA,eAAA,KAAA,aAAA;EACA;;;;;;;;EASA,gBAAA,QAAA,QACA;AACA,aAAA,IAAA,GAAA,IAAA,OAAA,SAAA,GAAA,KACA;AACA,YAAA,IAAA,OAAA,IAAA,CAAA;AACA,YAAA,IAAA,OAAA,IAAA,IAAA,CAAA;AAEA,aAAA,IAAA,CAAA,IAAA,OAAA,IAAA,IAAA,OAAA,IAAA,IAAA,OAAA;AACA,aAAA,IAAA,IAAA,CAAA,IAAA,OAAA,IAAA,IAAA,OAAA,IAAA,IAAA,OAAA;IACA;EACA;AACA;AAAA,uBAAA,aAAA;AC52BA,IAAA,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8WA,IAAA,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAgDA;EAGA,YAAAX,WACA,OAAA,YACA,OAAA,YACA,YAAA,CAAA,GACA;AACA,UAAA,EAAA,WAAA,YAAA,IAAAA;AAEA,WAAA,KAAA,QAAA,oBAAA,GAAA,aAAA,EACA,QAAA,kBAAA,GAAA,WAAA;AACA,WAAA,KAAA,QAAA,oBAAA,GAAA,aAAA,EAEA,QAAA,gBAAA,qBAAA,kBAAA,WAAA,CAAA;AAEA,UAAA,MAAA,IAAA;AACA,SAAA,WAAAA;EACA;AACA;gDAGA;EAGA,YAAAA,WAAA,OAAA,IAAA,sBAAAA,SAAA,GAAA,WAAA,CAAA,GACA;AACA,UAAA,EAAA,WAAA,YAAA,IAAAA;AACA,UAAA,eAAA,IAAA,WAAA,WAAA;AAEA,aAAA,IAAA,GAAA,IAAA,aAAA,KACA;AACA,mBAAA,CAAA,IAAA;IACA;AACA,UAAA,MAAA,OAAA,OAAA,UAAA;MACA,aAAA,IAAA,aAAA,IAAA,SAAA;MACA,gBAAA,IAAA,aAAA,SAAA;MACA,WAAA,IAAA,aAAA,IAAA,SAAA;MACA,aAAA,IAAA,aAAA,IAAA,WAAA;MACA,WAAA;MACA,MAAA,IAAA,aAAA,CAAA,GAAA,GAAA,GAAA,CAAA,CAAA;MACA,YAAA;MACA,QAAA;IACA,CAAA,CAAA;AACA,SAAA,WAAAA;EACA;EAEA,OAAA,kBAAA,aACA;AACA,QAAA,MAAA;AAEA,WAAA;AACA,WAAA;AAEA,aAAA,IAAA,GAAA,IAAA,aAAA,KACA;AACA,UAAA,IAAA,GACA;AACA,eAAA;MACA;AAEA,UAAA,IAAA,cAAA,GACA;AACA,eAAA,kBAAA;MACA;AAEA,aAAA;AACA,aAAA;kCAAA;AACA,aAAA;IACA;AAEA,WAAA;AACA,WAAA;AAEA,WAAA;EACA;AACA;;ECpeA,iBAAA,gBAAA;EACA,mBAAA;EACA,qBAAA;AACA;ACeA,IAAA,EAAA,aAAAkB,cAAA,gBAAAC,iBAAA,UAAAC,UAAA,IAAA;AAEA,IAAAC,QAAA,IAAA,aAAA,CAAA;AAEA,IAAAC,mBAAA,CAAA;6CAqBA;EACA,OAAA,eAAA;AAAA,SAAA,cAAA,IAAA,MAAA;EAAA;EAsBA,IAAA,WACA;AACA,WAAA,KAAA;EACA;EAEA,YAAA,WAAA,MACA;AACA,UAAA;AAEA,SAAA,YAAA,YAAA,IAAA,uBAAA;AACA,SAAA,UAAA;AAEA,SAAA,SAAA;AAEA,SAAA,iBAAA;MACA,WAAA,SAAA;MACA,aAAA,SAAA;IACA;AAEA,SAAA,QAAA,MAAA,MAAA;AAEA,SAAA,aAAA,IAAArB,WAAA;AAEA,SAAA,aAAA,IAAAE,WAAA;AAEA,SAAA,UAAA;AAEA,SAAA,YAAA;AAEA,SAAA,cAAA;AAEA,SAAA,UAAA,CAAA;AAEA,SAAA,YAAA;AAEA,SAAA,aAAA;AAEA,SAAA,aAAA;AAEA,SAAA,aAAA;AAEA,SAAA,eAAA;AAGA,SAAA,OAAA;AACA,SAAA,YAAA,YAAA;EACA;EAEA,QACA;AACA,SAAA,WAAA;AAEA,WAAA,IAAA,eAAA,KAAA,SAAA;EACA;EAEA,IAAA,UAAA,OACA;AACA,SAAA,MAAA,YAAA;EACA;EAEA,IAAA,YACA;AACA,WAAA,KAAA,MAAA;EACA;EAEA,IAAA,OACA;AACA,WAAA,KAAA;EACA;EAEA,IAAA,KAAA,OACA;AACA,SAAA,QAAA;EACA;EAEA,IAAA,OACA;AACA,WAAA,KAAA;EACA;EAEA,IAAA,OACA;AACA,WAAA,KAAA;EACA;EAMA,UAAA,UAAA,MACA,QAAA,GAAA,QAAA,GAAA,YAAA,KAAA,YAAA,SAAA,iBACA;AAEA,QAAA,OAAA,YAAA,UACA;AACA,UAAA,OAAA,cAAA,WACA;AACA,oBAAA,YAAA,gBAAA,OAAA,gBAAA;MACA;AACA,gBAAA,EAAA,OAAA,SAAA,OAAA,OAAA,WAAA,UAAA;IACA,OAEA;AACA,YAAA,SAAA,QAAA;AAEA,UAAA,WAAA,QACA;AACA,gBAAA,YAAA,SAAA,gBAAA,OAAA,gBAAA;MACA;IACA;AAEA,WAAA,KAAA,iBAAA,OAAA;EACA;EAEA,iBAAA,SACA;AAEA,cAAA,OAAA,OAAA;MACA,OAAA;MACA,SAAA,QAAA;MACA,OAAA,WAAA,QAAA,UAAA,WAAA;MACA,OAAA;MACA,QAAA;MACA,WAAA;MACA,QAAA;MACA,KAAA,SAAA;MACA,MAAA,UAAA;MACA,YAAA;MACA,QAAA;MACA,WAAA,SAAA;IACA,GAAA,OAAA;AAEA,QAAA,KAAA,aACA;AACA,WAAA,UAAA;IACA;AAEA,UAAA,UAAA,QAAA,QAAA,KAAA,QAAA,QAAA;AAEA,QAAA,CAAA,SACA;AACA,WAAA,WAAA,MAAA;IACA,OAEA;AACA,UAAA,QAAA,QACA;AACA,gBAAA,SAAA,QAAA,OAAA,MAAA;AACA,gBAAA,OAAA,OAAA;MACA;AAEA,aAAA,OAAA,KAAA,YAAA,EAAA,QAAA,GAAA,OAAA;IACA;AAEA,WAAA;EACA;EAEA,YACA;AACA,QAAA,KAAA,aACA;AACA,YAAA,SAAA,KAAA,YAAA;AACA,YAAA,MAAA,KAAA,YAAA,OAAA;AAEA,UAAA,MAAA,GACA;AACA,aAAA,UAAA,KAAA,WAAA;AACA,aAAA,cAAA,IAAA,QAAA;AACA,aAAA,YAAA,cAAA;AACA,aAAA,YAAA,OAAA,KAAA,OAAA,MAAA,CAAA,GAAA,OAAA,MAAA,CAAA,CAAA;MACA;IACA,OAEA;AACA,WAAA,cAAA,IAAA,QAAA;AACA,WAAA,YAAA,cAAA;IACA;EACA;EAEA,aACA;AACA,QAAA,KAAA,aACA;AACA,UAAA,KAAA,YAAA,OAAA,SAAA,GACA;AACA,aAAA,UAAA,KAAA,WAAA;AACA,aAAA,cAAA;MACA,OAEA;AACA,aAAA,YAAA,OAAA,SAAA;MACA;IACA;EACA;EAEA,OAAA,GAAA,GACA;AACA,SAAA,UAAA;AACA,SAAA,YAAA,OAAA,CAAA,IAAA;AACA,SAAA,YAAA,OAAA,CAAA,IAAA;AAEA,WAAA;EACA;EAEA,OAAA,GAAA,GACA;AACA,QAAA,CAAA,KAAA,aACA;AACA,WAAA,OAAA,GAAA,CAAA;IACA;AAGA,UAAA,SAAA,KAAA,YAAA;AACA,UAAA,QAAA,OAAA,OAAA,SAAA,CAAA;AACA,UAAA,QAAA,OAAA,OAAA,SAAA,CAAA;AAEA,QAAA,UAAA,KAAA,UAAA,GACA;AACA,aAAA,KAAA,GAAA,CAAA;IACA;AAEA,WAAA;EACA;EAEA,WAAA,IAAA,GAAA,IAAA,GACA;AACA,QAAA,KAAA,aACA;AACA,UAAA,KAAA,YAAA,OAAA,WAAA,GACA;AACA,aAAA,YAAA,SAAA,CAAA,GAAA,CAAA;MACA;IACA,OAEA;AACA,WAAA,OAAA,GAAA,CAAA;IACA;EACA;EAEA,iBAAA,KAAA,KAAA,KAAA,KACA;AACA,SAAA,WAAA;AAEA,UAAA,SAAA,KAAA,YAAA;AAEA,QAAA,OAAA,WAAA,GACA;AACA,WAAA,OAAA,GAAA,CAAA;IACA;AAEA,IAAAgB,gBAAA,QAAA,KAAA,KAAA,KAAA,KAAA,MAAA;AAEA,WAAA;EACA;EAEA,cAAA,KAAA,KAAA,MAAA,MAAA,KAAA,KACA;AACA,SAAA,WAAA;AAEA,IAAAD,aAAA,QAAA,KAAA,KAAA,MAAA,MAAA,KAAA,KAAA,KAAA,YAAA,MAAA;AAEA,WAAA;EACA;EAEA,MAAA,IAAA,IAAA,IAAA,IAAA,QACA;AACA,SAAA,WAAA,IAAA,EAAA;AAEA,UAAA,SAAA,KAAA,YAAA;AAEA,UAAA,SAAAE,UAAA,QAAA,IAAA,IAAA,IAAA,IAAA,QAAA,MAAA;AAEA,QAAA,QACA;AACA,YAAA,EAAA,IAAA,IAAA,QAAAG,SAAA,YAAA,UAAA,cAAA,IAAA;AAEA,WAAA,IAAA,IAAA,IAAAA,SAAA,YAAA,UAAA,aAAA;IACA;AAEA,WAAA;EACA;EAEA,IAAA,IAAA,IAAA,QAAA,YAAA,UAAA,gBAAA,OACA;AACA,QAAA,eAAA,UACA;AACA,aAAA;IACA;AAEA,QAAA,CAAA,iBAAA,YAAA,YACA;AACA,kBAAA;IACA,WACA,iBAAA,cAAA,UACA;AACA,oBAAA;IACA;AAEA,UAAA,QAAA,WAAA;AAEA,QAAA,UAAA,GACA;AACA,aAAA;IACA;AAEA,UAAA,SAAA,KAAA,KAAA,IAAA,UAAA,IAAA;AACA,UAAA,SAAA,KAAA,KAAA,IAAA,UAAA,IAAA;AACA,UAAA,MAAA,KAAA,UAAA;AAGA,QAAA,SAAA,KAAA,cAAA,KAAA,YAAA,SAAA;AAEA,QAAA,QACA;AAIA,YAAA,QAAA,KAAA,IAAA,OAAA,OAAA,SAAA,CAAA,IAAA,MAAA;AACA,YAAA,QAAA,KAAA,IAAA,OAAA,OAAA,SAAA,CAAA,IAAA,MAAA;AAEA,UAAA,QAAA,OAAA,QAAA;AACA;WAKA;AACA,eAAA,KAAA,QAAA,MAAA;MACA;IACA,OAEA;AACA,WAAA,OAAA,QAAA,MAAA;AACA,eAAA,KAAA,YAAA;IACA;AAEA,IAAAH,UAAA,IAAA,QAAA,QAAA,IAAA,IAAA,QAAA,YAAA,UAAA,eAAA,MAAA;AAEA,WAAA;EACA;EAEA,UAAA,QAAA,GAAA,QAAA,GAAA,SAAA,OACA;AACA,WAAA,KAAA,iBAAA,EAAA,SAAA,QAAA,OAAA,OAAA,OAAA,OAAA,CAAA;EACA;EAEA,iBAAA,SACA;AAEA,cAAA,OAAA,OAAA;MACA,SAAA,QAAA;MACA,OAAA;MACA,OAAA;MACA,QAAA;MACA,QAAA;IACA,GAAA,OAAA;AAEA,QAAA,KAAA,aACA;AACA,WAAA,UAAA;IACA;AAEA,UAAA,UAAA,QAAA,QAAA;AAEA,QAAA,CAAA,SACA;AACA,WAAA,WAAA,MAAA;IACA,OAEA;AACA,UAAA,QAAA,QACA;AACA,gBAAA,SAAA,QAAA,OAAA,MAAA;AACA,gBAAA,OAAA,OAAA;MACA;AAEA,aAAA,OAAA,KAAA,YAAA,EAAA,QAAA,GAAA,OAAA;IACA;AAEA,WAAA;EACA;EAEA,UACA;AACA,SAAA,WAAA;AAEA,SAAA,WAAA,MAAA;AAEA,WAAA;EACA;EAEA,SAAA,GAAA,GAAA,OAAA,QACA;AACA,WAAA,KAAA,UAAA,IAAA,UAAA,GAAA,GAAA,OAAA,MAAA,CAAA;EACA;EAEA,gBAAA,GAAA,GAAA,OAAA,QAAA,QACA;AACA,WAAA,KAAA,UAAA,IAAA,iBAAA,GAAA,GAAA,OAAA,QAAA,MAAA,CAAA;EACA;EAEA,WAAA,GAAA,GAAA,QACA;AACA,WAAA,KAAA,UAAA,IAAA,OAAA,GAAA,GAAA,MAAA,CAAA;EACA;EAEA,YAAA,GAAA,GAAA,OAAA,QACA;AACA,WAAA,KAAA,UAAA,IAAA,QAAA,GAAA,GAAA,OAAA,MAAA,CAAA;EACA;EAKA,eAAA,MACA;AACA,QAAA;AACA,QAAA,cAAA;AAEA,UAAA,OAAA,KAAA,CAAA;AAGA,QAAA,KAAA,QACA;AACA,oBAAA,KAAA;AACA,eAAA,KAAA;IACA,WACA,MAAA,QAAA,KAAA,CAAA,CAAA,GACA;AACA,eAAA,KAAA,CAAA;IACA,OAEA;AACA,eAAA;IACA;AAEA,UAAA,QAAA,IAAA,QAAA,MAAA;AAEA,UAAA,cAAA;AAEA,SAAA,UAAA,KAAA;AAEA,WAAA;EACA;EAEA,UAAA,OACA;AACA,QAAA,CAAA,KAAA,WACA;AACA,WAAA,UAAA;QACA;QACA,KAAA,WAAA,MAAA;QACA,KAAA,WAAA,MAAA;QACA,KAAA;MACA;IACA,OAEA;AACA,WAAA,UAAA,SAAA,OAAA,KAAA,OAAA;IACA;AAEA,WAAA;EACA;EAEA,QACA;AACA,SAAA,UAAA,MAAA;AACA,SAAA,WAAA,MAAA;AACA,SAAA,WAAA,MAAA;AAEA,SAAA;AACA,SAAA,UAAA;AACA,SAAA,YAAA;AACA,SAAA,cAAA;AAEA,WAAA;EACA;EAEA,aACA;AACA,UAAA,OAAA,KAAA,UAAA;AAEA,WAAA,KAAA,WAAA,KACA,KAAA,CAAA,EAAA,MAAA,SAAA,OAAA,QACA,EAAA,KAAA,CAAA,EAAA,UAAA,WAAA,KAAA,CAAA,EAAA,UAAA;EACA;EAEA,cAAA,UACA;AACA,IAAA,SAAA,UAAA,cAAA,KAAA,MAAA,QAAA;EACA;EAEA,QAAA,UACA;AACA,SAAA,WAAA;AAEA,UAAA,WAAA,KAAA;AACA,UAAA,YAAA,SAAA,QAAA,SAAA;AAIA,aAAA,gBAAA,SAAA,SAAA,aAAA,SAAA;AAEA,aAAA,cAAA,KAAA,cAAA;AAEA,QAAA,SAAA,WACA;AACA,UAAA,KAAA,eAAA,SAAA,YACA;AACA,aAAA,iBAAA;MACA;AAEA,WAAA,eAAA,QAAA;IACA,OAEA;AAEA,eAAA,MAAA,MAAA;AAEA,WAAA,cAAA,QAAA;IACA;EACA;EAEA,mBACA;AACA,UAAA,WAAA,KAAA;AACA,UAAA,YAAA,KAAA;AACA,UAAA,MAAA,SAAA,QAAA;AAEA,SAAA,YAAA;AACA,SAAA,eAAA;AACA,SAAA,aAAA,SAAA;AACA,SAAA,QAAA,SAAA;AAEA,SAAA,aAAA,IAAA,aAAA,SAAA,MAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,KACA;AACA,YAAA,KAAA,SAAA,QAAA,CAAA;AACA,YAAA,QAAA,GAAA,MAAA;AACA,YAAA,aAAA,IAAA;QAAA,KAAA,WAAA;QACA,GAAA,cAAA,IAAA;QACA,GAAA,aAAA;MAAA;AAUA,YAAA,QAAA;QACA;QACA;;;QAGA,WAAA,QAAA,KAAA;QACA,UAAA;QACA,UAAA,GAAA,MAAA;QACA,OAAA,GAAA,MAAA;QACA,YAAA;MACA;AAEA,WAAA,QAAA,CAAA,IAAA;IACA;EACA;EAEA,eAAA,UACA;AACA,QAAA,CAAA,KAAA,QAAA,QACA;AACA;IACA;AAEA,aAAA,MAAA,kBAAA,SAAA,QAAA,KAAA,UAAA,CAAA;AAEA,SAAA,kBAAA;AACA,SAAA,eAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,QAAA,QAAA,IAAA,GAAA,KACA;AACA,YAAA,QAAA,KAAA,QAAA,CAAA;AAEA,YAAA,aAAA,KAAA,aAAA,MAAA;AAEA,eAAA,QAAA,KAAA,UAAA,EAAA,OAAA,KAAA;IACA;EACA;EAEA,cAAA,UACA;AACA,UAAA,eAAA,KAAA,qBAAA,QAAA;AACA,QAAA,SAAA;AAEA,UAAA,WAAA,KAAA;AACA,UAAA,OAAA,KAAA;AACA,UAAA,aAAA,KAAA;AACA,UAAA,WAAA,OAAA;AACA,UAAA,YAAA,SAAA;AAGA,aAAA,oBAAA,KAAA,UAAA;AAGA,aAAA,KAAA,CAAA,KAAA,QAAA,KAAA,OAAA,MAAA;AACA,aAAA,KAAA,CAAA,KAAA,QAAA,IAAA,OAAA,MAAA;AACA,aAAA,KAAA,CAAA,KAAA,OAAA,OAAA,MAAA;AACA,aAAA,KAAA,CAAA,IAAA;AAEA,aAAA,aAAA,SAAA,cAAA,UACA,SAAA,cAAA,QAAA,aAAA,SAAA;AAEA,UAAA,YAAA,SAAA,WAAA;AAEA,QAAA,WACA;AAEA,YAAA,QAAA,KAAA,KAAA,UAAA,IAAA,UAAA,IAAA,UAAA,IAAA,UAAA,CAAA;AAEA,eAAA,cAAA;IACA;AAEA,aAAA,UAAA,SAAA,QAAA,YAAA,IAAA,KAAA,SAAA;AAOA,aAAA,OAAA,KAAA,MAAA;AACA,aAAA,SAAA,KAAA,UAAA,MAAA;AAGA,aAAA,MAAA,IAAA,KAAA,KAAA;AAEA,aAAA;AAEA,aAAA,IAAA,GAAA,IAAA,UAAA,QAAA,IAAA,GAAA,KACA;AAEA,YAAA,WAAA,SAAA,UAAA,CAAA;AAEA,YAAA,eAAA,WAAA,SAAA;AAEA,UAAA,cACA;AACA,iBAAA,SAAA;AACA,YAAA,QACA;AACA,iBAAA,SAAA,oBAAA,KAAA,UAAA;AACA,cAAA,OAAA,SAAA,MACA;AACA,mBAAA,SAAA,KAAA,CAAA,IAAA,SAAA,KAAA,CAAA;AACA,mBAAA,SAAA,KAAA,CAAA,IAAA,SAAA,KAAA,CAAA;AACA,mBAAA,SAAA,KAAA,CAAA,IAAA,SAAA,KAAA,CAAA;AACA,mBAAA,SAAA,KAAA,CAAA,IAAA,SAAA,KAAA,CAAA;UACA;QACA;MACA;AAEA,YAAA,EAAA,UAAA,YAAA,MAAA,MAAA,IAAA;AACA,YAAA,oBAAA,SAAA;AACA,YAAA,aAAA,UAAA;AAEA,YAAA,OAAA,WAAA,SAAA;AACA,YAAA,OAAA,WAAA,SAAA;AACA,YAAA,QAAA,WAAA,SAAA;AAEA,eAAAN,KAAA,GAAAA,KAAA,WAAA,OAAAA,MACA;AACA,aAAAA,EAAA,IAAA,WAAA,WAAAA,EAAA;AACA,cAAAA,KAAA,CAAA,IAAA,WAAA,MAAAA,KAAA,CAAA;AACA,cAAAA,KAAA,IAAA,CAAA,IAAA,WAAA,MAAAA,KAAA,IAAA,CAAA;AACA,cAAA,IAAA,WAAA,SAAAA,EAAA;AAEA,aAAAA,KAAA,CAAA,IAAA,EAAA;AACA,aAAAA,KAAA,IAAA,CAAA,IAAA,EAAA;AACA,aAAAA,KAAA,IAAA,CAAA,IAAA,EAAA;AACA,aAAAA,KAAA,IAAA,CAAA,IAAA,EAAA;AACA,aAAAA,KAAA,IAAA,CAAA,IAAA,EAAA;AACA,aAAAA,KAAA,IAAA,CAAA,IAAA,EAAA;MACA;AACA,YAAA,QAAA,WAAA,SAAA;AAEA,eAAAA,KAAA,GAAAA,KAAA,mBAAAA,MACA;AACA,cAAAA,KAAA,CAAA,IAAA,SAAA,SAAAA,EAAA,EAAA;AACA,cAAAA,KAAA,IAAA,CAAA,IAAA,SAAA,SAAAA,EAAA,EAAA;MACA;AAEA,eAAA,OAAA,KAAA,UAAA;AACA,UAAA,cACA;AACA,iBAAA,SAAA,KAAA,QAAA;MACA;AAGA,eAAA,IAAA,GAAA,IAAA,mBAAA,KACA;AACA,iBAAA,QAAA,KAAA,SAAA,SAAA,CAAA,GAAA,CAAA;MACA;AAGA,eAAA,SAAA,KAAA,WAAA,WAAA,MAAA,KAAA;IACA;EACA;EAEA,qBAAA,WACA;AACA,QAAA,SAAA,KAAA;AAEA,UAAA,aAAA,KAAA;AAEA,QAAA,CAAA,QACA;AACA,UAAA,CAAAQ,iBAAA,UAAA,GACA;AACA,QAAAA,iBAAA,UAAA,IAAA,IAAA,qBAAA,KAAA,cAAA;MACA;AACA,eAAAA,iBAAA,UAAA;IACA;AAEA,WAAA;EACA;EAEA,mBACA;AACA,SAAA,WAAA;AAEA,UAAA,WAAA,KAAA;AAGA,QAAA,CAAA,SAAA,aAAA,QACA;AACA;IACA;AAEA,UAAA,EAAA,MAAA,MAAA,MAAA,KAAA,IAAA,SAAA;AAEA,SAAA,QAAA,SAAA,KAAA,WAAA,MAAA,MAAA,MAAA,IAAA;EACA;EAEA,cAAA,OACA;AACA,SAAA,eAAA,aAAA,OAAA,eAAA,WAAA;AAEA,WAAA,KAAA,UAAA,cAAA,eAAA,WAAA;EACA;EAEA,iBACA;AACA,QAAA,KAAA,cAAA,KAAA,MACA;AACA,WAAA,YAAA,KAAA;AAEA,YAAA,UAAA,QAAA,KAAA,MAAAD,KAAA;AAEA,eAAA,IAAA,GAAA,IAAA,KAAA,QAAA,QAAA,KACA;AACA,cAAA,QAAA,KAAA,QAAA,CAAA;AAEA,cAAA,YAAA,MAAA;AAEA,cAAA,IAAA,QAAA,CAAA,IAAA,UAAA,CAAA,IAAA;AACA,cAAA,IAAA,QAAA,CAAA,IAAA,UAAA,CAAA,IAAA;AACA,cAAA,IAAA,QAAA,CAAA,IAAA,UAAA,CAAA,IAAA;AAGA,cAAA,SAAA,KAAA,OAAA,KAAA,MAAA,IAAA;AAEA,cAAA,YAAA,SAAA,OACA,QAAA,WACA,QAAA,QAAA;MACA;IACA;EACA;EAEA,oBACA;AACA,UAAA,OAAA,KAAA,UAAA;AAEA,QAAA,KAAA,iBAAA,MACA;AACA;IACA;AAEA,SAAA,eAAA;AAEA,UAAA,KAAA,KAAA,UAAA;AACA,UAAA,IAAA,GAAA;AACA,UAAA,IAAA,GAAA;AACA,UAAA,IAAA,GAAA;AACA,UAAA,IAAA,GAAA;AACA,UAAA,KAAA,GAAA;AACA,UAAA,KAAA,GAAA;AAEA,UAAA,OAAA,KAAA,UAAA;AACA,UAAA,aAAA,KAAA;AAEA,QAAA,QAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,QAAA,KAAA,GACA;AACA,YAAA,IAAA,KAAA,CAAA;AACA,YAAA,IAAA,KAAA,IAAA,CAAA;AAEA,iBAAA,OAAA,IAAA,IAAA,IAAA,IAAA,IAAA;AACA,iBAAA,OAAA,IAAA,IAAA,IAAA,IAAA,IAAA;IACA;EACA;EAEA,YACA;AACA,UAAA,cAAA,KAAA;AAEA,QAAA,aACA;AAEA,kBAAA,cAAA;IACA;AAEA,WAAA;EACA;EAEA,UAAA,QACA;AACA,SAAA,UAAA;AAEA,WAAA;EACA;EAEA,YACA;AACA,SAAA,WAAA;AACA,SAAA,YAAA;AAEA,WAAA;EACA;EAEA,UACA;AACA,SAAA,WAAA;AACA,SAAA,YAAA;AAEA,WAAA;EACA;EAEA,QAAA,SACA;AACA,SAAA,UAAA;AACA,QAAA,KAAA,UAAA,aAAA,GACA;AACA,WAAA,UAAA,QAAA;IACA;AAEA,SAAA,UAAA;AACA,SAAA,cAAA;AACA,SAAA,WAAA,QAAA;AACA,SAAA,aAAA;AACA,SAAA,WAAA,QAAA;AACA,SAAA,aAAA;AACA,SAAA,YAAA;AACA,SAAA,SAAA;AACA,SAAA,aAAA;AACA,SAAA,QAAA,SAAA;AACA,SAAA,UAAA;AAEA,UAAA,QAAA,OAAA;EACA;EAEA,SAAA,GAAA,GACA,QAAA,QAAA,aAAA,WAAA,GACA;AAEA,WAAA,KAAA,YAAA,IAAA,KAAA,GAAA,GAAA,QAAA,QAAA,aAAA,QAAA,CAAA;EACA;AACA;AAAA,eAAA,aAAA;iCAGA;EACA,YAAA,GAAA,GAAA,QAAA,QAAA,aAAA,WAAA,GACA;AACA,kBAAA,eAAA,SAAA;AAEA,UAAA,aAAA,KAAA,KAAA,KAAA,IAAA;AACA,UAAA,MAAA,SAAA;AACA,UAAA,QAAA,OAAA;AACA,UAAA,UAAA,CAAA;AAEA,aAAA,IAAA,GAAA,IAAA,KAAA,KACA;AACA,YAAA,IAAA,IAAA,IAAA,cAAA;AACA,YAAA,QAAA,IAAA,QAAA;AAEA,cAAA;QACA,IAAA,IAAA,KAAA,IAAA,KAAA;QACA,IAAA,IAAA,KAAA,IAAA,KAAA;MACA;IACA;AAEA,UAAA,OAAA;EACA;AACA;ACh9BA,IAAA,WAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDA+DA;EACA,YAAA,YACA;AACA,UAAArB,YAAA,EAAA,WAAA,IAAA,aAAA,EAAA;AAEA;MAAAA;MAAA,IAAA,sBAAAA,WAAA,QAAA,QAAA;MACA,cAAA;QACA,MAAA;QACA,KAAA;MACA;IAAA;EACA;AACA;",
  "names": ["LINE_JOIN", "LINE_CAP", "FillStyle", "d", "b", "verts", "ArcUtils", "BezierUtils", "QuadraticUtils", "BatchPart", "GraphicsData", "GraphicsGeometry", "LineStyle", "Graphics", "_a", "settings", "FillStyle", "LINE_SCALE_MODE", "LineStyle", "JOINT_TYPE", "verts", "j", "getPt", "quadraticBezierCurve", "ind", "tmpPoint", "tmpBounds", "DRAW_CALL_POOL", "BATCH_POOL", "i", "FILL_COMMANDS", "BatchPart", "BatchDrawCall", "BezierUtils", "QuadraticUtils", "ArcUtils", "temp", "DEFAULT_SHADERS", "radius"]
}
