import {
  TEXT_GRADIENT,
  TextMetrics,
  TextStyle
} from "./chunk-3JEBSM2O.js";
import "./chunk-C7PIBFK2.js";
import {
  Container
} from "./chunk-Q4VYVUYK.js";
import {
  LoaderResource
} from "./chunk-LWDBDAHE.js";
import {
  BaseTexture,
  Buffer,
  Geometry,
  Program,
  Shader,
  State,
  Texture,
  TextureMatrix
} from "./chunk-QNDMGAQH.js";
import "./chunk-6IDTDDQ4.js";
import {
  getResolutionOfUrl,
  hex2rgb,
  premultiplyTintToRgba,
  removeItems,
  string2hex
} from "./chunk-2J3TKREV.js";
import {
  settings
} from "./chunk-MITDHAZJ.js";
import {
  Matrix,
  ObservablePoint,
  Point,
  Polygon,
  Rectangle
} from "./chunk-R5PW3AE4.js";
import {
  DRAW_MODES,
  TYPES
} from "./chunk-4WFBNS3T.js";
import "./chunk-DFKQJ226.js";

// pixi-graph/node_modules/@pixi/mesh/dist/esm/mesh.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var MeshBatchUvs = function() {
  function MeshBatchUvs2(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  MeshBatchUvs2.prototype.update = function(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    var data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  };
  return MeshBatchUvs2;
}();
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = function(_super) {
  __extends(Mesh2, _super);
  function Mesh2(geometry, shader, state, drawMode) {
    if (drawMode === void 0) {
      drawMode = DRAW_MODES.TRIANGLES;
    }
    var _this = _super.call(this) || this;
    _this.geometry = geometry;
    geometry.refCount++;
    _this.shader = shader;
    _this.state = state || State.for2d();
    _this.drawMode = drawMode;
    _this.start = 0;
    _this.size = 0;
    _this.uvs = null;
    _this.indices = null;
    _this.vertexData = new Float32Array(1);
    _this.vertexDirty = -1;
    _this._transformID = -1;
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.batchUvs = null;
    return _this;
  }
  Object.defineProperty(Mesh2.prototype, "uvBuffer", {
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "material", {
    get: function() {
      return this.shader;
    },
    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.MeshMaterial}
     */
    set: function(value) {
      this.shader = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "tint", {
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * Null for non-MeshMaterial shaders
     * @member {number}
     * @default 0xFFFFFF
     */
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(value) {
      this.shader.tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "texture", {
    /**
     * The texture that the Mesh uses.
     *
     * Null for non-MeshMaterial shaders
     * @member {PIXI.Texture}
     */
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(value) {
      this.shader.texture = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._render = function(renderer) {
    var vertices = this.geometry.buffers[0].data;
    var shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  };
  Mesh2.prototype._renderDefault = function(renderer) {
    var shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  };
  Mesh2.prototype._renderToBatch = function(renderer) {
    var geometry = this.geometry;
    var shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    var pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  };
  Mesh2.prototype.calculateVertices = function() {
    var geometry = this.geometry;
    var verticesBuffer = geometry.buffers[0];
    var vertices = verticesBuffer.data;
    var vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    for (var i = 0; i < vertexData.length / 2; i++) {
      var x = vertices[i * 2];
      var y = vertices[i * 2 + 1];
      vertexData[i * 2] = a * x + c * y + tx;
      vertexData[i * 2 + 1] = b * x + d * y + ty;
    }
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i = 0; i < vertexData.length; ++i) {
        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);
      }
    }
    this.vertexDirty = vertexDirtyId;
  };
  Mesh2.prototype.calculateUvs = function() {
    var geomUvs = this.geometry.buffers[1];
    var shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  };
  Mesh2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  };
  Mesh2.prototype.containsPoint = function(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    var vertices = this.geometry.getBuffer("aVertexPosition").data;
    var points = tempPolygon.points;
    var indices = this.geometry.getIndex().data;
    var len = indices.length;
    var step = this.drawMode === 4 ? 3 : 1;
    for (var i = 0; i + 2 < len; i += step) {
      var ind0 = indices[i] * 2;
      var ind1 = indices[i + 1] * 2;
      var ind2 = indices[i + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  };
  Mesh2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.geometry.refCount--;
    if (this.geometry.refCount === 0) {
      this.geometry.dispose();
    }
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  };
  Mesh2.BATCHABLE_SIZE = 100;
  return Mesh2;
}(Container);
var fragment = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = function(_super) {
  __extends(MeshMaterial2, _super);
  function MeshMaterial2(uSampler, options) {
    var _this = this;
    var uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    _this = _super.call(this, options.program || Program.from(vertex, fragment), uniforms) || this;
    _this._colorDirty = false;
    _this.uvMatrix = new TextureMatrix(uSampler);
    _this.batchable = options.program === void 0;
    _this.pluginName = options.pluginName;
    _this.tint = options.tint;
    _this.alpha = options.alpha;
    return _this;
  }
  Object.defineProperty(MeshMaterial2.prototype, "texture", {
    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(value) {
      if (this.uniforms.uSampler !== value) {
        this.uniforms.uSampler = value;
        this.uvMatrix.texture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    set: function(value) {
      if (value === this._alpha) {
        return;
      }
      this._alpha = value;
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    set: function(value) {
      if (value === this._tint) {
        return;
      }
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  MeshMaterial2.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = false;
      var baseTexture = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  };
  return MeshMaterial2;
}(Shader);
var MeshGeometry = function(_super) {
  __extends(MeshGeometry2, _super);
  function MeshGeometry2(vertices, uvs, index) {
    var _this = _super.call(this) || this;
    var verticesBuffer = new Buffer(vertices);
    var uvsBuffer = new Buffer(uvs, true);
    var indexBuffer = new Buffer(index, true, true);
    _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);
    _this._updateId = -1;
    return _this;
  }
  Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: false,
    configurable: true
  });
  return MeshGeometry2;
}(Geometry);

// pixi-graph/node_modules/@pixi/text-bitmap/dist/esm/text-bitmap.js
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var BitmapFontData = function() {
  function BitmapFontData2() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
  }
  return BitmapFontData2;
}();
var TextFormat = function() {
  function TextFormat2() {
  }
  TextFormat2.test = function(data) {
    return typeof data === "string" && data.indexOf("info face=") === 0;
  };
  TextFormat2.parse = function(txt) {
    var items = txt.match(/^[a-z]+\s+.+$/gm);
    var rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: []
    };
    for (var i in items) {
      var name = items[i].match(/^[a-z]+/gm)[0];
      var attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      var itemData = {};
      for (var i_1 in attributeList) {
        var split = attributeList[i_1].split("=");
        var key = split[0];
        var strValue = split[1].replace(/"/gm, "");
        var floatValue = parseFloat(strValue);
        var value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name].push(itemData);
    }
    var font = new BitmapFontData();
    rawData.info.forEach(function(info) {
      return font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      });
    });
    rawData.common.forEach(function(common) {
      return font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      });
    });
    rawData.page.forEach(function(page) {
      return font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      });
    });
    rawData.char.forEach(function(char) {
      return font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      });
    });
    rawData.kerning.forEach(function(kerning) {
      return font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      });
    });
    return font;
  };
  return TextFormat2;
}();
var XMLFormat = function() {
  function XMLFormat2() {
  }
  XMLFormat2.test = function(data) {
    return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
  };
  XMLFormat2.parse = function(xml) {
    var data = new BitmapFontData();
    var info = xml.getElementsByTagName("info");
    var common = xml.getElementsByTagName("common");
    var page = xml.getElementsByTagName("page");
    var char = xml.getElementsByTagName("char");
    var kerning = xml.getElementsByTagName("kerning");
    for (var i = 0; i < info.length; i++) {
      data.info.push({
        face: info[i].getAttribute("face"),
        size: parseInt(info[i].getAttribute("size"), 10)
      });
    }
    for (var i = 0; i < common.length; i++) {
      data.common.push({
        lineHeight: parseInt(common[i].getAttribute("lineHeight"), 10)
      });
    }
    for (var i = 0; i < page.length; i++) {
      data.page.push({
        id: parseInt(page[i].getAttribute("id"), 10) || 0,
        file: page[i].getAttribute("file")
      });
    }
    for (var i = 0; i < char.length; i++) {
      var letter = char[i];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (var i = 0; i < kerning.length; i++) {
      data.kerning.push({
        first: parseInt(kerning[i].getAttribute("first"), 10),
        second: parseInt(kerning[i].getAttribute("second"), 10),
        amount: parseInt(kerning[i].getAttribute("amount"), 10)
      });
    }
    return data;
  };
  return XMLFormat2;
}();
var XMLStringFormat = function() {
  function XMLStringFormat2() {
  }
  XMLStringFormat2.test = function(data) {
    if (typeof data === "string" && data.indexOf("<font>") > -1) {
      var xml = new self.DOMParser().parseFromString(data, "text/xml");
      return XMLFormat.test(xml);
    }
    return false;
  };
  XMLStringFormat2.parse = function(xmlTxt) {
    var xml = new self.DOMParser().parseFromString(xmlTxt, "text/xml");
    return XMLFormat.parse(xml);
  };
  return XMLStringFormat2;
}();
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (var i = 0; i < formats.length; i++) {
    if (formats[i].test(data)) {
      return formats[i];
    }
  }
  return null;
}
function generateFillStyle(canvas, context, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i = 1; i < lengthPlus1; ++i) {
      fillGradientStops.push(i / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i = 0; i < lines.length; i++) {
      var thisLineTop = metrics.lineHeight * i;
      for (var j = 0; j < fill.length; j++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j] === "number") {
          lineStop = fillGradientStops[j];
        } else {
          lineStop = j / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i = 0; i < fill.length; i++) {
      var stop = void 0;
      if (typeof fillGradientStops[i] === "number") {
        stop = fillGradientStops[i];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas, context, metrics, x, y, resolution, style) {
  var char = metrics.text;
  var fontProperties = metrics.fontProperties;
  context.translate(x, y);
  context.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context.font = style.toFontString();
  context.lineWidth = style.strokeThickness;
  context.textBaseline = style.textBaseline;
  context.lineJoin = style.lineJoin;
  context.miterLimit = style.miterLimit;
  context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);
  context.strokeStyle = style.stroke;
  var dropShadowColor = style.dropShadowColor;
  var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
  if (style.dropShadow) {
    context.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
    context.shadowBlur = style.dropShadowBlur;
    context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
    context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
  } else {
    context.shadowColor = "black";
    context.shadowBlur = 0;
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillStyle = "rgba(0, 0, 0, 0)";
}
function resolveCharacters(chars) {
  if (typeof chars === "string") {
    chars = [chars];
  }
  var result = [];
  for (var i = 0, j = chars.length; i < j; i++) {
    var item = chars[i];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, item.split(""));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var BitmapFont = function() {
  function BitmapFont2(data, textures, ownsTextures) {
    var info = data.info[0];
    var common = data.common[0];
    var page = data.page[0];
    var res = getResolutionOfUrl(page.file);
    var pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (var i = 0; i < data.page.length; i++) {
      var _a = data.page[i], id = _a.id, file = _a.file;
      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];
    }
    for (var i = 0; i < data.char.length; i++) {
      var _b = data.char[i], id = _b.id, page_1 = _b.page;
      var _c = data.char[i], x = _c.x, y = _c.y, width = _c.width, height = _c.height, xoffset = _c.xoffset, yoffset = _c.yoffset, xadvance = _c.xadvance;
      x /= res;
      y /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      var rect = new Rectangle(x + pageTextures[page_1].frame.x / res, y + pageTextures[page_1].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page_1].baseTexture, rect),
        page: page_1
      };
    }
    for (var i = 0; i < data.kerning.length; i++) {
      var _d = data.kerning[i], first = _d.first, second = _d.second, amount = _d.amount;
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
  }
  BitmapFont2.prototype.destroy = function() {
    for (var id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (var id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  };
  BitmapFont2.install = function(data, textures, ownsTextures) {
    var fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      var format = autoDetectFormat(data);
      if (!format) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    var font = new BitmapFont2(fontData, textures, ownsTextures);
    BitmapFont2.available[font.font] = font;
    return font;
  };
  BitmapFont2.uninstall = function(name) {
    var font = BitmapFont2.available[name];
    if (!font) {
      throw new Error("No font found named '" + name + "'");
    }
    font.destroy();
    delete BitmapFont2.available[name];
  };
  BitmapFont2.from = function(name, textStyle, options) {
    if (!name) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    var _a = Object.assign({}, BitmapFont2.defaultOptions, options), chars = _a.chars, padding = _a.padding, resolution = _a.resolution, textureWidth = _a.textureWidth, textureHeight = _a.textureHeight;
    var charsList = resolveCharacters(chars);
    var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    var lineWidth = textureWidth;
    var fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    var positionX = 0;
    var positionY = 0;
    var canvas;
    var context;
    var baseTexture;
    var maxCharHeight = 0;
    var textures = [];
    for (var i = 0; i < charsList.length; i++) {
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.width = textureWidth;
        canvas.height = textureHeight;
        context = canvas.getContext("2d");
        baseTexture = new BaseTexture(canvas, { resolution });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      var metrics = TextMetrics.measureText(charsList[i], style, false, canvas);
      var width = metrics.width;
      var height = Math.ceil(metrics.height);
      var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
        }
        --i;
        canvas = null;
        context = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        --i;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);
      var id = metrics.text.charCodeAt(0);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (var i = 0, len = charsList.length; i < len; i++) {
      var first = charsList[i];
      for (var j = 0; j < len; j++) {
        var second = charsList[j];
        var c1 = context.measureText(first).width;
        var c2 = context.measureText(second).width;
        var total = context.measureText(first + second).width;
        var amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: first.charCodeAt(0),
            second: second.charCodeAt(0),
            amount
          });
        }
      }
    }
    var font = new BitmapFont2(fontData, textures, true);
    if (BitmapFont2.available[name] !== void 0) {
      BitmapFont2.uninstall(name);
    }
    BitmapFont2.available[name] = font;
    return font;
  };
  BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont2.NUMERIC = [["0", "9"]];
  BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont2.ASCII = [[" ", "~"]];
  BitmapFont2.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: BitmapFont2.ALPHANUMERIC
  };
  BitmapFont2.available = {};
  return BitmapFont2;
}();
var pageMeshDataPool = [];
var charRenderDataPool = [];
var BitmapText = function(_super) {
  __extends2(BitmapText2, _super);
  function BitmapText2(text, style) {
    if (style === void 0) {
      style = {};
    }
    var _this = _super.call(this) || this;
    _this._tint = 16777215;
    var _a = Object.assign({}, BitmapText2.styleDefaults, style), align = _a.align, tint = _a.tint, maxWidth = _a.maxWidth, letterSpacing = _a.letterSpacing, fontName = _a.fontName, fontSize = _a.fontSize;
    if (!BitmapFont.available[fontName]) {
      throw new Error('Missing BitmapFont "' + fontName + '"');
    }
    _this._activePagesMeshData = [];
    _this._textWidth = 0;
    _this._textHeight = 0;
    _this._align = align;
    _this._tint = tint;
    _this._fontName = fontName;
    _this._fontSize = fontSize || BitmapFont.available[fontName].size;
    _this._text = text;
    _this._maxWidth = maxWidth;
    _this._maxLineHeight = 0;
    _this._letterSpacing = letterSpacing;
    _this._anchor = new ObservablePoint(function() {
      _this.dirty = true;
    }, _this, 0, 0);
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.dirty = true;
    _this._textureCache = {};
    return _this;
  }
  BitmapText2.prototype.updateText = function() {
    var _a;
    var data = BitmapFont.available[this._fontName];
    var scale = this._fontSize / data.size;
    var pos = new Point();
    var chars = [];
    var lineWidths = [];
    var lineSpaces = [];
    var text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    var textLength = text.length;
    var maxWidth = this._maxWidth * data.size / this._fontSize;
    var prevCharCode = null;
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var line = 0;
    var lastBreakPos = -1;
    var lastBreakWidth = 0;
    var spacesRemoved = 0;
    var maxLineHeight = 0;
    var spaceCount = 0;
    for (var i = 0; i < textLength; i++) {
      var charCode = text.charCodeAt(i);
      var char = text.charAt(i);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      var charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      var charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
      charRenderData.position.y = pos.y + charData.yOffset;
      charRenderData.prevSpaces = spaceCount;
      chars.push(charRenderData);
      lastLineWidth = charRenderData.position.x + charData.texture.orig.width;
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
        i = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    var lastChar = text.charAt(text.length - 1);
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    var lineAlignOffsets = [];
    for (var i = 0; i <= line; i++) {
      var alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];
      }
      lineAlignOffsets.push(alignOffset);
    }
    var lenChars = chars.length;
    var pagesMeshData = {};
    var newPagesMeshData = [];
    var activePagesMeshData = this._activePagesMeshData;
    for (var i = 0; i < activePagesMeshData.length; i++) {
      pageMeshDataPool.push(activePagesMeshData[i]);
    }
    for (var i = 0; i < lenChars; i++) {
      var texture = chars[i].texture;
      var baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        var pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          var geometry = new MeshGeometry();
          var material = new MeshMaterial(Texture.EMPTY);
          var mesh = new Mesh(geometry, material);
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        var _textureCache = this._textureCache;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tint;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (var i = 0; i < activePagesMeshData.length; i++) {
      if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {
        this.removeChild(activePagesMeshData[i].mesh);
      }
    }
    for (var i = 0; i < newPagesMeshData.length; i++) {
      if (newPagesMeshData[i].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      var total = pageMeshData.total;
      if (!(((_a = pageMeshData.indices) === null || _a === void 0 ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        var total_1 = pageMeshData.total;
        var vertices = pageMeshData.vertices;
        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
          vertices[i_1] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (var i = 0; i < lenChars; i++) {
      var char = chars[i];
      var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      var xPos = offset * scale;
      var yPos = char.position.y * scale;
      var texture = char.texture;
      var pageMesh = pagesMeshData[texture.baseTexture.uid];
      var textureFrame = texture.frame;
      var textureUvs = texture._uvs;
      var index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (var i in pagesMeshData) {
      var pageMeshData = pagesMeshData[i];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        var vertexCount = 0;
        var anchorOffsetX = this._textWidth * this.anchor.x;
        var anchorOffsetY = this._textHeight * this.anchor.y;
        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      var indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (var i = 0; i < chars.length; i++) {
      charRenderDataPool.push(chars[i]);
    }
  };
  BitmapText2.prototype.updateTransform = function() {
    this.validate();
    this.containerUpdateTransform();
  };
  BitmapText2.prototype.getLocalBounds = function() {
    this.validate();
    return _super.prototype.getLocalBounds.call(this);
  };
  BitmapText2.prototype.validate = function() {
    if (this.dirty) {
      this.updateText();
      this.dirty = false;
    }
  };
  Object.defineProperty(BitmapText2.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     *
     * @member {number}
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (this._tint === value) {
        return;
      }
      this._tint = value;
      for (var i = 0; i < this._activePagesMeshData.length; i++) {
        this._activePagesMeshData[i].mesh.tint = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     *
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "fontName", {
    /**
     * The name of the BitmapFont.
     *
     * @member {string}
     */
    get: function() {
      return this._fontName;
    },
    set: function(value) {
      if (!BitmapFont.available[value]) {
        throw new Error('Missing BitmapFont "' + value + '"');
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "fontSize", {
    /**
     * The size of the font to display.
     *
     * @member {number}
     */
    get: function() {
      return this._fontSize;
    },
    set: function(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * @member {PIXI.Point | number}
     */
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "text", {
    /**
     * The text of the BitmapText object.
     *
     * @member {string}
     */
    get: function() {
      return this._text;
    },
    set: function(text) {
      text = String(text === null || text === void 0 ? "" : text);
      if (this._text === text) {
        return;
      }
      this._text = text;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     *
     * @member {number}
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     *
     * @member {number}
     * @readonly
     */
    get: function() {
      this.validate();
      return this._maxLineHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     *
     * @member {number}
     * @readonly
     */
    get: function() {
      this.validate();
      return this._textWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "letterSpacing", {
    /**
     * Additional space between characters.
     *
     * @member {number}
     */
    get: function() {
      return this._letterSpacing;
    },
    set: function(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText2.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     *
     * @member {number}
     * @readonly
     */
    get: function() {
      this.validate();
      return this._textHeight;
    },
    enumerable: false,
    configurable: true
  });
  BitmapText2.prototype.destroy = function(options) {
    var _textureCache = this._textureCache;
    for (var id in _textureCache) {
      var texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._textureCache = null;
    _super.prototype.destroy.call(this, options);
  };
  BitmapText2.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  return BitmapText2;
}(Container);
var BitmapFontLoader = function() {
  function BitmapFontLoader2() {
  }
  BitmapFontLoader2.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  BitmapFontLoader2.use = function(resource, next) {
    var format = autoDetectFormat(resource.data);
    if (!format) {
      next();
      return;
    }
    var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
    var data = format.parse(resource.data);
    var textures = {};
    var completed = function(page) {
      textures[page.metadata.pageFile] = page.texture;
      if (Object.keys(textures).length === data.page.length) {
        resource.bitmapFont = BitmapFont.install(data, textures, true);
        next();
      }
    };
    for (var i = 0; i < data.page.length; ++i) {
      var pageFile = data.page[i].file;
      var url = baseUrl + pageFile;
      var exists = false;
      for (var name in this.resources) {
        var bitmapResource = this.resources[name];
        if (bitmapResource.url === url) {
          bitmapResource.metadata.pageFile = pageFile;
          if (bitmapResource.texture) {
            completed(bitmapResource);
          } else {
            bitmapResource.onAfterMiddleware.add(completed);
          }
          exists = true;
          break;
        }
      }
      if (!exists) {
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
          parentResource: resource
        };
        this.add(url, options, completed);
      }
    }
  };
  BitmapFontLoader2.getBaseUrl = function(loader, resource) {
    var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
    if (resource.isDataUrl) {
      if (resUrl === ".") {
        resUrl = "";
      }
      if (loader.baseUrl && resUrl) {
        if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
          resUrl += "/";
        }
      }
    }
    resUrl = resUrl.replace(loader.baseUrl, "");
    if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
      resUrl += "/";
    }
    return resUrl;
  };
  BitmapFontLoader2.dirname = function(url) {
    var dir = url.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    if (dir === url) {
      return ".";
    } else if (dir === "") {
      return "/";
    }
    return dir;
  };
  return BitmapFontLoader2;
}();
export {
  BitmapFont,
  BitmapFontData,
  BitmapFontLoader,
  BitmapText
};
/*! Bundled license information:

@pixi/mesh/dist/esm/mesh.js:
  (*!
   * @pixi/mesh - v6.1.2
   * Compiled Thu, 12 Aug 2021 17:11:19 UTC
   *
   * @pixi/mesh is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/text-bitmap/dist/esm/text-bitmap.js:
  (*!
   * @pixi/text-bitmap - v6.1.2
   * Compiled Thu, 12 Aug 2021 17:11:19 UTC
   *
   * @pixi/text-bitmap is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@pixi_text-bitmap.js.map
