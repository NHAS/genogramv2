import {
  Bounds,
  Container
} from "./chunk-Q4VYVUYK.js";
import {
  BaseTexture,
  BatchDrawCall,
  BatchGeometry,
  BatchTextureArray,
  Buffer,
  Geometry,
  Program,
  Shader,
  State,
  Texture,
  UniformGroup
} from "./chunk-QNDMGAQH.js";
import "./chunk-6IDTDDQ4.js";
import {
  hex2rgb,
  import_earcut,
  premultiplyTint
} from "./chunk-2J3TKREV.js";
import "./chunk-MITDHAZJ.js";
import {
  Circle,
  Ellipse,
  Matrix,
  PI_2,
  Point,
  Polygon,
  Rectangle,
  RoundedRectangle,
  SHAPES
} from "./chunk-R5PW3AE4.js";
import {
  BLEND_MODES,
  DRAW_MODES,
  TYPES,
  WRAP_MODES
} from "./chunk-4WFBNS3T.js";
import "./chunk-DFKQJ226.js";

// pixi-graph/node_modules/@pixi/graphics/dist/esm/graphics.js
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length || isNaN(length)) {
      return defaultSegments;
    }
    var result = Math.ceil(length / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = function() {
  function FillStyle3() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  FillStyle3.prototype.clone = function() {
    var obj = new FillStyle3();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  };
  FillStyle3.prototype.reset = function() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  };
  FillStyle3.prototype.destroy = function() {
    this.texture = null;
    this.matrix = null;
  };
  return FillStyle3;
}();
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (b2.hasOwnProperty(p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts2 = graphicsGeometry.points;
    var indices = graphicsGeometry.indices;
    if (points.length >= 6) {
      var holeArray = [];
      for (var i = 0; i < holes.length; i++) {
        var hole = holes[i];
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = (0, import_earcut.default)(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts2.length / 2;
      for (var i = 0; i < triangles.length; i += 3) {
        indices.push(triangles[i] + vertPos);
        indices.push(triangles[i + 1] + vertPos);
        indices.push(triangles[i + 2] + vertPos);
      }
      for (var i = 0; i < points.length; i++) {
        verts2.push(points[i]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var circleData = graphicsData.shape;
    var points = graphicsData.points;
    var x = circleData.x;
    var y = circleData.y;
    var width;
    var height;
    points.length = 0;
    if (graphicsData.type === SHAPES.CIRC) {
      width = circleData.radius;
      height = circleData.radius;
    } else {
      var ellipseData = graphicsData.shape;
      width = ellipseData.width;
      height = ellipseData.height;
    }
    if (width === 0 || height === 0) {
      return;
    }
    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width + height));
    totalSegs /= 2.3;
    var seg = Math.PI * 2 / totalSegs;
    for (var i = 0; i < totalSegs - 0.5; i++) {
      points.push(x + Math.sin(-seg * i) * width, y + Math.cos(-seg * i) * height);
    }
    points.push(points[0], points[1]);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts2 = graphicsGeometry.points;
    var indices = graphicsGeometry.indices;
    var vertPos = verts2.length / 2;
    var center = vertPos;
    var circle = graphicsData.shape;
    var matrix = graphicsData.matrix;
    var x = circle.x;
    var y = circle.y;
    verts2.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
    for (var i = 0; i < points.length; i += 2) {
      verts2.push(points[i], points[i + 1]);
      indices.push(vertPos++, center, vertPos);
    }
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x = rectData.x;
    var y = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x, y, x + width, y, x + width, y + height, x, y + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts2 = graphicsGeometry.points;
    var vertPos = verts2.length / 2;
    verts2.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n1, n2, perc) {
  var diff = n2 - n1;
  return n1 + diff * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n = 20;
  var points = out;
  var xa = 0;
  var ya = 0;
  var xb = 0;
  var yb = 0;
  var x = 0;
  var y = 0;
  for (var i = 0, j = 0; i <= n; ++i) {
    j = i / n;
    xa = getPt(fromX, cpX, j);
    ya = getPt(fromY, cpY, j);
    xb = getPt(cpX, toX, j);
    yb = getPt(cpY, toY, j);
    x = getPt(xa, xb, j);
    y = getPt(ya, yb, j);
    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {
      continue;
    }
    points.push(x, y);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x = rrectData.x;
    var y = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    } else {
      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts2 = graphicsGeometry.points;
    var indices = graphicsGeometry.indices;
    var vecPos = verts2.length / 2;
    var triangles = (0, import_earcut.default)(points, null, 2);
    for (var i = 0, j = triangles.length; i < j; i += 3) {
      indices.push(triangles[i] + vecPos);
      indices.push(triangles[i + 1] + vecPos);
      indices.push(triangles[i + 2] + vecPos);
    }
    for (var i = 0, j = points.length; i < j; i++) {
      verts2.push(points[i], points[++i]);
    }
  }
};
function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts2) {
  var ix = x - nx * innerWeight;
  var iy = y - ny * innerWeight;
  var ox = x + nx * outerWeight;
  var oy = y + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts2.push(eix, eiy);
  verts2.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts2, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts2.push(cx, cy);
    verts2.push(sx, sy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts2.push(cx, cy);
      verts2.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts2.push(cx, cy);
    verts2.push(ex, ey);
  } else {
    verts2.push(sx, sy);
    verts2.push(cx, cy);
    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts2.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts2.push(cx, cy);
    }
    verts2.push(ex, ey);
    verts2.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts2 = graphicsGeometry.points;
  var length = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts2.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts2, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts2);
    }
  }
  verts2.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts2.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 0.1) {
      verts2.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts2.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts2.push(imx, imy);
          verts2.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts2.push(imx, imy);
          verts2.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts2.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts2.push(omx, omy);
          verts2.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts2.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts2.push(imx, imy);
          verts2.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts2, true) + 4;
          verts2.push(imx, imy);
          verts2.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts2.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts2.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts2, false) + 4;
          verts2.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts2.push(omx, omy);
        }
      } else {
        verts2.push(imx, imy);
        verts2.push(omx, omy);
      }
    } else {
      verts2.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts2.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)
        ;
      else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts2, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts2, false) + 2;
        }
      } else {
        if (clockwise) {
          verts2.push(omx, omy);
          verts2.push(omx, omy);
        } else {
          verts2.push(imx, imy);
          verts2.push(imx, imy);
        }
        indexCount += 2;
      }
      verts2.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts2.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts2.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts2.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts2, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts2);
    }
  }
  var indices = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts2[i * 2];
    y0 = verts2[i * 2 + 1];
    x1 = verts2[(i + 1) * 2];
    y1 = verts2[(i + 1) * 2 + 1];
    x2 = verts2[(i + 2) * 2];
    y2 = verts2[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts2 = graphicsGeometry.points;
  var indices = graphicsGeometry.indices;
  var length = points.length / 2;
  var startIndex = verts2.length / 2;
  var currentIndex = startIndex;
  verts2.push(points[0], points[1]);
  for (i = 1; i < length; i++) {
    verts2.push(points[i * 2], points[i * 2 + 1]);
    indices.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = function() {
  function ArcUtils3() {
  }
  ArcUtils3.curveTo = function(x1, y1, x2, y2, radius, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2 - y1;
    var b2 = x2 - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    var dd = a1 * a1 + b1 * b1;
    var cc = a2 * a2 + b2 * b2;
    var tt = a1 * a2 + b1 * b2;
    var k1 = radius * Math.sqrt(dd) / mm;
    var k2 = radius * Math.sqrt(cc) / mm;
    var j1 = k1 * tt / dd;
    var j2 = k2 * tt / cc;
    var cx = k1 * b2 + k2 * b1;
    var cy = k1 * a2 + k2 * a1;
    var px = b1 * (k2 + j1);
    var py = a1 * (k2 + j1);
    var qx = b2 * (k1 + j2);
    var qy = a2 * (k1 + j2);
    var startAngle = Math.atan2(py - cy, px - cx);
    var endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  };
  ArcUtils3.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    var sweep = endAngle - startAngle;
    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    var theta = sweep / (n * 2);
    var theta2 = theta * 2;
    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    var segMinus = n - 1;
    var remainder = segMinus % 1 / segMinus;
    for (var i = 0; i <= segMinus; ++i) {
      var real = i + remainder * i;
      var angle = theta + startAngle + theta2 * real;
      var c = Math.cos(angle);
      var s = -Math.sin(angle);
      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
    }
  };
  return ArcUtils3;
}();
var BezierUtils = function() {
  function BezierUtils3() {
  }
  BezierUtils3.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var n = 10;
    var result = 0;
    var t = 0;
    var t2 = 0;
    var t3 = 0;
    var nt = 0;
    var nt2 = 0;
    var nt3 = 0;
    var x = 0;
    var y = 0;
    var dx = 0;
    var dy = 0;
    var prevX = fromX;
    var prevY = fromY;
    for (var i = 1; i <= n; ++i) {
      t = i / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x;
      dy = prevY - y;
      prevX = x;
      prevY = y;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  };
  BezierUtils3.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    points.length -= 2;
    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils3.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;
    points.push(fromX, fromY);
    for (var i = 1, j = 0; i <= n; ++i) {
      j = i / n;
      dt = 1 - j;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j * j;
      t3 = t2 * j;
      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  };
  return BezierUtils3;
}();
var QuadraticUtils = function() {
  function QuadraticUtils3() {
  }
  QuadraticUtils3.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
    var ax = fromX - 2 * cpX + toX;
    var ay = fromY - 2 * cpY + toY;
    var bx = 2 * cpX - 2 * fromX;
    var by = 2 * cpY - 2 * fromY;
    var a = 4 * (ax * ax + ay * ay);
    var b = 4 * (ax * bx + ay * by);
    var c = bx * bx + by * by;
    var s = 2 * Math.sqrt(a + b + c);
    var a2 = Math.sqrt(a);
    var a32 = 2 * a * a2;
    var c2 = 2 * Math.sqrt(c);
    var ba = b / a2;
    return (a32 * s + a2 * b * (s - c2) + (4 * c * a - b * b) * Math.log((2 * a2 + ba + s) / (ba + c2))) / (4 * a32);
  };
  QuadraticUtils3.curveTo = function(cpX, cpY, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils3.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    var xa = 0;
    var ya = 0;
    for (var i = 1; i <= n; ++i) {
      var j = i / n;
      xa = fromX + (cpX - fromX) * j;
      ya = fromY + (cpY - fromY) * j;
      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
    }
  };
  return QuadraticUtils3;
}();
var BatchPart = function() {
  function BatchPart3() {
    this.reset();
  }
  BatchPart3.prototype.begin = function(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  };
  BatchPart3.prototype.end = function(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  };
  BatchPart3.prototype.reset = function() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  };
  return BatchPart3;
}();
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
function isPolygonClockwise(polygon) {
  var points = polygon.points;
  var sum = 0;
  for (var i = 0; i < points.length - 2; i += 2) {
    sum += (points[i + 2] - points[i]) * (points[i + 3] + points[i + 1]);
  }
  return sum > 0;
}
var GraphicsData = function() {
  function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  GraphicsData2.prototype.clone = function() {
    return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  };
  GraphicsData2.prototype.destroy = function() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  };
  return GraphicsData2;
}();
var tmpPoint = new Point();
var tmpBounds = new Bounds();
var GraphicsGeometry = function(_super) {
  __extends(GraphicsGeometry2, _super);
  function GraphicsGeometry2() {
    var _this = _super.call(this) || this;
    _this.closePointEps = 1e-4;
    _this.boundsPadding = 0;
    _this.uvsFloat32 = null;
    _this.indicesUint16 = null;
    _this.batchable = false;
    _this.points = [];
    _this.colors = [];
    _this.uvs = [];
    _this.indices = [];
    _this.textureIds = [];
    _this.graphicsData = [];
    _this.drawCalls = [];
    _this.batchDirty = -1;
    _this.batches = [];
    _this.dirty = 0;
    _this.cacheDirty = -1;
    _this.clearDirty = 0;
    _this.shapeIndex = 0;
    _this._bounds = new Bounds();
    _this.boundsDirty = -1;
    return _this;
  }
  Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get: function() {
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    },
    enumerable: false,
    configurable: true
  });
  GraphicsGeometry2.prototype.invalidate = function() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (var i = 0; i < this.batches.length; i++) {
      var batchPart = this.batches[i];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  };
  GraphicsGeometry2.prototype.clear = function() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  };
  GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    if (!this.graphicsData.length) {
      return null;
    }
    var data = new GraphicsData(shape, null, null, matrix);
    var lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    for (var i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  };
  GraphicsGeometry2.prototype.containsPoint = function(point) {
    var graphicsData = this.graphicsData;
    for (var i = 0; i < graphicsData.length; ++i) {
      var data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          var hitHole = false;
          if (data.holes) {
            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
              var hole = data.holes[i_1];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  };
  GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    var uvs = this.uvs;
    var graphicsData = this.graphicsData;
    var batchPart = null;
    var currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (var i = this.shapeIndex; i < graphicsData.length; i++) {
      this.shapeIndex++;
      var data = graphicsData[i];
      var fillStyle = data.fillStyle;
      var lineStyle = data.lineStyle;
      var command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      for (var j = 0; j < 2; j++) {
        var style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible) {
          continue;
        }
        var nextTexture = style.texture.baseTexture;
        var index_1 = this.indices.length;
        var attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        var size = this.points.length / 2 - attribIndex;
        if (size === 0) {
          continue;
        }
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index_1, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index_1, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    var index = this.indices.length;
    var attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
      this.indicesUint16.set(this.indices);
    } else {
      var need32 = attrib > 65535 && allow32Indices;
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  };
  GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  };
  GraphicsGeometry2.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (var i = 0, l = this.graphicsData.length; i < l; i++) {
      var data = this.graphicsData[i];
      var fill = data.fillStyle;
      var line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid) {
        return false;
      }
      if (line && !line.texture.baseTexture.valid) {
        return false;
      }
    }
    return true;
  };
  GraphicsGeometry2.prototype.packBatches = function() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    var batches = this.batches;
    for (var i = 0, l = batches.length; i < l; i++) {
      var batch = batches[i];
      for (var j = 0; j < batch.size; j++) {
        var index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  };
  GraphicsGeometry2.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    var batches = this.batches;
    for (var i = 0; i < batches.length; i++) {
      if (batches[i].style.native) {
        return false;
      }
    }
    return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
  };
  GraphicsGeometry2.prototype.buildDrawCalls = function() {
    var TICK = ++BaseTexture._globalBatch;
    for (var i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES.TRIANGLES;
    var textureCount = 0;
    var currentTexture = null;
    var textureId = 0;
    var native = false;
    var drawMode = DRAW_MODES.TRIANGLES;
    var index = 0;
    this.drawCalls.push(currentGroup);
    for (var i = 0; i < this.batches.length; i++) {
      var data = this.batches[i];
      var MAX_TEXTURES = 8;
      var style = data.style;
      var nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;
        currentTexture = null;
        textureCount = MAX_TEXTURES;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === MAX_TEXTURES) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  };
  GraphicsGeometry2.prototype.packAttributes = function() {
    var verts2 = this.points;
    var uvs = this.uvs;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var glPoints = new ArrayBuffer(verts2.length * 3 * 4);
    var f32 = new Float32Array(glPoints);
    var u32 = new Uint32Array(glPoints);
    var p = 0;
    for (var i = 0; i < verts2.length / 2; i++) {
      f32[p++] = verts2[i * 2];
      f32[p++] = verts2[i * 2 + 1];
      f32[p++] = uvs[i * 2];
      f32[p++] = uvs[i * 2 + 1];
      u32[p++] = colors[i];
      f32[p++] = textureIds[i];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  };
  GraphicsGeometry2.prototype.processFill = function(data) {
    if (data.holes.length) {
      this.processHoles(data.holes);
      buildPoly.triangulate(data, this);
    } else {
      var command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  };
  GraphicsGeometry2.prototype.processLine = function(data) {
    buildLine(data, this);
    for (var i = 0; i < data.holes.length; i++) {
      buildLine(data.holes[i], this);
    }
  };
  GraphicsGeometry2.prototype.processHoles = function(holes) {
    for (var i = 0; i < holes.length; i++) {
      var hole = holes[i];
      var command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  };
  GraphicsGeometry2.prototype.calculateBounds = function() {
    var bounds = this._bounds;
    var sequenceBounds = tmpBounds;
    var curMatrix = Matrix.IDENTITY;
    this._bounds.clear();
    sequenceBounds.clear();
    for (var i = 0; i < this.graphicsData.length; i++) {
      var data = this.graphicsData[i];
      var shape = data.shape;
      var type = data.type;
      var lineStyle = data.lineStyle;
      var nextMatrix = data.matrix || Matrix.IDENTITY;
      var lineWidth = 0;
      if (lineStyle && lineStyle.visible) {
        var alignment = lineStyle.alignment;
        lineWidth = lineStyle.width;
        if (type === SHAPES.POLY) {
          if (isPolygonClockwise(shape)) {
            lineWidth = lineWidth * (1 - alignment);
          } else {
            lineWidth = lineWidth * alignment;
          }
        } else {
          lineWidth = lineWidth * Math.max(0, alignment);
        }
      }
      if (curMatrix !== nextMatrix) {
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
          sequenceBounds.clear();
        }
        curMatrix = nextMatrix;
      }
      if (type === SHAPES.RECT || type === SHAPES.RREC) {
        var rect = shape;
        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
      } else if (type === SHAPES.CIRC) {
        var circle = shape;
        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
      } else if (type === SHAPES.ELIP) {
        var ellipse = shape;
        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
      } else {
        var poly = shape;
        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
      }
    }
    if (!sequenceBounds.isEmpty()) {
      bounds.addBoundsMatrix(sequenceBounds, curMatrix);
    }
    bounds.pad(this.boundsPadding, this.boundsPadding);
  };
  GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
    for (var i = 0; i < points.length / 2; i++) {
      var x = points[i * 2];
      var y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  };
  GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
    var rgba = premultiplyTint(rgb, alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (var i = 0; i < size; i++) {
      colors[offset + i] = rgba;
    }
  };
  GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (var i = 0; i < size; i++) {
      textureIds[offset + i] = id;
    }
  };
  GraphicsGeometry2.prototype.addUvs = function(verts2, uvs, texture, start, size, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    var index = 0;
    var uvsStart = uvs.length;
    var frame = texture.frame;
    while (index < size) {
      var x = verts2[(start + index) * 2];
      var y = verts2[(start + index) * 2 + 1];
      if (matrix) {
        var nx = matrix.a * x + matrix.c * y + matrix.tx;
        y = matrix.b * x + matrix.d * y + matrix.ty;
        x = nx;
      }
      index++;
      uvs.push(x / frame.width, y / frame.height);
    }
    var baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  };
  GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
    var baseTexture = texture.baseTexture;
    var eps = 1e-6;
    var finish = start + size * 2;
    var frame = texture.frame;
    var scaleX = frame.width / baseTexture.width;
    var scaleY = frame.height / baseTexture.height;
    var offsetX = frame.x / frame.width;
    var offsetY = frame.y / frame.height;
    var minX = Math.floor(uvs[start] + eps);
    var minY = Math.floor(uvs[start + 1] + eps);
    for (var i = start + 2; i < finish; i += 2) {
      minX = Math.min(minX, Math.floor(uvs[i] + eps));
      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (var i = start; i < finish; i += 2) {
      uvs[i] = (uvs[i] + offsetX) * scaleX;
      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;
    }
  };
  GraphicsGeometry2.BATCHABLE_SIZE = 100;
  return GraphicsGeometry2;
}(BatchGeometry);
var LineStyle = function(_super) {
  __extends(LineStyle3, _super);
  function LineStyle3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.width = 0;
    _this.alignment = 0.5;
    _this.native = false;
    _this.cap = LINE_CAP.BUTT;
    _this.join = LINE_JOIN.MITER;
    _this.miterLimit = 10;
    return _this;
  }
  LineStyle3.prototype.clone = function() {
    var obj = new LineStyle3();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  };
  LineStyle3.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  };
  return LineStyle3;
}(FillStyle);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = function(_super) {
  __extends(Graphics2, _super);
  function Graphics2(geometry) {
    if (geometry === void 0) {
      geometry = null;
    }
    var _this = _super.call(this) || this;
    _this.shader = null;
    _this.pluginName = "batch";
    _this.currentPath = null;
    _this.batches = [];
    _this.batchTint = -1;
    _this.batchDirty = -1;
    _this.vertexData = null;
    _this._fillStyle = new FillStyle();
    _this._lineStyle = new LineStyle();
    _this._matrix = null;
    _this._holeMode = false;
    _this.state = State.for2d();
    _this._geometry = geometry || new GraphicsGeometry();
    _this._geometry.refCount++;
    _this._transformID = -1;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES.NORMAL;
    return _this;
  }
  Object.defineProperty(Graphics2.prototype, "geometry", {
    /**
     * Includes vertex positions, face indices, normals, colors, UVs, and
     * custom attributes within buffers, reducing the cost of passing all
     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
     *
     * @member {PIXI.GraphicsGeometry}
     * @readonly
     */
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.clone = function() {
    this.finishPoly();
    return new Graphics2(this._geometry);
  };
  Object.defineProperty(Graphics2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
     * primitive in the GraphicsGeometry list is rendered sequentially, modes
     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
     * be applied per-primitive.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "tint", {
    /**
     * The tint applied to each graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "fill", {
    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    get: function() {
      return this._fillStyle;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "line", {
    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    get: function() {
      return this._lineStyle;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {
    if (options === void 0) {
      options = null;
    }
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    if (alignment === void 0) {
      alignment = 0.5;
    }
    if (native === void 0) {
      native = false;
    }
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  };
  Graphics2.prototype.lineTextureStyle = function(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.startPoly = function() {
    if (this.currentPath) {
      var points = this.currentPath.points;
      var len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  };
  Graphics2.prototype.finishPoly = function() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  };
  Graphics2.prototype.moveTo = function(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  };
  Graphics2.prototype.lineTo = function(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    var points = this.currentPath.points;
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  };
  Graphics2.prototype._initCurve = function(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  };
  Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
    this._initCurve();
    var points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  };
  Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  };
  Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    var points = this.currentPath.points;
    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
    }
    return this;
  };
  Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    var sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    var eps = this._geometry.closePointEps;
    var points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      var xDiff = Math.abs(points[points.length - 2] - startX);
      var yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  };
  Graphics2.prototype.beginFill = function(color, alpha) {
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  };
  Graphics2.prototype.beginTextureFill = function(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.endFill = function() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  };
  Graphics2.prototype.drawRect = function(x, y, width, height) {
    return this.drawShape(new Rectangle(x, y, width, height));
  };
  Graphics2.prototype.drawRoundedRect = function(x, y, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
  };
  Graphics2.prototype.drawCircle = function(x, y, radius) {
    return this.drawShape(new Circle(x, y, radius));
  };
  Graphics2.prototype.drawEllipse = function(x, y, width, height) {
    return this.drawShape(new Ellipse(x, y, width, height));
  };
  Graphics2.prototype.drawPolygon = function() {
    var arguments$1 = arguments;
    var path = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      path[_i] = arguments$1[_i];
    }
    var points;
    var closeStroke = true;
    var poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    var shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  };
  Graphics2.prototype.drawShape = function(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  };
  Graphics2.prototype.clear = function() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  };
  Graphics2.prototype.isFastRect = function() {
    var data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  };
  Graphics2.prototype._render = function(renderer) {
    this.finishPoly();
    var geometry = this._geometry;
    var hasuint32 = renderer.context.supports.uint32Indices;
    geometry.updateBatches(hasuint32);
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  };
  Graphics2.prototype._populateBatches = function() {
    var geometry = this._geometry;
    var blendMode = this.blendMode;
    var len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (var i = 0; i < len; i++) {
      var gI = geometry.batches[i];
      var color = gI.style.color;
      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      var batch = {
        vertexData,
        blendMode,
        indices,
        uvs,
        _batchRGB: hex2rgb(color),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  };
  Graphics2.prototype._renderBatched = function(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (var i = 0, l = this.batches.length; i < l; i++) {
      var batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  };
  Graphics2.prototype._renderDirect = function(renderer) {
    var shader = this._resolveDirectShader(renderer);
    var geometry = this._geometry;
    var tint = this.tint;
    var worldAlpha = this.worldAlpha;
    var uniforms = shader.uniforms;
    var drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
    uniforms.tint[3] = worldAlpha;
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (var i = 0, l = drawCalls.length; i < l; i++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
    }
  };
  Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
    var texArray = drawCall.texArray, type = drawCall.type, size = drawCall.size, start = drawCall.start;
    var groupTextureCount = texArray.count;
    for (var j = 0; j < groupTextureCount; j++) {
      renderer.texture.bind(texArray.elements[j], j);
    }
    renderer.geometry.draw(type, size, start);
  };
  Graphics2.prototype._resolveDirectShader = function(renderer) {
    var shader = this.shader;
    var pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;
        var sampleValues = new Int32Array(MAX_TEXTURES);
        for (var i = 0; i < MAX_TEXTURES; i++) {
          sampleValues[i] = i;
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        var program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  };
  Graphics2.prototype._calculateBounds = function() {
    this.finishPoly();
    var geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    var _a2 = geometry.bounds, minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  Graphics2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
    return this._geometry.containsPoint(Graphics2._TEMP_POINT);
  };
  Graphics2.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      var tintRGB = hex2rgb(this.tint, temp);
      for (var i = 0; i < this.batches.length; i++) {
        var batch = this.batches[i];
        var batchTint = batch._batchRGB;
        var r = tintRGB[0] * batchTint[0] * 255;
        var g = tintRGB[1] * batchTint[1] * 255;
        var b = tintRGB[2] * batchTint[2] * 255;
        var color = (r << 16) + (g << 8) + (b | 0);
        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      }
    }
  };
  Graphics2.prototype.calculateVertices = function() {
    var wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    var wt = this.transform.worldTransform;
    var a = wt.a;
    var b = wt.b;
    var c = wt.c;
    var d = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var data = this._geometry.points;
    var vertexData = this.vertexData;
    var count = 0;
    for (var i = 0; i < data.length; i += 2) {
      var x = data[i];
      var y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  };
  Graphics2.prototype.closePath = function() {
    var currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  };
  Graphics2.prototype.setMatrix = function(matrix) {
    this._matrix = matrix;
    return this;
  };
  Graphics2.prototype.beginHole = function() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  };
  Graphics2.prototype.endHole = function() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  };
  Graphics2.prototype.destroy = function(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    _super.prototype.destroy.call(this, options);
  };
  Graphics2._TEMP_POINT = new Point();
  return Graphics2;
}(Container);
var graphicsUtils = {
  buildPoly,
  buildCircle,
  buildRectangle,
  buildRoundedRectangle,
  buildLine,
  ArcUtils,
  BezierUtils,
  QuadraticUtils,
  BatchPart,
  FILL_COMMANDS,
  BATCH_POOL,
  DRAW_CALL_POOL
};

// pixi-graph/node_modules/@pixi/graphics-smooth/lib/pixi-graphics-smooth.es.js
function matrixEquals(th, matrix, eps = 1e-3) {
  return this === matrix || Math.abs(th.a - matrix.a) < eps && Math.abs(th.b - matrix.b) < eps && Math.abs(th.c - matrix.c) < eps && Math.abs(th.d - matrix.d) < eps && Math.abs(th.tx - matrix.tx) < eps && Math.abs(th.ty - matrix.ty) < eps;
}
var BatchStyleArray = class {
  constructor() {
    this.textureIds = [];
    this.matrices = [];
    this.lines = [];
    this.count = 0;
  }
  clear() {
    for (let i = 0; i < this.count; i++) {
      this.textureIds[i] = null;
      this.matrices[i] = null;
    }
    this.count = 0;
  }
  add(textureId, matrix, lineWidth, lineAlignment, settings2) {
    const { textureIds, matrices, lines, count } = this;
    for (let i = 0; i < count; i++) {
      if (lines[i * 2] === lineWidth && lines[i * 2 + 1] === lineAlignment && textureIds[i] === textureId && matrixEquals(matrices[i], matrix)) {
        return i;
      }
    }
    if (count >= settings2.maxStyles) {
      return -1;
    }
    textureIds[count] = textureId;
    matrices[count] = matrix;
    lines[count * 2] = lineWidth;
    lines[count * 2 + 1] = lineAlignment;
    this.count++;
    return count;
  }
};
var BatchDrawCall2 = class {
  constructor() {
    this.texArray = new BatchTextureArray();
    this.styleArray = new BatchStyleArray();
    this.shader = null;
    this.blend = BLEND_MODES.NORMAL;
    this.start = 0;
    this.size = 0;
    this.TICK = 0;
    this.settings = null;
    this.data = null;
  }
  clear() {
    this.texArray.clear();
    this.styleArray.clear();
    this.settings = null;
    this.data = null;
    this.shader = null;
  }
  begin(settings2, shader) {
    this.TICK = ++BaseTexture._globalBatch;
    this.settings = settings2;
    this.shader = shader;
    this.start = 0;
    this.size = 0;
    this.data = null;
    if (shader && shader.settings) {
      this.settings = shader.settings;
    }
  }
  check(shader) {
    if (this.size === 0) {
      this.shader = shader;
      return true;
    }
    return this.shader === shader;
  }
  add(texture, matrix, lineWidth, lineAlignment) {
    const { texArray, TICK, styleArray, settings: settings2 } = this;
    const { baseTexture } = texture;
    if (baseTexture._batchEnabled !== TICK && texArray.count === settings2.maxTextures) {
      return -1;
    }
    const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;
    const res = styleArray.add(loc, matrix || Matrix.IDENTITY, lineWidth, lineAlignment, settings2);
    if (res >= 0) {
      if (baseTexture._batchEnabled !== TICK) {
        baseTexture._batchEnabled = TICK;
        baseTexture._batchLocation = texArray.count;
        texArray.elements[texArray.count++] = baseTexture;
      }
    }
    return res;
  }
};
var BatchPart2 = class {
  constructor() {
    this.reset();
  }
  begin(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
    this.jointEnd = 0;
  }
  end(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  }
  reset() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
    this.styleId = -1;
    this.rgba = 0;
    this.jointEnd = 0;
  }
};
var FillStyle2 = class {
  constructor() {
    this.reset();
  }
  toJSON() {
    return this.copyTo({});
  }
  clone() {
    return this.copyTo(new FillStyle2());
  }
  copyTo(obj) {
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.shader = this.shader;
    obj.visible = this.visible;
    obj.smooth = this.smooth;
    obj.matrixTex = null;
    return obj;
  }
  /**
   * returns width multiplied by scaleMode
   */
  packLineWidth() {
    return 0;
  }
  reset() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.shader = null;
    this.visible = false;
    this.smooth = false;
    this.matrixTex = null;
  }
  destroy() {
    this.texture = null;
    this.matrix = null;
    this.matrixTex = null;
  }
  getTextureMatrix() {
    const tex = this.texture;
    if (!this.matrix) {
      return null;
    }
    if (tex.frame.width === tex.baseTexture.width && tex.frame.height === tex.baseTexture.height) {
      return this.matrix;
    }
    if (!this.matrixTex) {
      this.matrixTex = this.matrix.clone();
    } else {
      this.matrixTex.copyFrom(this.matrix);
    }
    this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));
    return this.matrixTex;
  }
};
var LINE_SCALE_MODE;
(function(LINE_SCALE_MODE2) {
  const NONE = "none";
  LINE_SCALE_MODE2["NONE"] = NONE;
  const NORMAL = "normal";
  LINE_SCALE_MODE2["NORMAL"] = NORMAL;
})(LINE_SCALE_MODE || (LINE_SCALE_MODE = {}));
var LineStyle2 = class extends FillStyle2 {
  clone() {
    return this.copyTo(new LineStyle2());
  }
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  copyTo(obj) {
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.shader = this.shader;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    obj.scaleMode = this.scaleMode;
    return obj;
  }
  /**
   * returns width multiplied by scaleMode
   */
  packLineWidth() {
    return this.scaleMode === LINE_SCALE_MODE.NORMAL ? this.width : -this.width;
  }
  reset() {
    super.reset();
    this.smooth = true;
    this.color = 0;
    this.width = 0;
    this.alignment = 0.5;
    this.cap = LINE_CAP.BUTT;
    this.join = LINE_JOIN.MITER;
    this.miterLimit = 10;
    this.scaleMode = LINE_SCALE_MODE.NORMAL;
  }
};
var BuildData = class {
  constructor() {
    BuildData.prototype.__init.call(this);
    BuildData.prototype.__init2.call(this);
    BuildData.prototype.__init3.call(this);
    BuildData.prototype.__init4.call(this);
    BuildData.prototype.__init5.call(this);
  }
  __init() {
    this.verts = [];
  }
  __init2() {
    this.joints = [];
  }
  __init3() {
    this.vertexSize = 0;
  }
  __init4() {
    this.indexSize = 0;
  }
  __init5() {
    this.closePointEps = 1e-4;
  }
  clear() {
    this.verts.length = 0;
    this.joints.length = 0;
    this.vertexSize = 0;
    this.indexSize = 0;
  }
  destroy() {
    this.verts.length = 0;
    this.joints.length = 0;
  }
};
var JOINT_TYPE;
(function(JOINT_TYPE2) {
  const NONE = 0;
  JOINT_TYPE2[JOINT_TYPE2["NONE"] = NONE] = "NONE";
  const FILL = 1;
  JOINT_TYPE2[JOINT_TYPE2["FILL"] = FILL] = "FILL";
  const JOINT_BEVEL = 4;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_BEVEL"] = JOINT_BEVEL] = "JOINT_BEVEL";
  const JOINT_MITER = 8;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_MITER"] = JOINT_MITER] = "JOINT_MITER";
  const JOINT_ROUND = 12;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_ROUND"] = JOINT_ROUND] = "JOINT_ROUND";
  const JOINT_CAP_BUTT = 16;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_BUTT"] = JOINT_CAP_BUTT] = "JOINT_CAP_BUTT";
  const JOINT_CAP_SQUARE = 18;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_SQUARE"] = JOINT_CAP_SQUARE] = "JOINT_CAP_SQUARE";
  const JOINT_CAP_ROUND = 20;
  JOINT_TYPE2[JOINT_TYPE2["JOINT_CAP_ROUND"] = JOINT_CAP_ROUND] = "JOINT_CAP_ROUND";
  const FILL_EXPAND = 24;
  JOINT_TYPE2[JOINT_TYPE2["FILL_EXPAND"] = FILL_EXPAND] = "FILL_EXPAND";
  const CAP_BUTT = 1 << 5;
  JOINT_TYPE2[JOINT_TYPE2["CAP_BUTT"] = CAP_BUTT] = "CAP_BUTT";
  const CAP_SQUARE = 2 << 5;
  JOINT_TYPE2[JOINT_TYPE2["CAP_SQUARE"] = CAP_SQUARE] = "CAP_SQUARE";
  const CAP_ROUND = 3 << 5;
  JOINT_TYPE2[JOINT_TYPE2["CAP_ROUND"] = CAP_ROUND] = "CAP_ROUND";
  const CAP_BUTT2 = 4 << 5;
  JOINT_TYPE2[JOINT_TYPE2["CAP_BUTT2"] = CAP_BUTT2] = "CAP_BUTT2";
})(JOINT_TYPE || (JOINT_TYPE = {}));
var SegmentPacker = class {
  constructor() {
    SegmentPacker.prototype.__init.call(this);
    SegmentPacker.prototype.__init2.call(this);
    SegmentPacker.prototype.__init3.call(this);
  }
  static __initStatic() {
    this.vertsByJoint = [];
  }
  __init() {
    this.strideFloats = 12;
  }
  updateBufferSize(jointStart, jointLen, triangles, target) {
    const { joints } = target;
    let foundTriangle = false;
    let vertexSize = 0;
    let indexSize = 0;
    for (let i = jointStart; i < jointStart + jointLen; i++) {
      const prevCap = joints[i] & ~31;
      const joint = joints[i] & 31;
      if (joint === JOINT_TYPE.FILL) {
        foundTriangle = true;
        vertexSize++;
        continue;
      }
      if (joint >= JOINT_TYPE.FILL_EXPAND) {
        vertexSize += 3;
        indexSize += 3;
        continue;
      }
      const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];
      if (vs >= 4) {
        vertexSize += vs;
        indexSize += 6 + 3 * Math.max(vs - 6, 0);
      }
    }
    if (foundTriangle) {
      indexSize += triangles;
    }
    target.vertexSize += vertexSize;
    target.indexSize += indexSize;
  }
  __init2() {
    this.bufferPos = 0;
  }
  __init3() {
    this.indexPos = 0;
  }
  beginPack(buildData, bufFloat, bufUint, indices, bufferPos = 0, indexPos = 0) {
    this.buildData = buildData;
    this.bufFloat = bufFloat;
    this.bufUint = bufUint;
    this.indices = indices;
    this.bufferPos = bufferPos;
    this.indexPos = indexPos;
  }
  endPack() {
    this.buildData = null;
    this.bufFloat = null;
    this.bufUint = null;
    this.indices = null;
  }
  packInterleavedGeometry(jointStart, jointLen, triangles, lineStyle, color) {
    const { bufFloat, bufUint, indices, buildData, strideFloats } = this;
    const { joints, verts: verts2 } = buildData;
    let bufPos = this.bufferPos;
    let indPos = this.indexPos;
    let index = this.bufferPos / this.strideFloats;
    let x1;
    let y1;
    let x2;
    let y2;
    let prevX;
    let prevY;
    let nextX;
    let nextY;
    let hasTriangle = false;
    let travel = 0;
    for (let j = jointStart; j < jointStart + jointLen; j++) {
      const fullJoint = joints[j];
      const prevCap = joints[j] & ~31;
      const joint = joints[j] & 31;
      if (joint === JOINT_TYPE.FILL) {
        hasTriangle = true;
        x1 = verts2[j * 2];
        y1 = verts2[j * 2 + 1];
        bufFloat[bufPos] = x1;
        bufFloat[bufPos + 1] = y1;
        bufFloat[bufPos + 2] = x1;
        bufFloat[bufPos + 3] = y1;
        bufFloat[bufPos + 4] = x1;
        bufFloat[bufPos + 5] = y1;
        bufFloat[bufPos + 6] = x1;
        bufFloat[bufPos + 7] = y1;
        bufFloat[bufPos + 8] = travel;
        bufFloat[bufPos + 9] = 16 * joint;
        bufFloat[bufPos + 10] = lineStyle;
        bufUint[bufPos + 11] = color;
        bufPos += strideFloats;
        continue;
      }
      if (joint >= JOINT_TYPE.FILL_EXPAND) {
        prevX = verts2[j * 2];
        prevY = verts2[j * 2 + 1];
        x1 = verts2[j * 2 + 2];
        y1 = verts2[j * 2 + 3];
        x2 = verts2[j * 2 + 4];
        y2 = verts2[j * 2 + 5];
        const bis = j + 3;
        for (let i = 0; i < 3; i++) {
          bufFloat[bufPos] = prevX;
          bufFloat[bufPos + 1] = prevY;
          bufFloat[bufPos + 2] = x1;
          bufFloat[bufPos + 3] = y1;
          bufFloat[bufPos + 4] = x2;
          bufFloat[bufPos + 5] = y2;
          bufFloat[bufPos + 6] = verts2[(bis + i) * 2];
          bufFloat[bufPos + 7] = verts2[(bis + i) * 2 + 1];
          bufFloat[bufPos + 8] = travel;
          bufFloat[bufPos + 9] = 16 * fullJoint + i;
          bufFloat[bufPos + 10] = lineStyle;
          bufUint[bufPos + 11] = color;
          bufPos += strideFloats;
        }
        indices[indPos] = index;
        indices[indPos + 1] = index + 1;
        indices[indPos + 2] = index + 2;
        indPos += 3;
        index += 3;
        continue;
      }
      const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];
      if (vs === 0) {
        continue;
      }
      x1 = verts2[j * 2];
      y1 = verts2[j * 2 + 1];
      x2 = verts2[j * 2 + 2];
      y2 = verts2[j * 2 + 3];
      prevX = verts2[j * 2 - 2];
      prevY = verts2[j * 2 - 1];
      const dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      if (SegmentPacker.vertsByJoint[joint] === 0) {
        travel -= dist;
      }
      if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT) {
        nextX = verts2[j * 2 + 4];
        nextY = verts2[j * 2 + 5];
      } else {
        nextX = x1;
        nextY = y1;
      }
      for (let i = 0; i < vs; i++) {
        bufFloat[bufPos] = prevX;
        bufFloat[bufPos + 1] = prevY;
        bufFloat[bufPos + 2] = x1;
        bufFloat[bufPos + 3] = y1;
        bufFloat[bufPos + 4] = x2;
        bufFloat[bufPos + 5] = y2;
        bufFloat[bufPos + 6] = nextX;
        bufFloat[bufPos + 7] = nextY;
        bufFloat[bufPos + 8] = travel;
        bufFloat[bufPos + 9] = 16 * fullJoint + i;
        bufFloat[bufPos + 10] = lineStyle;
        bufUint[bufPos + 11] = color;
        bufPos += strideFloats;
      }
      travel += dist;
      indices[indPos] = index;
      indices[indPos + 1] = index + 1;
      indices[indPos + 2] = index + 2;
      indices[indPos + 3] = index;
      indices[indPos + 4] = index + 2;
      indices[indPos + 5] = index + 3;
      indPos += 6;
      for (let j2 = 5; j2 + 1 < vs; j2++) {
        indices[indPos] = index + 4;
        indices[indPos + 1] = index + j2;
        indices[indPos + 2] = index + j2 + 1;
        indPos += 3;
      }
      index += vs;
    }
    if (hasTriangle) {
      for (let i = 0; i < triangles.length; i++) {
        indices[indPos + i] = triangles[i] + index;
      }
      indPos += triangles.length;
    }
    this.bufferPos = bufPos;
    this.indexPos = indPos;
  }
};
SegmentPacker.__initStatic();
var verts = SegmentPacker.vertsByJoint;
for (let i = 0; i < 256; i++) {
  verts.push(0);
}
verts[JOINT_TYPE.FILL] = 1;
for (let i = 0; i < 8; i++) {
  verts[JOINT_TYPE.FILL_EXPAND + i] = 3;
}
verts[JOINT_TYPE.JOINT_BEVEL] = 4 + 3;
verts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 3;
verts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 3;
verts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 3;
verts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;
verts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;
verts[JOINT_TYPE.JOINT_MITER] = 4 + 4;
verts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 4;
verts[JOINT_TYPE.JOINT_MITER + 2] = 4;
verts[JOINT_TYPE.JOINT_MITER + 3] = 4;
verts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;
verts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;
verts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;
verts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;
verts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 4;
verts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 4;
verts[JOINT_TYPE.CAP_ROUND] = 4;
var SmoothGraphicsData = class {
  // result of simplification
  // indices in build
  constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
    this.points = [];
    this.holes = [];
    this.triangles = [];
    this.closeStroke = false;
    this.clearBuild();
  }
  clearPath() {
    this.points.length = 0;
    this.closeStroke = true;
  }
  clearBuild() {
    this.triangles.length = 0;
    this.fillStart = 0;
    this.fillLen = 0;
    this.strokeStart = 0;
    this.strokeLen = 0;
    this.fillAA = false;
  }
  clone() {
    return new SmoothGraphicsData(
      this.shape,
      this.fillStyle,
      this.lineStyle,
      this.matrix
    );
  }
  capType() {
    let cap;
    switch (this.lineStyle.cap) {
      case LINE_CAP.SQUARE:
        cap = JOINT_TYPE.CAP_SQUARE;
        break;
      case LINE_CAP.ROUND:
        cap = JOINT_TYPE.CAP_ROUND;
        break;
      default:
        cap = JOINT_TYPE.CAP_BUTT;
        break;
    }
    return cap;
  }
  goodJointType() {
    let joint;
    switch (this.lineStyle.join) {
      case LINE_JOIN.BEVEL:
        joint = JOINT_TYPE.JOINT_BEVEL;
        break;
      case LINE_JOIN.ROUND:
        joint = JOINT_TYPE.JOINT_ROUND;
        break;
      default:
        joint = JOINT_TYPE.JOINT_MITER + 3;
        break;
    }
    return joint;
  }
  jointType() {
    let joint;
    switch (this.lineStyle.join) {
      case LINE_JOIN.BEVEL:
        joint = JOINT_TYPE.JOINT_BEVEL;
        break;
      case LINE_JOIN.ROUND:
        joint = JOINT_TYPE.JOINT_ROUND;
        break;
      default:
        joint = JOINT_TYPE.JOINT_MITER;
        break;
    }
    return joint;
  }
  destroy() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
    this.triangles = null;
  }
};
var CircleBuilder = class {
  path(graphicsData, _target) {
    const circleData = graphicsData.shape;
    const points = graphicsData.points;
    const x = circleData.x;
    const y = circleData.y;
    let width;
    let height;
    if (graphicsData.type === SHAPES.CIRC) {
      width = circleData.radius;
      height = circleData.radius;
    } else {
      const ellipseData = graphicsData.shape;
      width = ellipseData.width;
      height = ellipseData.height;
    }
    if (width <= 0 || height <= 0) {
      return;
    }
    points.push(x, y);
    let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width + height));
    totalSegs /= 2.3;
    if (totalSegs < 3) {
      totalSegs = 3;
    }
    const seg = Math.PI * 2 / totalSegs;
    for (let i = 0; i < totalSegs - 0.5; i++) {
      points.push(
        x + Math.sin(-seg * i) * width,
        y + Math.cos(-seg * i) * height
      );
    }
  }
  fill(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points, triangles } = graphicsData;
    let vertPos = 1;
    const center = 0;
    if (!graphicsData.fillAA) {
      for (let i = 0; i < points.length; i += 2) {
        verts2.push(points[i], points[i + 1]);
        joints.push(JOINT_TYPE.FILL);
        if (i > 2) {
          triangles.push(vertPos++, center, vertPos);
        }
      }
      triangles.push(vertPos, center, 1);
      return;
    }
    const cx = points[0];
    const cy = points[1];
    const rad = graphicsData.shape.radius;
    for (let i = 2; i < points.length; i += 2) {
      const cur = i;
      const next = i + 2 < points.length ? i + 2 : 2;
      verts2.push(cx);
      verts2.push(cy);
      verts2.push(points[cur]);
      verts2.push(points[cur + 1]);
      verts2.push(points[next]);
      verts2.push(points[next + 1]);
      verts2.push(0);
      verts2.push(0);
      verts2.push((points[cur] - cx) / rad);
      verts2.push((points[cur + 1] - cy) / rad);
      verts2.push((points[next] - cx) / rad);
      verts2.push((points[next + 1] - cy) / rad);
      joints.push(JOINT_TYPE.FILL_EXPAND + 2);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
    }
  }
  line(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points } = graphicsData;
    const joint = graphicsData.goodJointType();
    const len = points.length;
    verts2.push(points[len - 2], points[len - 1]);
    joints.push(JOINT_TYPE.NONE);
    for (let i = 2; i < len; i += 2) {
      verts2.push(points[i], points[i + 1]);
      joints.push(joint);
    }
    verts2.push(points[2], points[3]);
    joints.push(JOINT_TYPE.NONE);
    verts2.push(points[4], points[5]);
    joints.push(JOINT_TYPE.NONE);
  }
};
var RectangleBuilder = class {
  path(graphicsData, _target) {
    const rectData = graphicsData.shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    const points = graphicsData.points;
    points.length = 0;
    points.push(
      x,
      y,
      x + width,
      y,
      x + width,
      y + height,
      x,
      y + height
    );
  }
  line(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points } = graphicsData;
    const joint = graphicsData.goodJointType();
    const len = points.length;
    verts2.push(points[len - 2], points[len - 1]);
    joints.push(JOINT_TYPE.NONE);
    for (let i = 0; i < len; i += 2) {
      verts2.push(points[i], points[i + 1]);
      joints.push(joint);
    }
    verts2.push(points[0], points[1]);
    joints.push(JOINT_TYPE.NONE);
    verts2.push(points[2], points[3]);
    joints.push(JOINT_TYPE.NONE);
  }
  fill(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points, triangles } = graphicsData;
    triangles.length = 0;
    verts2.push(
      points[0],
      points[1],
      points[2],
      points[3],
      points[4],
      points[5],
      points[6],
      points[7]
    );
    joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);
    triangles.push(0, 1, 2, 0, 2, 3);
  }
};
function getPt2(n1, n2, perc) {
  const diff = n2 - n1;
  return n1 + diff * perc;
}
function quadraticBezierCurve2(fromX, fromY, cpX, cpY, toX, toY, out = []) {
  const n = 20;
  const points = out;
  let xa = 0;
  let ya = 0;
  let xb = 0;
  let yb = 0;
  let x = 0;
  let y = 0;
  for (let i = 0, j = 0; i <= n; ++i) {
    j = i / n;
    xa = getPt2(fromX, cpX, j);
    ya = getPt2(fromY, cpY, j);
    xb = getPt2(cpX, toX, j);
    yb = getPt2(cpY, toY, j);
    x = getPt2(xa, xb, j);
    y = getPt2(ya, yb, j);
    points.push(x, y);
  }
  return points;
}
var RoundedRectangleBuilder = class {
  path(graphicsData, _target) {
    const rrectData = graphicsData.shape;
    const { points } = graphicsData;
    const x = rrectData.x;
    const y = rrectData.y;
    const width = rrectData.width;
    const height = rrectData.height;
    const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(
        x,
        y,
        x + width,
        y,
        x + width,
        y + height,
        x,
        y + height
      );
    } else {
      quadraticBezierCurve2(
        x,
        y + radius,
        x,
        y,
        x + radius,
        y,
        points
      );
      quadraticBezierCurve2(
        x + width - radius,
        y,
        x + width,
        y,
        x + width,
        y + radius,
        points
      );
      quadraticBezierCurve2(
        x + width,
        y + height - radius,
        x + width,
        y + height,
        x + width - radius,
        y + height,
        points
      );
      quadraticBezierCurve2(
        x + radius,
        y + height,
        x,
        y + height,
        x,
        y + height - radius,
        points
      );
    }
  }
  line(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points } = graphicsData;
    const joint = points.length === 8 ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;
    const len = points.length;
    verts2.push(points[len - 2], points[len - 1]);
    joints.push(JOINT_TYPE.NONE);
    for (let i = 0; i < len; i += 2) {
      verts2.push(points[i], points[i + 1]);
      joints.push(joint);
    }
    verts2.push(points[0], points[1]);
    joints.push(JOINT_TYPE.NONE);
    verts2.push(points[2], points[3]);
    joints.push(JOINT_TYPE.NONE);
  }
  fill(graphicsData, target) {
    const { verts: verts2, joints } = target;
    const { points } = graphicsData;
    graphicsData.triangles = (0, import_earcut.default)(points, null, 2);
    for (let i = 0, j = points.length; i < j; i++) {
      verts2.push(points[i], points[++i]);
      joints.push(JOINT_TYPE.FILL);
    }
  }
};
var tempArr = [];
var PolyBuilder = class {
  path(graphicsData, buildData) {
    const shape = graphicsData.shape;
    const points = graphicsData.points = shape.points.slice();
    const eps = buildData.closePointEps;
    const eps2 = eps * eps;
    if (points.length === 0) {
      return;
    }
    const firstPoint = new Point(points[0], points[1]);
    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
    const closedShape = graphicsData.closeStroke = shape.closeStroke;
    let len = points.length;
    let newLen = 2;
    for (let i = 2; i < len; i += 2) {
      const x1 = points[i - 2];
      const y1 = points[i - 1];
      const x2 = points[i];
      const y2 = points[i + 1];
      let flag = true;
      if (Math.abs(x1 - x2) < eps && Math.abs(y1 - y2) < eps) {
        flag = false;
      }
      if (flag) {
        points[newLen] = points[i];
        points[newLen + 1] = points[i + 1];
        newLen += 2;
      }
    }
    points.length = len = newLen;
    newLen = 2;
    for (let i = 2; i + 2 < len; i += 2) {
      let x1 = points[i - 2];
      let y1 = points[i - 1];
      const x2 = points[i];
      const y2 = points[i + 1];
      let x3 = points[i + 2];
      let y3 = points[i + 3];
      x1 -= x2;
      y1 -= y2;
      x3 -= x2;
      y3 -= y2;
      let flag = true;
      if (Math.abs(x3 * y1 - y3 * x1) < eps2) {
        if (x1 * x3 + y1 * y3 < -eps2) {
          flag = false;
        }
      }
      if (flag) {
        points[newLen] = points[i];
        points[newLen + 1] = points[i + 1];
        newLen += 2;
      }
    }
    points[newLen] = points[len - 2];
    points[newLen + 1] = points[len - 1];
    newLen += 2;
    points.length = len = newLen;
    if (len <= 2) {
      return;
    }
    if (closedShape) {
      const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
      if (closedPath) {
        points.pop();
        points.pop();
      }
    }
  }
  line(graphicsData, buildData) {
    const { closeStroke, points } = graphicsData;
    const eps = buildData.closePointEps;
    const len = points.length;
    if (len <= 2) {
      return;
    }
    const { verts: verts2, joints } = buildData;
    const joint = graphicsData.jointType();
    const cap = graphicsData.capType();
    let prevCap = 0;
    let prevX;
    let prevY;
    if (closeStroke) {
      prevX = points[len - 2];
      prevY = points[len - 1];
      joints.push(JOINT_TYPE.NONE);
    } else {
      prevX = points[2];
      prevY = points[3];
      if (cap === JOINT_TYPE.CAP_ROUND) {
        verts2.push(points[0], points[1]);
        joints.push(JOINT_TYPE.NONE);
        joints.push(JOINT_TYPE.CAP_ROUND);
        prevCap = 0;
      } else {
        prevCap = cap;
        joints.push(JOINT_TYPE.NONE);
      }
    }
    verts2.push(prevX, prevY);
    for (let i = 0; i < len; i += 2) {
      const x1 = points[i];
      const y1 = points[i + 1];
      let x2;
      let y2;
      if (i + 2 < len) {
        x2 = points[i + 2];
        y2 = points[i + 3];
      } else {
        x2 = points[0];
        y2 = points[1];
      }
      const dx = x2 - x1;
      const dy = y2 - y1;
      let nextX;
      let nextY;
      let endJoint = joint;
      if (i + 2 >= len) {
        nextX = points[2];
        nextY = points[3];
        if (!closeStroke) {
          endJoint = JOINT_TYPE.NONE;
        }
      } else if (i + 4 >= len) {
        nextX = points[0];
        nextY = points[1];
        if (!closeStroke) {
          if (cap === JOINT_TYPE.CAP_ROUND) {
            endJoint = JOINT_TYPE.JOINT_CAP_ROUND;
          }
          if (cap === JOINT_TYPE.CAP_BUTT) {
            endJoint = JOINT_TYPE.JOINT_CAP_BUTT;
          }
          if (cap === JOINT_TYPE.CAP_SQUARE) {
            endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;
          }
        }
      } else {
        nextX = points[i + 4];
        nextY = points[i + 5];
      }
      const dx3 = x1 - prevX;
      const dy3 = y1 - prevY;
      if (joint >= JOINT_TYPE.JOINT_BEVEL && joint <= JOINT_TYPE.JOINT_MITER) {
        const dx2 = nextX - x2;
        const dy2 = nextY - y2;
        if (endJoint >= JOINT_TYPE.JOINT_BEVEL && endJoint <= JOINT_TYPE.JOINT_MITER + 3) {
          const D = dx2 * dy - dy2 * dx;
          if (Math.abs(D) < eps) {
            switch (joint & ~3) {
              case JOINT_TYPE.JOINT_ROUND:
                endJoint = JOINT_TYPE.JOINT_CAP_ROUND;
                break;
              default:
                endJoint = JOINT_TYPE.JOINT_CAP_BUTT;
                break;
            }
          }
        }
        if (joint === JOINT_TYPE.JOINT_MITER) {
          let jointAdd = 0;
          if (dx3 * dx + dy3 * dy > -eps) {
            jointAdd++;
          }
          if (endJoint === JOINT_TYPE.JOINT_MITER && dx2 * dx + dy2 * dy > -eps) {
            jointAdd += 2;
          }
          endJoint += jointAdd;
        }
      }
      if (prevCap === 0) {
        if (Math.abs(dx3 * dy - dy3 * dx) < eps) {
          prevCap = JOINT_TYPE.CAP_BUTT2;
        }
      }
      endJoint += prevCap;
      prevCap = 0;
      verts2.push(x1, y1);
      joints.push(endJoint);
      prevX = x1;
      prevY = y1;
    }
    if (closeStroke) {
      verts2.push(points[0], points[1]);
      joints.push(JOINT_TYPE.NONE);
      verts2.push(points[2], points[3]);
      joints.push(JOINT_TYPE.NONE);
    } else {
      verts2.push(points[len - 4], points[len - 3]);
      joints.push(JOINT_TYPE.NONE);
    }
  }
  fill(graphicsData, buildData) {
    let points = graphicsData.points;
    const holes = graphicsData.holes;
    const eps = buildData.closePointEps;
    const { verts: verts2, joints } = buildData;
    if (points.length < 6) {
      return;
    }
    const holeArray = [];
    let len = points.length;
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      holeArray.push(points.length / 2);
      points = points.concat(hole.points);
    }
    const pn = tempArr;
    if (pn.length < points.length) {
      pn.length = points.length;
    }
    const start = 0;
    for (let i = 0; i <= holeArray.length; i++) {
      let finish = len / 2;
      if (i > 0) {
        if (i < holeArray.length) {
          finish = holeArray[i];
        } else {
          finish = points.length >> 1;
        }
      }
      pn[start * 2] = finish - 1;
      pn[(finish - 1) * 2 + 1] = 0;
      for (let j = start; j + 1 < finish; j++) {
        pn[j * 2 + 1] = j + 1;
        pn[j * 2 + 2] = j;
      }
    }
    graphicsData.triangles = (0, import_earcut.default)(points, holeArray, 2);
    if (!graphicsData.triangles) {
      return;
    }
    if (!graphicsData.fillAA) {
      for (let i = 0; i < points.length; i += 2) {
        verts2.push(points[i], points[i + 1]);
        joints.push(JOINT_TYPE.FILL);
      }
      return;
    }
    const { triangles } = graphicsData;
    len = points.length;
    for (let i = 0; i < triangles.length; i += 3) {
      let flag = 0;
      for (let j = 0; j < 3; j++) {
        const ind1 = triangles[i + j];
        const ind2 = triangles[i + (j + 1) % 3];
        if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2) {
          flag |= 1 << j;
        }
      }
      joints.push(JOINT_TYPE.FILL_EXPAND + flag);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
      joints.push(JOINT_TYPE.NONE);
    }
    for (let ind = 0; ind < len / 2; ind++) {
      const prev = pn[ind * 2];
      const next = pn[ind * 2 + 1];
      let nx1 = points[next * 2 + 1] - points[ind * 2 + 1];
      let ny1 = -(points[next * 2] - points[ind * 2]);
      let nx2 = points[ind * 2 + 1] - points[prev * 2 + 1];
      let ny2 = -(points[ind * 2] - points[prev * 2]);
      const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);
      nx1 /= D1;
      ny1 /= D1;
      const D2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
      nx2 /= D2;
      ny2 /= D2;
      let bx = nx1 + nx2;
      let by = ny1 + ny2;
      const D = bx * nx1 + by * ny1;
      if (Math.abs(D) < eps) {
        bx = nx1;
        by = ny1;
      } else {
        bx /= D;
        by /= D;
      }
      pn[ind * 2] = bx;
      pn[ind * 2 + 1] = by;
    }
    for (let i = 0; i < triangles.length; i += 3) {
      const prev = triangles[i];
      const ind = triangles[i + 1];
      const next = triangles[i + 2];
      const nx1 = points[next * 2 + 1] - points[ind * 2 + 1];
      const ny1 = -(points[next * 2] - points[ind * 2]);
      const nx2 = points[ind * 2 + 1] - points[prev * 2 + 1];
      const ny2 = -(points[ind * 2] - points[prev * 2]);
      let j1 = 1;
      if (nx1 * ny2 - nx2 * ny1 > 0) {
        j1 = 2;
      }
      for (let j = 0; j < 3; j++) {
        const ind2 = triangles[i + j * j1 % 3];
        verts2.push(points[ind2 * 2], points[ind2 * 2 + 1]);
      }
      for (let j = 0; j < 3; j++) {
        const ind2 = triangles[i + j * j1 % 3];
        verts2.push(pn[ind2 * 2], pn[ind2 * 2 + 1]);
      }
    }
  }
};
var FILL_COMMANDS2 = {
  [SHAPES.POLY]: new PolyBuilder(),
  [SHAPES.CIRC]: new CircleBuilder(),
  [SHAPES.ELIP]: new CircleBuilder(),
  [SHAPES.RECT]: new RectangleBuilder(),
  [SHAPES.RREC]: new RoundedRectangleBuilder()
};
var BATCH_POOL2 = [];
var DRAW_CALL_POOL2 = [];
var tmpPoint2 = new Point();
var tmpBounds2 = new Bounds();
var SmoothGraphicsGeometry = class extends Geometry {
  static __initStatic() {
    this.BATCHABLE_SIZE = 100;
  }
  __init() {
    this.indicesUint16 = null;
  }
  get points() {
    return this.buildData.verts;
  }
  get closePointEps() {
    return this.buildData.closePointEps;
  }
  initAttributes(_static) {
    this._buffer = new Buffer(null, _static, false);
    this._bufferFloats = new Float32Array();
    this._bufferUint = new Uint32Array();
    this._indexBuffer = new Buffer(null, _static, true);
    this.addAttribute("aPrev", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aPoint1", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aPoint2", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aNext", this._buffer, 2, false, TYPES.FLOAT).addAttribute("aTravel", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aVertexJoint", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aStyleId", this._buffer, 1, false, TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, true, TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer);
    this.strideFloats = 12;
  }
  constructor() {
    super();
    SmoothGraphicsGeometry.prototype.__init.call(this);
    this.initAttributes(false);
    this.buildData = new BuildData();
    this.graphicsData = [];
    this.dirty = 0;
    this.batchDirty = -1;
    this.cacheDirty = -1;
    this.clearDirty = 0;
    this.drawCalls = [];
    this.batches = [];
    this.shapeBuildIndex = 0;
    this.shapeBatchIndex = 0;
    this._bounds = new Bounds();
    this.boundsDirty = -1;
    this.boundsPadding = 0;
    this.batchable = false;
    this.indicesUint16 = null;
    this.packer = null;
    this.packSize = 0;
    this.pack32index = null;
  }
  checkInstancing(instanced, allow32Indices) {
    if (this.packer) {
      return;
    }
    this.packer = new SegmentPacker();
    this.pack32index = allow32Indices;
  }
  /**
   * Get the current bounds of the graphic geometry.
   *
   * @member {PIXI.Bounds}
   * @readonly
   */
  get bounds() {
    if (this.boundsDirty !== this.dirty) {
      this.boundsDirty = this.dirty;
      this.calculateBounds();
    }
    return this._bounds;
  }
  /**
   * Call if you changed graphicsData manually.
   * Empties all batch buffers.
   */
  invalidate() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeBuildIndex = 0;
    this.shapeBatchIndex = 0;
    this.packSize = 0;
    this.buildData.clear();
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].clear();
      DRAW_CALL_POOL2.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    for (let i = 0; i < this.batches.length; i++) {
      const batchPart = this.batches[i];
      batchPart.reset();
      BATCH_POOL2.push(batchPart);
    }
    this.batches.length = 0;
  }
  clear() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  }
  drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
    const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  }
  drawHole(shape, matrix = null) {
    if (!this.graphicsData.length) {
      return null;
    }
    const data = new SmoothGraphicsData(shape, null, null, matrix);
    const lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  }
  destroy() {
    super.destroy();
    for (let i = 0; i < this.graphicsData.length; ++i) {
      this.graphicsData[i].destroy();
    }
    this.buildData.destroy();
    this.buildData = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  }
  /**
   * Check to see if a point is contained within this geometry.
   *
   * @param {PIXI.IPointData} point - Point to check if it's contained.
   * @return {Boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    const graphicsData = this.graphicsData;
    for (let i = 0; i < graphicsData.length; ++i) {
      const data = graphicsData[i];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint2);
        } else {
          tmpPoint2.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint2.x, tmpPoint2.y)) {
          let hitHole = false;
          if (data.holes) {
            for (let i2 = 0; i2 < data.holes.length; i2++) {
              const hole = data.holes[i2];
              if (hole.shape.contains(tmpPoint2.x, tmpPoint2.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  }
  updatePoints() {
  }
  updateBufferSize() {
    this._buffer.update(new Float32Array());
  }
  updateBuild() {
    const { graphicsData, buildData } = this;
    const len = graphicsData.length;
    for (let i = this.shapeBuildIndex; i < len; i++) {
      const data = graphicsData[i];
      data.strokeStart = 0;
      data.strokeLen = 0;
      data.fillStart = 0;
      data.fillLen = 0;
      const { fillStyle, lineStyle, holes } = data;
      if (!fillStyle.visible && !lineStyle.visible) {
        continue;
      }
      const command = FILL_COMMANDS2[data.type];
      data.clearPath();
      command.path(data, buildData);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      data.clearBuild();
      if (data.points.length <= 2) {
        continue;
      }
      if (fillStyle.visible) {
        if (holes.length) {
          this.processHoles(holes);
        }
        data.fillAA = data.fillStyle.smooth && !(data.lineStyle.visible && data.lineStyle.alpha >= 0.99 && data.lineStyle.width >= 0.99);
        data.fillStart = buildData.joints.length;
        command.fill(data, buildData);
        data.fillLen = buildData.joints.length - data.fillStart;
      }
      if (lineStyle.visible) {
        data.strokeStart = buildData.joints.length;
        command.line(data, buildData);
        data.strokeLen = buildData.joints.length - data.strokeStart;
      }
    }
    this.shapeBuildIndex = len;
  }
  updateBatches(shaderSettings) {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    this.updateBuild();
    if (!this.validateBatching()) {
      return;
    }
    const { buildData, graphicsData } = this;
    const len = graphicsData.length;
    this.cacheDirty = this.dirty;
    let batchPart = null;
    let currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (let i = this.shapeBatchIndex; i < len; i++) {
      const data = graphicsData[i];
      const fillStyle = data.fillStyle;
      const lineStyle = data.lineStyle;
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (!fillStyle.visible && !lineStyle.visible) {
        continue;
      }
      for (let j = 0; j < 2; j++) {
        const style = j === 0 ? fillStyle : lineStyle;
        if (!style.visible)
          continue;
        const nextTexture = style.texture.baseTexture;
        const attribOld = buildData.vertexSize;
        const indexOld = buildData.indexSize;
        nextTexture.wrapMode = WRAP_MODES.REPEAT;
        if (j === 0) {
          this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);
        } else {
          this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);
        }
        const attribSize = buildData.vertexSize;
        if (attribSize === attribOld)
          continue;
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(indexOld, attribOld);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL2.pop() || new BatchPart2();
          batchPart.begin(style, indexOld, attribOld);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        if (j === 0) {
          batchPart.jointEnd = data.fillStart + data.fillLen;
        } else {
          batchPart.jointEnd = data.strokeStart + data.strokeLen;
        }
      }
    }
    this.shapeBatchIndex = len;
    if (batchPart) {
      batchPart.end(buildData.indexSize, buildData.vertexSize);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls(shaderSettings);
      this.updatePack();
    }
  }
  updatePack() {
    const { vertexSize, indexSize } = this.buildData;
    if (this.packSize === vertexSize) {
      return;
    }
    const { strideFloats, packer, buildData, batches } = this;
    const buffer = this._buffer;
    const index = this._indexBuffer;
    const floatsSize = vertexSize * strideFloats;
    if (buffer.data.length !== floatsSize) {
      const arrBuf = new ArrayBuffer(floatsSize * 4);
      this._bufferFloats = new Float32Array(arrBuf);
      this._bufferUint = new Uint32Array(arrBuf);
      buffer.data = this._bufferFloats;
    }
    if (index.data.length !== indexSize) {
      if (vertexSize > 65535 && this.pack32index) {
        index.data = new Uint32Array(indexSize);
      } else {
        index.data = new Uint16Array(indexSize);
      }
    }
    packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data);
    let j = 0;
    for (let i = 0; i < this.graphicsData.length; i++) {
      const data = this.graphicsData[i];
      if (data.fillLen) {
        while (batches[j].jointEnd <= data.fillStart) {
          j++;
        }
        packer.packInterleavedGeometry(
          data.fillStart,
          data.fillLen,
          data.triangles,
          batches[j].styleId,
          batches[j].rgba
        );
      }
      if (data.strokeLen) {
        while (batches[j].jointEnd <= data.strokeStart) {
          j++;
        }
        packer.packInterleavedGeometry(
          data.strokeStart,
          data.strokeLen,
          data.triangles,
          batches[j].styleId,
          batches[j].rgba
        );
      }
    }
    buffer.update();
    index.update();
    this.packSize = vertexSize;
  }
  /**
   * Affinity check
   *
   * @param {PIXI.FillStyle | PIXI.LineStyle} styleA
   * @param {PIXI.FillStyle | PIXI.LineStyle} styleB
   */
  _compareStyles(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (styleA.packLineWidth() !== styleB.packLineWidth()) {
      return false;
    }
    if (styleA.alignment !== styleB.alignment) {
      return false;
    }
    const mat1 = styleA.matrix || Matrix.IDENTITY;
    const mat2 = styleB.matrix || Matrix.IDENTITY;
    return matrixEquals(mat1, mat2);
  }
  /**
   * Test geometry for batching process.
   *
   * @protected
   */
  validateBatching() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (let i = 0, l = this.graphicsData.length; i < l; i++) {
      const data = this.graphicsData[i];
      const fill = data.fillStyle;
      const line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid)
        return false;
      if (line && !line.texture.baseTexture.valid)
        return false;
    }
    return true;
  }
  /**
   * Offset the indices so that it works with the batcher.
   *
   * @protected
   */
  packBatches() {
    this.batchDirty++;
    const batches = this.batches;
    for (let i = 0, l = batches.length; i < l; i++) {
      const batch = batches[i];
      for (let j = 0; j < batch.size; j++) {
        const index = batch.start + j;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  }
  isBatchable() {
    return false;
  }
  /**
   * Converts intermediate batches data to drawCalls.
   *
   * @protected
   */
  buildDrawCalls(shaderSettings) {
    for (let i = 0; i < this.drawCalls.length; i++) {
      this.drawCalls[i].clear();
      DRAW_CALL_POOL2.push(this.drawCalls[i]);
    }
    this.drawCalls.length = 0;
    let currentGroup = DRAW_CALL_POOL2.pop() || new BatchDrawCall2();
    currentGroup.begin(shaderSettings, null);
    let index = 0;
    this.drawCalls.push(currentGroup);
    for (let i = 0; i < this.batches.length; i++) {
      const batchData = this.batches[i];
      const style = batchData.style;
      if (batchData.attribSize === 0) {
        continue;
      }
      let styleId = -1;
      const mat = style.getTextureMatrix();
      if (currentGroup.check(style.shader)) {
        styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);
      }
      if (styleId < 0) {
        currentGroup = DRAW_CALL_POOL2.pop() || new BatchDrawCall2();
        this.drawCalls.push(currentGroup);
        currentGroup.begin(shaderSettings, style.shader);
        currentGroup.start = index;
        styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);
      }
      currentGroup.size += batchData.size;
      index += batchData.size;
      const { color, alpha } = style;
      const rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      batchData.rgba = premultiplyTint(rgb, alpha);
      batchData.styleId = styleId;
    }
  }
  processHoles(holes) {
    for (let i = 0; i < holes.length; i++) {
      const hole = holes[i];
      const command = FILL_COMMANDS2[hole.type];
      command.path(hole, this.buildData);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  }
  /**
   * Update the local bounds of the object. Expensive to use performance-wise.
   *
   * @protected
   */
  calculateBounds() {
    const bounds = this._bounds;
    const sequenceBounds = tmpBounds2;
    let curMatrix = Matrix.IDENTITY;
    this._bounds.clear();
    sequenceBounds.clear();
    for (let i = 0; i < this.graphicsData.length; i++) {
      const data = this.graphicsData[i];
      const shape = data.shape;
      const type = data.type;
      const lineStyle = data.lineStyle;
      const nextMatrix = data.matrix || Matrix.IDENTITY;
      let lineWidth = 0;
      if (lineStyle && lineStyle.visible) {
        const alignment = lineStyle.alignment;
        lineWidth = lineStyle.width;
        if (type === SHAPES.POLY) {
          lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));
        } else {
          lineWidth = lineWidth * Math.max(0, alignment);
        }
      }
      if (curMatrix !== nextMatrix) {
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
          sequenceBounds.clear();
        }
        curMatrix = nextMatrix;
      }
      if (type === SHAPES.RECT || type === SHAPES.RREC) {
        const rect = shape;
        sequenceBounds.addFramePad(
          rect.x,
          rect.y,
          rect.x + rect.width,
          rect.y + rect.height,
          lineWidth,
          lineWidth
        );
      } else if (type === SHAPES.CIRC) {
        const circle = shape;
        sequenceBounds.addFramePad(
          circle.x,
          circle.y,
          circle.x,
          circle.y,
          circle.radius + lineWidth,
          circle.radius + lineWidth
        );
      } else if (type === SHAPES.ELIP) {
        const ellipse = shape;
        sequenceBounds.addFramePad(
          ellipse.x,
          ellipse.y,
          ellipse.x,
          ellipse.y,
          ellipse.width + lineWidth,
          ellipse.height + lineWidth
        );
      } else {
        const poly = shape;
        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
      }
    }
    if (!sequenceBounds.isEmpty()) {
      bounds.addBoundsMatrix(sequenceBounds, curMatrix);
    }
    bounds.pad(this.boundsPadding, this.boundsPadding);
  }
  /**
   * Transform points using matrix.
   *
   * @protected
   * @param {number[]} points - Points to transform
   * @param {PIXI.Matrix} matrix - Transform matrix
   */
  transformPoints(points, matrix) {
    for (let i = 0; i < points.length / 2; i++) {
      const x = points[i * 2];
      const y = points[i * 2 + 1];
      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;
      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;
    }
  }
};
SmoothGraphicsGeometry.__initStatic();
var smoothVert = `precision highp float;
const float FILL = 1.0;
const float BEVEL = 4.0;
const float MITER = 8.0;
const float ROUND = 12.0;
const float JOINT_CAP_BUTT = 16.0;
const float JOINT_CAP_SQUARE = 18.0;
const float JOINT_CAP_ROUND = 20.0;

const float FILL_EXPAND = 24.0;

const float CAP_BUTT = 1.0;
const float CAP_SQUARE = 2.0;
const float CAP_ROUND = 3.0;
const float CAP_BUTT2 = 4.0;

const float MITER_LIMIT = 10.0;

// === geom ===
attribute vec2 aPrev;
attribute vec2 aPoint1;
attribute vec2 aPoint2;
attribute vec2 aNext;
attribute float aVertexJoint;
attribute float aTravel;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec4 vSignedCoord;
varying vec4 vDistance;
varying float vType;

uniform float resolution;
uniform float expand;

// === style ===
attribute float aStyleId;
attribute vec4 aColor;

varying float vTextureId;
varying vec4 vColor;
varying vec2 vTextureCoord;
varying float vTravel;

uniform vec2 styleLine[%MAX_STYLES%];
uniform vec3 styleMatrix[2 * %MAX_STYLES%];
uniform float styleTextureId[%MAX_STYLES%];
uniform vec2 samplerSize[%MAX_TEXTURES%];

vec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,
    float dy, float inner) {
    vec2 bisect = (norm + norm2) / 2.0;
    bisect /= dot(norm, bisect);
    vec2 shift = dy * bisect;
    if (inner > 0.5) {
        if (len < len2) {
            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {
                return dy * norm;
            }
        } else {
            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {
                return dy * norm;
            }
        }
    }
    return dy * bisect;
}

void main(void){
    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;
    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;

    vec2 xBasis = pointB - pointA;
    float len = length(xBasis);
    vec2 forward = xBasis / len;
    vec2 norm = vec2(forward.y, -forward.x);

    float type = floor(aVertexJoint / 16.0);
    float vertexNum = aVertexJoint - type * 16.0;
    float dx = 0.0, dy = 1.0;


    vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;
    float avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);

    float capType = floor(type / 32.0);
    type -= capType * 32.0;

    int styleId = int(aStyleId + 0.5);
    float lineWidth = styleLine[styleId].x;
    if (lineWidth < 0.0) {
        lineWidth = -lineWidth;
    } else {
        lineWidth = lineWidth * avgScale;
    }
    lineWidth *= 0.5;
    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;
    vTextureId = styleTextureId[styleId];
    vTextureCoord = vec2(0.0);

    vec2 pos;

    if (capType == CAP_ROUND) {
        vertexNum += 4.0;
        type = JOINT_CAP_ROUND;
        capType = 0.0;
    }

    if (type == FILL) {
        pos = pointA;
        vDistance = vec4(0.0, -0.5, -0.5, 1.0);
        vType = 0.0;

        vec2 vTexturePixel;
        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);
        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);
        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];
    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {
        // expand vertices
        float flags = type - FILL_EXPAND;
        float flag3 = floor(flags / 4.0);
        float flag2 = floor((flags - flag3 * 4.0) / 2.0);
        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;

        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;

        if (vertexNum < 0.5) {
            pos = prev;
        } else if (vertexNum < 1.5) {
            pos = pointA;
        } else {
            pos = pointB;
        }
        float len2 = length(aNext);
        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;
        if (len2 > 0.01) {
            bisect = normalize(bisect) * len2;
        }

        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));
        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));
        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));

        if (n1.x * n2.y - n1.y * n2.x < 0.0) {
            n1 = -n1;
            n2 = -n2;
            n3 = -n3;
        }

        vDistance.w = 1.0;
        pos += bisect * expand;

        vDistance = vec4(16.0, 16.0, 16.0, -1.0);
        if (flag1 > 0.5) {
            vDistance.x = -dot(pos - prev, n1);
        }
        if (flag2 > 0.5) {
            vDistance.y = -dot(pos - pointA, n2);
        }
        if (flag3 > 0.5) {
            vDistance.z = -dot(pos - pointB, n3);
        }
        vDistance.xyz *= resolution;
        vType = 2.0;
    } else if (type >= BEVEL) {
        float dy = lineWidth + expand;
        float inner = 0.0;
        if (vertexNum >= 1.5) {
            dy = -dy;
            inner = 1.0;
        }

        vec2 base, next, xBasis2, bisect;
        float flag = 0.0;
        float sign2 = 1.0;
        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {
            next = (translationMatrix * vec3(aPrev, 1.0)).xy;
            base = pointA;
            flag = type - floor(type / 2.0) * 2.0;
            sign2 = -1.0;
        } else {
            next = (translationMatrix * vec3(aNext, 1.0)).xy;
            base = pointB;
            if (type >= MITER && type < MITER + 3.5) {
                flag = step(MITER + 1.5, type);
                // check miter limit here?
            }
        }
        xBasis2 = next - base;
        float len2 = length(xBasis2);
        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;
        float D = norm.x * norm2.y - norm.y * norm2.x;
        if (D < 0.0) {
            inner = 1.0 - inner;
        }

        norm2 *= sign2;

        if (abs(lineAlignment) > 0.01) {
            float shift = lineWidth * lineAlignment;
            pointA += norm * shift;
            pointB += norm * shift;
            if (abs(D) < 0.01) {
                base += norm * shift;
            } else {
                base += doBisect(norm, len, norm2, len2, shift, 0.0);
            }
        }

        float collinear = step(0.0, dot(norm, norm2));

        vType = 0.0;
        float dy2 = -1000.0;
        float dy3 = -1000.0;

        if (abs(D) < 0.01 && collinear < 0.5) {
            if (type >= ROUND && type < ROUND + 1.5) {
                type = JOINT_CAP_ROUND;
            }
            //TODO: BUTT here too
        }

        if (vertexNum < 3.5) {
            if (abs(D) < 0.01) {
                pos = dy * norm;
            } else {
                if (flag < 0.5 && inner < 0.5) {
                    pos = dy * norm;
                } else {
                    pos = doBisect(norm, len, norm2, len2, dy, inner);
                }
            }
            if (capType >= CAP_BUTT && capType < CAP_ROUND) {
                float extra = step(CAP_SQUARE, capType) * lineWidth;
                vec2 back = -forward;
                if (vertexNum < 0.5 || vertexNum > 2.5) {
                    pos += back * (expand + extra);
                    dy2 = expand;
                } else {
                    dy2 = dot(pos + base - pointA, back) - extra;
                }
            }
            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {
                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;
                if (vertexNum < 0.5 || vertexNum > 2.5) {
                    dy3 = dot(pos + base - pointB, forward) - extra;
                } else {
                    pos += forward * (expand + extra);
                    dy3 = expand;
                    if (capType >= CAP_BUTT) {
                        dy2 -= expand + extra;
                    }
                }
            }
        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {
            if (inner > 0.5) {
                dy = -dy;
                inner = 0.0;
            }
            vec2 d2 = abs(dy) * vec2(-norm.y, norm.x);
            if (vertexNum < 4.5) {
                dy = -dy;
                pos = dy * norm;
            } else if (vertexNum < 5.5) {
                pos = dy * norm;
            } else if (vertexNum < 6.5) {
                pos = dy * norm + d2;
            } else {
                dy = -dy;
                pos = dy * norm + d2;
            }
            dy = -0.5;
            dy2 = pos.x;
            dy3 = pos.y;
            vType = 3.0;
        } else if (abs(D) < 0.01) {
            pos = dy * norm;
        } else {
            if (type >= ROUND && type < ROUND + 1.5) {
                if (inner > 0.5) {
                    dy = -dy;
                    inner = 0.0;
                }
                if (vertexNum < 4.5) {
                    pos = doBisect(norm, len, norm2, len2, -dy, 1.0);
                } else if (vertexNum < 5.5) {
                    pos = dy * norm;
                } else if (vertexNum > 7.5) {
                    pos = dy * norm2;
                } else {
                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);
                    float d2 = abs(dy);
                    if (length(pos) > abs(dy) * 1.5) {
                        if (vertexNum < 6.5) {
                            pos.x = dy * norm.x - d2 * norm.y;
                            pos.y = dy * norm.y + d2 * norm.x;
                        } else {
                            pos.x = dy * norm2.x + d2 * norm2.y;
                            pos.y = dy * norm2.y - d2 * norm2.x;
                        }
                    }
                }
                vec2 norm3 = normalize(norm - norm2);
                dy = pos.x * norm3.y - pos.y * norm3.x - 3.0;
                dy2 = pos.x;
                dy3 = pos.y;
                vType = 3.0;
            } else {
                if (type >= MITER && type < MITER + 3.5) {
                    if (inner > 0.5) {
                        dy = -dy;
                        inner = 0.0;
                    }
                    float sign = step(0.0, dy) * 2.0 - 1.0;
                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);
                    if (length(pos) > abs(dy) * MITER_LIMIT) {
                        type = BEVEL;
                    } else {
                        if (vertexNum < 4.5) {
                            dy = -dy;
                            pos = doBisect(norm, len, norm2, len2, dy, 1.0);
                        } else if (vertexNum < 5.5) {
                            pos = dy * norm;
                        } else if (vertexNum > 6.5) {
                            pos = dy * norm2;
                            // dy = ...
                        }
                    }
                    vType = 1.0;
                    dy = -sign * dot(pos, norm);
                    dy2 = -sign * dot(pos, norm2);
                }
                if (type >= BEVEL && type < BEVEL + 1.5) {
                    if (inner < 0.5) {
                        dy = -dy;
                        inner = 1.0;
                    }
                    vec2 norm3 = normalize((norm + norm2) / 2.0);
                    if (vertexNum < 4.5) {
                        pos = doBisect(norm, len, norm2, len2, dy, 1.0);
                        dy2 = -abs(dot(pos + dy * norm, norm3));
                    } else {
                        dy2 = 0.0;
                        dy = -dy;
                        if (vertexNum < 5.5) {
                            pos = dy * norm;
                        } else {
                            pos = dy * norm2;
                        }
                    }
                }
            }
        }

        pos += base;
        vDistance = vec4(dy, dy2, dy3, lineWidth) * resolution;
        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));
    }

    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);

    vColor = aColor * tint;
}`;
var smoothFrag = `
varying vec4 vColor;
varying vec4 vDistance;
varying float vType;
varying float vTextureId;
varying vec2 vTextureCoord;
varying float vTravel;
uniform sampler2D uSamplers[%MAX_TEXTURES%];

void main(void){
    float alpha = 1.0;
    float lineWidth = vDistance.w;
    if (vType < 0.5) {
        float left = max(vDistance.x - 0.5, -vDistance.w);
        float right = min(vDistance.x + 0.5, vDistance.w);
        float near = vDistance.y - 0.5;
        float far = min(vDistance.y + 0.5, 0.0);
        float top = vDistance.z - 0.5;
        float bottom = min(vDistance.z + 0.5, 0.0);
        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);
    } else if (vType < 1.5) {
        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);
        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);
        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);
        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);
        alpha = a2 * b2 - a1 * b1;
    } else if (vType < 2.5) {
        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);
        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);
        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);
    } else {
        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));
        float rad = vDistance.w;
        float left = max(dist2 - 0.5, -rad);
        float right = min(dist2 + 0.5, rad);
        // TODO: something has to be done about artifact at vDistance.x far side
        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));
    }

    vec4 texColor;
    float textureId = floor(vTextureId+0.5);
    %FOR_LOOP%

    gl_FragColor = vColor * texColor * alpha;
}
`;
var SmoothGraphicsProgram = class extends Program {
  constructor(settings2, vert = smoothVert, frag = smoothFrag, _uniforms = {}) {
    const { maxStyles, maxTextures } = settings2;
    vert = vert.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`).replace(/%MAX_STYLES%/gi, `${maxStyles}`);
    frag = frag.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`).replace(/%FOR_LOOP%/gi, SmoothGraphicsShader.generateSampleSrc(maxTextures));
    super(vert, frag);
    this.settings = settings2;
  }
};
var SmoothGraphicsShader = class extends Shader {
  constructor(settings2, prog = new SmoothGraphicsProgram(settings2), uniforms = {}) {
    const { maxStyles, maxTextures } = settings2;
    const sampleValues = new Int32Array(maxTextures);
    for (let i = 0; i < maxTextures; i++) {
      sampleValues[i] = i;
    }
    super(prog, Object.assign(uniforms, {
      styleMatrix: new Float32Array(6 * maxStyles),
      styleTextureId: new Float32Array(maxStyles),
      styleLine: new Float32Array(2 * maxStyles),
      samplerSize: new Float32Array(2 * maxTextures),
      uSamplers: sampleValues,
      tint: new Float32Array([1, 1, 1, 1]),
      resolution: 1,
      expand: 1
    }));
    this.settings = settings2;
  }
  static generateSampleSrc(maxTextures) {
    let src = "";
    src += "\n";
    src += "\n";
    for (let i = 0; i < maxTextures; i++) {
      if (i > 0) {
        src += "\nelse ";
      }
      if (i < maxTextures - 1) {
        src += `if(textureId < ${i}.5)`;
      }
      src += "\n{";
      src += `
	texColor = texture2D(uSamplers[${i}], vTextureCoord);`;
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  }
};
var settings = {
  LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,
  SHADER_MAX_STYLES: 24,
  SHADER_MAX_TEXTURES: 4
};
var { BezierUtils: BezierUtils2, QuadraticUtils: QuadraticUtils2, ArcUtils: ArcUtils2 } = graphicsUtils;
var temp2 = new Float32Array(3);
var DEFAULT_SHADERS2 = {};
var SmoothGraphics = class extends Container {
  static __initStatic() {
    this._TEMP_POINT = new Point();
  }
  get geometry() {
    return this._geometry;
  }
  constructor(geometry = null) {
    super();
    this._geometry = geometry || new SmoothGraphicsGeometry();
    this._geometry.refCount++;
    this.shader = null;
    this.shaderSettings = {
      maxStyles: settings.SHADER_MAX_STYLES,
      maxTextures: settings.SHADER_MAX_TEXTURES
    };
    this.state = State.for2d();
    this._fillStyle = new FillStyle2();
    this._lineStyle = new LineStyle2();
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    this.batches = [];
    this.batchTint = -1;
    this.batchDirty = -1;
    this.vertexData = null;
    this.pluginName = "smooth";
    this._transformID = -1;
    this.tint = 16777215;
    this.blendMode = BLEND_MODES.NORMAL;
  }
  clone() {
    this.finishPoly();
    return new SmoothGraphics(this._geometry);
  }
  set blendMode(value) {
    this.state.blendMode = value;
  }
  get blendMode() {
    return this.state.blendMode;
  }
  get tint() {
    return this._tint;
  }
  set tint(value) {
    this._tint = value;
  }
  get fill() {
    return this._fillStyle;
  }
  get line() {
    return this._lineStyle;
  }
  lineStyle(options = null, color = 0, alpha = 1, alignment = 0.5, scaleMode = settings.LINE_SCALE_MODE) {
    if (typeof options === "number") {
      if (typeof scaleMode === "boolean") {
        scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;
      }
      options = { width: options, color, alpha, alignment, scaleMode };
    } else {
      const native = options.native;
      if (native !== void 0) {
        options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;
      }
    }
    return this.lineTextureStyle(options);
  }
  lineTextureStyle(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10,
      shader: null,
      scaleMode: settings.LINE_SCALE_MODE
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  }
  startPoly() {
    if (this.currentPath) {
      const points = this.currentPath.points;
      const len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  }
  finishPoly() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  }
  moveTo(x, y) {
    this.startPoly();
    this.currentPath.points[0] = x;
    this.currentPath.points[1] = y;
    return this;
  }
  lineTo(x, y) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    const points = this.currentPath.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  _initCurve(x = 0, y = 0) {
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x, y];
      }
    } else {
      this.moveTo(x, y);
    }
  }
  quadraticCurveTo(cpX, cpY, toX, toY) {
    this._initCurve();
    const points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils2.curveTo(cpX, cpY, toX, toY, points);
    return this;
  }
  bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils2.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    const points = this.currentPath.points;
    const result = ArcUtils2.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      const { cx, cy, radius: radius2, startAngle, endAngle, anticlockwise } = result;
      this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
    }
    return this;
  }
  arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    const sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const eps = this._geometry.closePointEps;
    let points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      const xDiff = Math.abs(points[points.length - 2] - startX);
      const yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils2.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  }
  beginFill(color = 0, alpha = 1, smooth = false) {
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha, smooth });
  }
  beginTextureFill(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null,
      smooth: false
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    const visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  }
  endFill() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  }
  drawRect(x, y, width, height) {
    return this.drawShape(new Rectangle(x, y, width, height));
  }
  drawRoundedRect(x, y, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));
  }
  drawCircle(x, y, radius) {
    return this.drawShape(new Circle(x, y, radius));
  }
  drawEllipse(x, y, width, height) {
    return this.drawShape(new Ellipse(x, y, width, height));
  }
  drawPolygon(...path) {
    let points;
    let closeStroke = true;
    const poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    const shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  }
  drawShape(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(
        shape,
        this._fillStyle.clone(),
        this._lineStyle.clone(),
        this._matrix
      );
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  }
  clear() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  }
  isFastRect() {
    const data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  }
  _renderCanvas(renderer) {
    Graphics.prototype._renderCanvas.call(this, renderer);
  }
  _render(renderer) {
    this.finishPoly();
    const geometry = this._geometry;
    const hasuint32 = renderer.context.supports.uint32Indices;
    geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);
    geometry.updateBatches(this.shaderSettings);
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  }
  _populateBatches() {
    const geometry = this._geometry;
    const blendMode = this.blendMode;
    const len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (let i = 0; i < len; i++) {
      const gI = geometry.batches[i];
      const color = gI.style.color;
      const vertexData = new Float32Array(
        this.vertexData.buffer,
        gI.attribStart * 4 * 2,
        gI.attribSize * 2
      );
      const batch = {
        vertexData,
        blendMode,
        // indices,
        // uvs,
        _batchRGB: hex2rgb(color),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i] = batch;
    }
  }
  _renderBatched(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (let i = 0, l = this.batches.length; i < l; i++) {
      const batch = this.batches[i];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  }
  _renderDirect(renderer) {
    const directShader = this._resolveDirectShader(renderer);
    let shader = directShader;
    const geometry = this._geometry;
    const tint = this.tint;
    const worldAlpha = this.worldAlpha;
    const uniforms = shader.uniforms;
    const drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
    uniforms.tint[3] = worldAlpha;
    uniforms.resolution = renderer.renderTexture.current ? renderer.renderTexture.current.resolution : renderer.resolution;
    const projTrans = renderer.projection.transform;
    if (projTrans) {
      const scale = Math.sqrt(projTrans.a * projTrans.a + projTrans.b * projTrans.b);
      uniforms.resolution *= scale;
    }
    uniforms.expand = (renderer.options.antialias ? 2 : 1) / uniforms.resolution;
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    shader = null;
    for (let i = 0, l = drawCalls.length; i < l; i++) {
      const drawCall = geometry.drawCalls[i];
      const shaderChange = shader !== drawCall.shader;
      if (shaderChange) {
        shader = drawCall.shader;
        if (shader) {
          shader.uniforms.translationMatrix = this.transform.worldTransform;
          if (shader.uniforms.tint) {
            shader.uniforms.tint[0] = uniforms.tint[0];
            shader.uniforms.tint[1] = uniforms.tint[1];
            shader.uniforms.tint[2] = uniforms.tint[2];
            shader.uniforms.tint[3] = uniforms.tint[3];
          }
        }
      }
      const { texArray, styleArray, size, start } = drawCall;
      const groupTextureCount = texArray.count;
      const shaderHere = shader || directShader;
      const texs = shaderHere.uniforms.styleTextureId;
      const mats = shaderHere.uniforms.styleMatrix;
      const lines = shaderHere.uniforms.styleLine;
      for (let i2 = 0; i2 < styleArray.count; i2++) {
        texs[i2] = styleArray.textureIds[i2];
        lines[i2 * 2] = styleArray.lines[i2 * 2];
        lines[i2 * 2 + 1] = styleArray.lines[i2 * 2 + 1];
        const m = styleArray.matrices[i2];
        mats[i2 * 6] = m.a;
        mats[i2 * 6 + 1] = m.c;
        mats[i2 * 6 + 2] = m.tx;
        mats[i2 * 6 + 3] = m.b;
        mats[i2 * 6 + 4] = m.d;
        mats[i2 * 6 + 5] = m.ty;
      }
      const sizes = shaderHere.uniforms.samplerSize;
      for (let i2 = 0; i2 < groupTextureCount; i2++) {
        sizes[i2 * 2] = texArray.elements[i2].width;
        sizes[i2 * 2 + 1] = texArray.elements[i2].height;
      }
      renderer.shader.bind(shaderHere);
      if (shaderChange) {
        renderer.geometry.bind(geometry);
      }
      for (let j = 0; j < groupTextureCount; j++) {
        renderer.texture.bind(texArray.elements[j], j);
      }
      renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);
    }
  }
  _resolveDirectShader(_renderer) {
    let shader = this.shader;
    const pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS2[pluginName]) {
        DEFAULT_SHADERS2[pluginName] = new SmoothGraphicsShader(this.shaderSettings);
      }
      shader = DEFAULT_SHADERS2[pluginName];
    }
    return shader;
  }
  _calculateBounds() {
    this.finishPoly();
    const geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    const { minX, minY, maxX, maxY } = geometry.bounds;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  }
  containsPoint(point) {
    this.worldTransform.applyInverse(point, SmoothGraphics._TEMP_POINT);
    return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT);
  }
  calculateTints() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      const tintRGB = hex2rgb(this.tint, temp2);
      for (let i = 0; i < this.batches.length; i++) {
        const batch = this.batches[i];
        const batchTint = batch._batchRGB;
        const r = tintRGB[0] * batchTint[0] * 255;
        const g = tintRGB[1] * batchTint[1] * 255;
        const b = tintRGB[2] * batchTint[2] * 255;
        const color = (r << 16) + (g << 8) + (b | 0);
        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      }
    }
  }
  calculateVertices() {
    const wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    const wt = this.transform.worldTransform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const data = this._geometry.points;
    const vertexData = this.vertexData;
    let count = 0;
    for (let i = 0; i < data.length; i += 2) {
      const x = data[i];
      const y = data[i + 1];
      vertexData[count++] = a * x + c * y + tx;
      vertexData[count++] = d * y + b * x + ty;
    }
  }
  closePath() {
    const currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
    }
    return this;
  }
  setMatrix(matrix) {
    this._matrix = matrix;
    return this;
  }
  beginHole() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  }
  endHole() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  }
  destroy(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    super.destroy(options);
  }
  drawStar(x, y, points, radius, innerRadius, rotation = 0) {
    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));
  }
};
SmoothGraphics.__initStatic();
var Star = class extends Polygon {
  constructor(x, y, points, radius, innerRadius, rotation = 0) {
    innerRadius = innerRadius || radius / 2;
    const startAngle = -1 * Math.PI / 2 + rotation;
    const len = points * 2;
    const delta = PI_2 / len;
    const polygon = [];
    for (let i = 0; i < len; i++) {
      const r = i % 2 ? innerRadius : radius;
      const angle = i * delta + startAngle;
      polygon.push(
        x + r * Math.cos(angle),
        y + r * Math.sin(angle)
      );
    }
    super(polygon);
  }
};
var dashFrag = `
varying vec4 vColor;
varying vec4 vDistance;
varying float vType;
varying float vTextureId;
varying vec2 vTextureCoord;
varying float vTravel;
uniform sampler2D uSamplers[%MAX_TEXTURES%];
uniform float dash;
uniform float gap;

void main(void){
    float alpha = 1.0;
    float lineWidth = vDistance.w;
    if (vType < 0.5) {
        float left = max(vDistance.x - 0.5, -vDistance.w);
        float right = min(vDistance.x + 0.5, vDistance.w);
        float near = vDistance.y - 0.5;
        float far = min(vDistance.y + 0.5, 0.0);
        float top = vDistance.z - 0.5;
        float bottom = min(vDistance.z + 0.5, 0.0);
        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);
    } else if (vType < 1.5) {
        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);
        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);
        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);
        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);
        alpha = a2 * b2 - a1 * b1;
    } else if (vType < 2.5) {
        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);
        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);
        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);
    } else {
        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));
        float rad = vDistance.w;
        float left = max(dist2 - 0.5, -rad);
        float right = min(dist2 + 0.5, rad);
        // TODO: something has to be done about artifact at vDistance.x far side
        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));
    }

    if (dash + gap > 1.0)
    {
        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);
        float left = max(travel - 0.5, -0.5);
        float right = min(travel + 0.5, gap + 0.5);
        alpha *= max(0.0, right - left);
    }

    vec4 texColor;
    float textureId = floor(vTextureId+0.5);
    %FOR_LOOP%

    gl_FragColor = vColor * texColor * alpha;
}
`;
var DashLineShader = class extends SmoothGraphicsShader {
  constructor(dashParams) {
    const settings2 = { maxStyles: 16, maxTextures: 1 };
    super(
      settings2,
      new SmoothGraphicsProgram(settings2, void 0, dashFrag),
      dashParams || {
        dash: 5,
        gap: 8
      }
    );
  }
};
export {
  BATCH_POOL2 as BATCH_POOL,
  BatchDrawCall2 as BatchDrawCall,
  BatchPart2 as BatchPart,
  BatchStyleArray,
  BuildData,
  CircleBuilder,
  DRAW_CALL_POOL2 as DRAW_CALL_POOL,
  DashLineShader,
  FILL_COMMANDS2 as FILL_COMMANDS,
  FillStyle2 as FillStyle,
  JOINT_TYPE,
  LINE_SCALE_MODE,
  LineStyle2 as LineStyle,
  PolyBuilder,
  RectangleBuilder,
  RoundedRectangleBuilder,
  SegmentPacker,
  SmoothGraphics,
  SmoothGraphicsData,
  SmoothGraphicsGeometry,
  SmoothGraphicsProgram,
  SmoothGraphicsShader,
  Star,
  matrixEquals,
  settings
};
/*! Bundled license information:

@pixi/graphics/dist/esm/graphics.js:
  (*!
   * @pixi/graphics - v6.1.2
   * Compiled Thu, 12 Aug 2021 17:11:19 UTC
   *
   * @pixi/graphics is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@pixi/graphics-smooth/lib/pixi-graphics-smooth.es.js:
  (*!
   * @pixi/graphics-smooth - v0.0.13
   * Compiled Wed, 07 Jul 2021 12:07:12 UTC
   *
   * @pixi/graphics-smooth is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved
   *)
*/
//# sourceMappingURL=@pixi_graphics-smooth.js.map
