import {
  Rectangle
} from "./chunk-R5PW3AE4.js";
import "./chunk-DFKQJ226.js";

// pixi-graph/node_modules/@pixi-essentials/cull/lib/cull.es.js
var tempRect = new Rectangle();
var Cull = class {
  /**
   * @param options
   * @param [options.recursive] - whether culling should be recursive
   * @param [options.toggle='renderable'] - which property of display-object was be set to indicate
   *      its culling state. It should be one of `renderable`, `visible`.
   */
  constructor(options = {}) {
    this._recursive = typeof options.recursive === "boolean" ? options.recursive : true;
    this._toggle = options.toggle || "visible";
    this._targetList = /* @__PURE__ */ new Set();
  }
  /**
   * Adds a display-object to the culling list
   *
   * @param target - the display-object to be culled
   * @return this
   */
  add(target) {
    this._targetList.add(target);
    return this;
  }
  /**
   * Adds all the display-objects to the culling list
   *
   * @param targets - the display-objects to be culled
   * @return this
   */
  addAll(targets) {
    for (let i = 0, j = targets.length; i < j; i++) {
      this._targetList.add(targets[i]);
    }
    return this;
  }
  /**
   * Removes the display-object from the culling list
   *
   * @param target - the display-object to be removed
   * @return this
   */
  remove(target) {
    this._targetList.delete(target);
    return this;
  }
  /**
   * Removes all the passed display-objects from the culling list
   *
   * @param targets - the display-objects to be removed
   * @return this
   */
  removeAll(targets) {
    for (let i = 0, j = targets.length; i < j; i++) {
      this._targetList.delete(targets[i]);
    }
    return this;
  }
  /**
   * Clears the culling list
   *
   * @return this
   */
  clear() {
    this._targetList.clear();
    return this;
  }
  /**
   * @param rect - the rectangle outside of which display-objects should be culled
   * @param skipUpdate - whether to skip unculling, transform update, bounds calculation. It is
   *  highly recommended you enable this by calling _this.uncull()_ and _root.getBounds(false)_ manually
   *  before your render loop.
   * @return this
   */
  cull(rect, skipUpdate = false) {
    if (!skipUpdate) {
      this.uncull();
    }
    this._targetList.forEach((target) => {
      if (!skipUpdate) {
        target.getBounds(false, tempRect);
      }
      if (this._recursive) {
        this.cullRecursive(rect, target, skipUpdate);
      } else {
        if (skipUpdate) {
          target._bounds.getRectangle(rect);
        }
        target[this._toggle] = tempRect.right > rect.left && tempRect.left < rect.right && tempRect.bottom > rect.top && tempRect.top < rect.bottom;
      }
    });
    return this;
  }
  /**
   * Sets all display-objects to the unculled state.
   *
   * This happens regardless of whether the culling toggle was set by {@code this.cull} or manually. This
   * is why it is recommended to one of `visible` or `renderable` for normal use and the other for culling.
   *
   * @return this
   */
  uncull() {
    this._targetList.forEach((target) => {
      if (this._recursive) {
        this.uncullRecursive(target);
      } else {
        target[this._toggle] = false;
      }
    });
    return this;
  }
  /**
   * Recursively culls the subtree of {@code displayObject}.
   *
   * @param rect - the visiblity rectangle
   * @param displayObject - the root of the subtree to cull
   * @param skipUpdate - whether to skip bounds calculation. However, transforms are expected to be updated by the caller.
   */
  cullRecursive(rect, displayObject, skipUpdate) {
    const bounds = skipUpdate ? displayObject._bounds.getRectangle(tempRect) : displayObject.getBounds(true, tempRect);
    displayObject[this._toggle] = bounds.right > rect.left && bounds.left < rect.right && bounds.bottom > rect.top && bounds.top < rect.bottom;
    const fullyVisible = bounds.left >= rect.left && bounds.top >= rect.top && bounds.right <= rect.right && bounds.bottom <= rect.bottom;
    if (!fullyVisible && displayObject[this._toggle] && displayObject.children && displayObject.children.length) {
      const children = displayObject.children;
      for (let i = 0, j = children.length; i < j; i++) {
        this.cullRecursive(rect, children[i]);
      }
    }
  }
  /**
   * Recursively unculls the subtree of {@code displayObject}.
   *
   * @param displayObject
   */
  uncullRecursive(displayObject) {
    displayObject[this._toggle] = true;
    if (displayObject.children && displayObject.children.length) {
      const children = displayObject.children;
      for (let i = 0, j = children.length; i < j; i++) {
        this.uncullRecursive(children[i]);
      }
    }
  }
};
export {
  Cull
};
/*! Bundled license information:

@pixi-essentials/cull/lib/cull.es.js:
  (*!
   * @pixi-essentials/cull - v1.0.12
   * Compiled Wed, 17 Mar 2021 16:10:19 UTC
   *
   * @pixi-essentials/cull is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   * 
   * Copyright 2019-2020, Shukant Pal <shukantpal@outlook.com>, All Rights Reserved
   *)
*/
//# sourceMappingURL=@pixi-essentials_cull.js.map
